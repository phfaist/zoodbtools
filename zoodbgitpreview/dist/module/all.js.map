{"mappings":"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","sources":["zoodbgitpreview/all.js","zoodbgitpreview/ZooDbGithubRepoPreviewComponent.jsx","zoodbgitpreview/GithubRepoSelector.jsx","zoodbgitpreview/useBrowserFs.js"],"sourcesContent":["export { ZooDbGithubRepoPreviewComponent } from './ZooDbGithubRepoPreviewComponent.jsx';\nexport * from './useBrowserFs.js';\n","import path from 'path';\n\nimport debugm from 'debug';\nconst debug = debugm('zoodbgitpreview.ZooDbGithubRepoPreviewComponent');\n\nimport git from 'isomorphic-git';\nimport gitHttp from 'isomorphic-git/http/web/index.js';\n\nimport React, { useState, useRef, useEffect } from 'react';\n\nimport { ZooDbPreviewComponent } from '@phfaist/zoodbtools_preview';\n\n\nimport { GithubRepoSelector } from './GithubRepoSelector.jsx';\n\n\nwindow.git = git;\nwindow.gitHttp = gitHttp;\n\n\nexport function ZooDbGithubRepoPreviewComponent(props)\n{\n    let {\n        githubUser,\n        githubRepo,\n        allowChoosePullRequest,\n        fs,\n        loadZooDbFromFsDir,\n        mainBranchName,\n        fsWorkDir,\n        initialObjectType,\n        initialObjectId,\n        commandButtonsUseReload,\n        commandButtonsToggleDarkModeCallback,\n        renderObject,\n        getMathJax,\n    } = props;\n\n    allowChoosePullRequest ??= true;\n    fsWorkDir ??= \"/git-work\"\n    mainBranchName ??= 'main'\n    let fsRepoDir = `${fsWorkDir}/${githubUser}-${githubRepo}`\n\n    commandButtonsUseReload ??= false;\n\n    const [ gitBranch, setGitBranch ] = useState({\n         branch: mainBranchName,\n         userLoadVersion: 0,\n    });\n\n    // to help with in-browser debugging\n    window.fsRepoDir = fsRepoDir;\n    window.githubUser = githubUser;\n    window.githubRepo = githubRepo;\n\n    const doGitCheckoutAppropriateVersion = async () => {\n\n        //\n        // fetch and checkout the relevant git branch in\n        //\n\n        let gitRemoteRef = mainBranchName;\n        //let gitRef = mainBranchName;\n        if (gitBranch.pullRequestNumber != null) {\n            gitRemoteRef = `pull/${gitBranch.pullRequestNumber}/head`;\n            //gitRef = `pr-${gitBranch.pullRequestNumber}`;\n        }\n\n        debug(`Calling git.fetch()`, { gitRemoteRef, //gitRef,\n                                      gitBranch });\n\n        let fetchResult = await git.fetch({\n            fs,\n            http: gitHttp,\n            dir: fsRepoDir,\n            corsProxy: 'https://cors.isomorphic-git.org',\n            url: `https://github.com/${githubUser}/${githubRepo}.git`,\n            remoteRef: gitRemoteRef,\n            ref: gitRemoteRef, //gitRef,\n            singleBranch: true,\n            depth: 1, // NOT 0 !!!\n\n            //author: { name: 'git-preview-test', email: 'noemail@example.com' },\n        });\n\n        // and do 'git checkout' for the appropriate version\n\n        debug(`Calling git.checkout() to checkout ${fetchResult.fetchHead} `\n              + `(${fetchResult.fetchHeadDescription})`);\n\n        await git.checkout({\n            fs,\n            dir: fsRepoDir,\n            ref: fetchResult.fetchHead,\n        });\n\n    };\n\n\n    const loadZooDb = async () => {\n        \n        // see if we have our special marker in the folder\n        let needsClone = true;\n        const metaInfoFileName = path.join(fsRepoDir, '_zoodbgitpreview_git_repo.json');\n        try {\n            let data = await fs.promises.readFile(metaInfoFileName);\n            let d = JSON.parse(data);\n            if (d.githubUser === githubUser && d.githubRepo === githubRepo) {\n                needsClone = false;\n            }\n        } catch (err) {\n            debug(`Couldn't read ${metaInfoFileName}, will do a fresh repository clone`);\n        }\n\n        if (needsClone) {\n\n            // Clear up any existing work dir folder\n            await fs.promises.rm(fsRepoDir, { recursive: true });\n\n            debug(`About to git clone...`);\n\n            await git.clone({\n                fs,\n                http: gitHttp,\n                dir: fsRepoDir,\n                corsProxy: 'https://cors.isomorphic-git.org',\n                url: `https://github.com/${githubUser}/${githubRepo}.git`,\n                ref: mainBranchName,\n                singleBranch: true,\n                depth: 1, // NOT 0 !!!\n            });\n\n            await fs.promises.writeFile(metaInfoFileName, JSON.stringify(\n                { githubUser, githubRepo }\n            ));\n            \n            debug(`Cloned repository.  Folder ${fsRepoDir} now -> `,\n                await fs.promises.readdir(`${fsRepoDir}`));\n\n        } else {\n\n            await doGitCheckoutAppropriateVersion();\n\n        }\n\n        let zoodb = await loadZooDbFromFsDir({ fsRepoDir });\n    \n        // for in-browser debugging\n        window.zoodb = zoodb;\n\n        return zoodb;\n    };\n\n    const reloadZooDb = async (zoodb) => {\n\n        debug(`Called reloadZooDb()`);\n\n        await doGitCheckoutAppropriateVersion();\n\n        // now, initiate a zoo reload.\n\n        debug(`Reloading the zoo now`);\n        \n        await zoodb.load();\n\n        return zoodb;\n    };\n\n    debug(`In ZooDbGithubRepoPreviewComponent render, gitBranch is`, gitBranch);\n\n    //\n    // Render the component\n    //\n    return (\n        <ZooDbPreviewComponent\n            loadZooDb={loadZooDb}\n            reloadZooDb={reloadZooDb}\n            renderObject={renderObject}\n            getMathJax={getMathJax}\n            initialObjectType={initialObjectType}\n            initialObjectId={initialObjectId}\n            commandButtonsUseReload={commandButtonsUseReload}\n            commandButtonsToggleDarkModeCallback={commandButtonsToggleDarkModeCallback}\n            userLoadVersion={gitBranch.userLoadVersion}\n            >\n            <GithubRepoSelector\n                githubUser={githubUser}\n                githubRepo={githubRepo}\n                mainBranchName={mainBranchName}\n                allowChoosePullRequest={allowChoosePullRequest}\n                onGitBranchSelected={\n                    (newGitBranch) => setGitBranch({...newGitBranch, userLoadVersion: gitBranch.userLoadVersion+1})\n                }\n            />\n        </ZooDbPreviewComponent>\n    );\n\n\n}\n","import debugm from 'debug';\nconst debug = debugm('zoodbgitpreview.GithubRepoSelector');\n\nimport React from 'react';\n\nexport function GithubRepoSelector(props)\n{\n    const {\n        githubUser,\n        githubRepo,\n        mainBranchName,\n        onGitBranchSelected,\n    } = props;\n\n    debug('rendering github repo selector');\n\n    const btnClicked = (event) => {\n        const prText = document.getElementById('show-gh-select-input-pull-request').value;\n        if (prText != null && prText != \"\") {\n            // we seem to have selected a PR\n            let pullRequestNumber = parseInt(prText);\n            debug('pr selected!', { pullRequestNumber });\n            onGitBranchSelected({ pullRequestNumber, });\n        } else {\n            alert(`Please enter a pull request number to view`);\n        }\n    };\n    const btnMainClicked = (event) => {\n        onGitBranchSelected({ branch: mainBranchName });\n    };\n    return (\n        <div className=\"GithubRepoSelector\">\n            <span className=\"show-gh-user\">{githubUser}</span>\n            {\":\"}\n            <span className=\"show-gh-repo\">{githubRepo}</span>\n            <label htmlFor=\"show-gh-select-input-pull-request\">Pull Request #:</label>\n            <input type=\"text\" size=\"10\" id=\"show-gh-select-input-pull-request\" />\n            <button onClick={btnClicked}>Go to PR!</button>\n            <button onClick={btnMainClicked}>Go to main branch</button>\n        </div>\n    );\n}","import debugm from 'debug';\nconst debug = debugm('zoodbgitpreview.useBrowserfs');\n\nimport path from 'path';\n\nimport stream from 'stream';\nimport * as BrowserFS from 'browserfs';\n\nimport pify from 'pify';\n\n\n// ----------------------------------------------------------------------------\n\nexport async function fsExists(filePath, fs)\n{\n    let fsp = fs.promises;\n    try {\n        let fileStat = await fsp.lstat(filePath);\n        //console.log('path', filePath, 'exists -> ', fileStat);\n        return true;\n    } catch (e) {\n        console.log('path', filePath, 'does not seem to exist', e);\n    }\n    return false;\n}\n\n// rm -rf ...  thanks https://stackoverflow.com/a/32197381/1694896\nexport async function deleteFolderRecursive(directoryPath, fs)\n{\n    //console.log('deleteFolderRecursive', { directoryPath, fs });\n    let fsp = fs.promises;\n\n    let fileExists = await fsExists(directoryPath, fs);    \n    if (fileExists) {\n        const dirEntries = await fsp.readdir(directoryPath);\n        for (const file of dirEntries) {\n            const curPath = path.join(directoryPath, file);\n            const curStat = await fsp.lstat(curPath);\n            //console.log(`encountered file \"${directoryPath}\" / \"${file}\" -> `, curStat);\n            if (curStat.isDirectory()) {\n                // recurse\n                await deleteFolderRecursive(curPath, fs);\n            } else {\n                // delete file\n                await fsp.unlink(curPath);\n                //console.log(`removed file \"${curPath}\"; exists? = `, await fsExists(curPath, fs));\n            }\n        }\n        //console.log(`Recursively cleaned out ${directoryPath}, entries are now: `,\n        //            await fsp.readdir(directoryPath));\n        await fsp.rmdir(directoryPath);\n    }\n};\n\nexport function createSimpleBufferReadStream(buffer)\n{\n    let buf = buffer;\n    return new stream.Readable({\n        read(/*size*/) {\n            if (buf != null) {\n                this.push(buf);\n                buf = null;\n            }\n            this.push(null);\n        }\n    });\n}\n\n\n\n\nexport async function fixupBrowserFsObject(fs)\n{\n\n    // add fs.promises\n    fs.promises = {};\n    for (const method of ['access','appendFile','chmod','chown','close',\n        //'copyFile',\n        'exists','fchmod','fchown','fdatasync','fstat','fsync','ftruncate','futimes','lchmod','lchown','link','lstat','mkdir',\n        //'mkdtemp',\n        'open','read','readFile','readdir','readlink','realpath','rename','rmdir',\n        //'rm',\n        'stat','symlink','truncate','unlink','utimes','write','writeFile',]) {\n        debug(`Promisifying fs.${method} ...`);\n        fs.promises[method] = pify(fs[method]);\n    }\n    debug(`Added fs.promises`);\n\n    // patch up access()\n    fs.promises.access = async (filePath) => {\n        if (await fsExists(filePath, fs)) {\n            return true;\n        }\n        throw new Error(`access() test patch: file ${filePath} does not exist`);\n    };\n\n    // patch up createReadStream()\n    fs.createReadStream = async (filePath) => {\n        let content = await fs.promises.readFile(filePath);\n        return createSimpleBufferReadStream(content);\n    };\n\n    // patch up fs.promises.rm(..., { recursive: true|false, force: true|false})\n    fs.promises.rm = async (filePath, { recursive }) => {\n        // TODO, should actually raise an error if filePath doesn't exist ... oh\n        // well, that's too bad.\n        if (recursive) {\n            return await deleteFolderRecursive(filePath, fs);\n        }\n        return await fs.promises.unlink(filePath);\n    };\n\n}\n\n// -----------------------------------------------------------------------------\n\nexport async function setupBrowserFs(browserFsConfig, options={})\n{\n    BrowserFS.install(window);\n    const fs = await new Promise( (accept, reject) => {\n        BrowserFS.configure(\n            browserFsConfig,\n            function (e) {\n                if (e) {\n                    // An error happened!\n                    reject(e);\n                }\n                // Otherwise, BrowserFS is ready-to-use!\n                const fs = BrowserFS.BFSRequire('fs');\n                accept(fs);\n            }\n        );\n    } );\n    debug(`Got fs object from BrowserFS`, { fs });\n\n    if (options.setGlobalWindowProperty ?? true) {\n        window.fs = fs;\n    }\n\n    await fixupBrowserFsObject(fs);\n\n    return fs;\n}\n"],"names":[],"version":3,"file":"all.js.map"}