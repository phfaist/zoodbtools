{"db":{"schemas":{"code":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/code","type":"object","additionalProperties":false,"required":["code_id","name","description","_meta"],"_zoo_primarykey":"code_id","_zoo_relations":[{"object_field":"physical","to_object_type":"space","relation_primary_key_field":true,"allow_null":true},{"object_field":"logical","to_object_type":"space","relation_primary_key_field":true,"allow_null":true},{"object_field":"relations.parents","to_object_type":"code","relation_primary_key_field":"code_id","relation_add_object_field":"code","backreference":{"field":"relations.parent_of"}},{"object_field":"relations.cousins","to_object_type":"code","relation_primary_key_field":"code_id","relation_add_object_field":"code","backreference":{"field":"relations.cousin_of"}},{"object_field":"_meta.changelog","to_object_type":"user","relation_primary_key_field":"user_id","relation_add_object_field":"user","backreference":{"field":"zoo_contributions.code"}}],"properties":{"code_id":{"type":"string","pattern":"^[a-z0-9_.-]+$","_single_line_string":true,"_description":"An internal identifier for the code.  It must be unique across all codes on the error correction zoo."},"name":{"type":"string","_flm":"standalone","_single_line_string":true,"_description":"The name of the code.  It is listed in multiple places, so don't make it too long."},"short_name":{"type":"string","_flm":"standalone","_single_line_string":true,"_description":"(Optional.) A short name in case the 'name' field is long.  The short name is used in places where space is precious, such as in the navigation links in the header bar.  If no 'short_name' is provided, the 'name' field is used in those places instead."},"alternative_names":{"type":"array","_description":"Alternative name(s) under which this code is known.","items":{"type":"string","_flm":"standalone","_single_line_string":true}},"description":{"type":"string","_flm":"full","_description":"Describe code subspace as best as you can here.  Anything applicable to a larger parent set of codes (see below) should go in that entry instead of here."},"introduced":{"type":"string","_single_line_string":true,"_flm":"full","_description":"First reference with the code (optional).  This field should be a single ‘\\cite{}’ command with the appropriate reference(s).  Recall that you can cite multiple references with a single ‘\\cite’ command, separating keys with commas."},"physical":{"type":"string","_single_line_string":true},"logical":{"type":"string","_single_line_string":true},"protection":{"_flm":"full","type":"string"},"features":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/code_features","type":"object","additionalProperties":false,"required":[],"properties":{"rate":{"type":"string","_flm":"full"},"magic_scaling_exponent":{"type":"string","_flm":"full"},"encoders":{"type":"array","items":{"type":"string","_flm":"full"}},"general_gates":{"type":"array","items":{"type":"string","_flm":"full"}},"decoders":{"type":"array","items":{"type":"string","_flm":"full"}},"transversal_gates":{"type":"string","_flm":"full"},"fault_tolerance":{"type":"array","items":{"type":"string","_flm":"full"}},"threshold":{"type":"array","items":{"type":"string","_flm":"full"}},"code_capacity_threshold":{"type":"array","items":{"type":"string","_flm":"full"}}}},"realizations":{"type":"array","items":{"_flm":"full","type":"string"}},"notes":{"type":"array","items":{"_flm":"full","type":"string"}},"relations":{"type":"object","additionalProperties":false,"properties":{"parents":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/code_relation_list","type":"array","items":{"type":"object","required":["code_id"],"additionalProperties":false,"properties":{"code_id":{"_single_line_string":true,"type":"string"},"detail":{"_flm":"full","type":"string"},"code":{"_auto_populated":true}}}},"cousins":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/code_relation_list","type":"array","items":{"type":"object","required":["code_id"],"additionalProperties":false,"properties":{"code_id":{"_single_line_string":true,"type":"string"},"detail":{"_flm":"full","type":"string"},"code":{"_auto_populated":true}}}},"parent_of":{"_auto_populated":true,"type":"array","items":{"type":"object","properties":{"detail":{"_flm":"full"}}}},"cousin_of":{"_auto_populated":true,"type":"array","items":{"type":"object","properties":{"detail":{"_flm":"full"}}}},"defines_kingdom":{"_auto_populated":true}}},"_meta":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/meta","_description":"The _meta field contains additional meta-information data about the error correction zoo entry itself.  We store among others the list of people who have contributed to this particular entry.","_use_schemadata":false,"type":"object","additionalProperties":false,"properties":{"changelog":{"_description":"The list of significant edits to this entry, in chronological order. Edits are included only if the contribution is substantial; fixing typos and formatting tweaks are not considered substantial contributions.\nMake sure you add your own name here if you're editing this entry!","type":"array","items":{"type":"object","additionalProperties":false,"required":["user_id","date"],"properties":{"user_id":{"type":"string","_single_line_string":true},"date":{"type":"string","pattern":"^[0-9]{4}-[0-9]{2}(-[0-9]{2})?$","_single_line_string":true,"_description":"(Approximate) date of the modification, in the format YYYY-MM-DD or YYYY-MM"},"notes":{"type":"string","_description":"Any additional notes that are worty to store with regards to this particular edit.  Usually you should leave this blank."}}}},"stub":{"_description":"Set to true if this entry is a stub and is intended to be completed at a later time.","type":"boolean"}}}}},"space":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/space","_zoo_primarykey":"space_id","type":"object","additionalProperties":false,"required":["space_id"],"properties":{"space_id":{"type":"string","_single_line_string":true,"pattern":"^[a-z0-9_.-]+$"},"name":{"type":"string","_single_line_string":true,"_flm":"standalone"},"description":{"type":"string","_flm":"full"}}},"domain":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/domain","_zoo_primarykey":"domain_id","type":"object","additionalProperties":false,"required":["domain_id","name","description"],"properties":{"domain_id":{"type":"string","_single_line_string":true,"pattern":"^[a-z0-9_.-]+$"},"name":{"type":"string","_flm":"standalone","_single_line_string":true},"description":{"type":"string","_flm":"full"},"kingdoms":{"_auto_populated":true}}},"kingdom":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/kingdom","_zoo_primarykey":"kingdom_id","type":"object","additionalProperties":false,"required":["kingdom_id","name","parent_domain","kingdom_code"],"properties":{"kingdom_id":{"type":"string","_single_line_string":true,"pattern":"^[a-z0-9_.-]+$"},"name":{"type":"string","_single_line_string":true,"_flm":"standalone"},"description":{"type":"string","_flm":"full"},"parent_domain":{"type":"object","additionalProperties":false,"properties":{"domain_id":{"type":"string","pattern":"^[a-z0-9_.-]+$","_single_line_string":true}}},"kingdom_code":{"type":"object","additionalProperties":false,"requried":["code_id"],"properties":{"code_id":{"type":"string","_single_line_string":true,"pattern":"^[a-z0-9_.-]+$"},"code":{"_auto_populated":true}}}},"_zoo_relations":[{"object_field":"parent_domain","to_object_type":"domain","relation_primary_key_field":"domain_id","relation_add_object_field":"domain","backreference":{"field":"kingdoms"}},{"object_field":"kingdom_code","to_object_type":"code","relation_primary_key_field":"code_id","relation_add_object_field":"code","backreference":{"field":"relations.defines_kingdom"}}]},"codelist":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/codelist","_zoo_primarykey":"list_id","type":"object","additionalProperties":false,"required":["list_id","title","codes","display"],"properties":{"list_id":{"type":"string","pattern":"^[a-z0-9_.-]+$"},"title":{"type":"string","_flm":"standalone"},"intro":{"type":"string","_flm":"full"},"display":{"type":"object","additionalProperties":false,"properties":{"style":{"type":"string"},"options":{"type":"object"}}},"codes":{"type":"object","additionalProperties":false,"required":["select"],"properties":{"select":{"type":"array","items":{"type":"object","additionalProperties":false,"properties":{"property_set":{"type":"string"},"property":{"type":"object","required":["name","value"],"properties":{"name":{"type":"string"},"value":{"type":"string"}}},"domain":{"type":"string"},"descendant_of":{"type":"string"},"cousin_of":{"type":"string"},"manual_code_list":{"type":"array","items":{"type":"string"}}}}}}},"sort":{"type":"object","additionalProperties":false,"properties":{"by":{"type":"string"},"reverse":{"type":"boolean"},"case_sensitive":{"type":"boolean"},"parents_before_children":{"type":"boolean"}}},"metainfo":{"type":"object"}}},"user":{"$schema":"http://json-schema.org/draft-06/schema","$id":"https://errorcorrectionzoo.org/schemas/user","type":"object","additionalProperties":{},"required":["user_id","name"],"_zoo_primarykey":"user_id","properties":{"user_id":{"type":"string","pattern":"^[a-zA-Z0-9]+$","_single_line_string":true,"_description":"A unique, internal identifier for the user.","_zoo_search":{"include_in_index":false}},"name":{"type":"string","_single_line_string":true,"_description":"The user's full name, as it should be displayed.","_zoo_search":{"include_in_index":true}},"zooteam":{"type":"string","_single_line_string":true,"_description":"Zoo team indicates membership to a particular \"team\" (Core, Veterinarians, Code Contributors).  Leave blank for code contributors.","_zoo_search":{"include_in_index":false}},"zoorole":{"type":"string","_single_line_string":true,"_description":"Zoo role is applicable to core team members, otherwise omit field.","_zoo_search":{"include_in_index":false}},"githubusername":{"type":"string","_single_line_string":true,"_description":"The user's username on github.com"},"gscholaruser":{"type":"string","_single_line_string":true,"_description":"The user's Google scholar profile ID","_zoo_search":{"include_in_index":false}},"pageurl":{"type":"string","_single_line_string":true,"_description":"The user's web page URL","_zoo_search":{"include_in_index":false}},"avatarurl":{"type":"string","_single_line_string":true,"_description":"A link to a profile picture (image) for this user","_zoo_search":{"include_in_index":false}},"zoo_contributions":{"type":"object","_auto_populated":true,"_zoo_search":{"include_in_index":false},"properties":{"code":{"type":"array","items":{}}}}}}},"objects":{"code":{"approximate_oaecc":{"code_id":"approximate_oaecc","name":"Approximate operator-algebra error-correcting code","short_name":"Approximate operator-algebra QECC","introduced":"\\cite{arXiv:0907.4207,arXiv:0907.5391}","description":"Code encoding quantum and/or classical information that approximately corrects against noise affecting operators forming an algebra.","protection":"Given some algebra \\(\\mathcal{A}\\), \\(\\mathcal{A}\\) is \\textit{\\(\\epsilon\\)-correctable} under noise channel \\(\\mathcal{N}\\) if there exists some quantum channel \\(\\mathcal{R}\\) such that\n\\begin{align}\n  ||(\\mathcal{R}\\circ\\mathcal{N})-P_{\\mathcal{A}}||_{\\diamond}\\leq\\epsilon~,\n\\end{align}\nwhere \\(P_{\\mathcal{A}}\\) is the projector onto algebra \\(A\\) and we use the diamond norm \\(\\diamond\\) \\cite{arxiv:quant-ph/9806029}.\n\nLet the minimal error for some algebra \\(\\mathcal{A}\\) under noise channel \\(\\mathcal{N}\\) be\n\\begin{align}\n  \\epsilon_{\\mathcal{A}}=\\min_{\\mathcal{R}} ||\\mathcal{R}\\circ\\mathcal{N}-P_{\\mathcal{A}}||_{\\diamond}~.\n\\end{align}\nLet \\(\\delta_{\\mathcal{A}}=||\\mathcal{N}^C-\\mathcal{N}^C\\circ P_{\\mathcal{A}'}||_{\\diamond}\\)\nfor commutant \\(\\mathcal{A}'\\) of algebra \\(\\mathcal{A}\\) and complementary channel \\(\\mathcal{N}^C\\) of noise channel \\(\\mathcal{N}\\). Then \\cite{arXiv:0907.4207},\n\\begin{align}\n  \\delta_{\\mathcal{A}}^2/4\\leq \\epsilon_{\\mathcal{A}}\\leq 2\\delta_{\\mathcal{A}}^{1/2}~.\n\\end{align}\n","relations":{"parents":[{"code_id":"oaecc"}]},"_meta":{"changelog":[{"user_id":"M10T","date":"2023-06-26"},{"user_id":"M10T","date":"2023-06-22"}]},"_zoodb":{"id":"approximate_oaecc","source_file_path":"codes/approximate_oaecc.yml","source_file_modification_token":1689550329215.6897}},"analog":{"code_id":"analog","physical":"reals","logical":"reals","name":"Sphere packing","description":"Encodes states (codewords) into coordinates in the \\(n\\)-dimensional real coordinate space \\(\\mathbb{R}^n\\).\nThe number of codewords may be infinite because the coordinate space is infinite, so various restricted versions have to be constructed in practice.\n\nSphere packings provide ways of encoding digital or analog information into the frequency, amplitude, and phase of one or more analog waveforms for transmission through, e.g., an optical fiber or free space.\nThis is due to Kotelnikov's \\cite{manual:{V. A. Kotelnikov, “The theory of optimum noise immunity,” PhD Thesis, Molotov Energy Institute, Moscow, Jan. 1947}} and Shannon's \\cite{doi:10.1109/JRPROC.1949.232969} fundamental observation that a discretized electromagnetic signal of finite bandwidth and average power \\(P\\) can be represented as a vector in \\(\\mathbb{R}^n\\) with norm \\(nP\\).\nQuestions of capacity of electromagnetic communication channels then translate to packing problems in \\(\\mathbb{R}^n\\) \\cite{doi:10.1007/978-1-4757-6568-7}.\n\nIn the electromagnetic context, the information stored in the code is called the \\textit{bitstream}, coordinates used for encoding are often called \\textit{signal points} and form a \\textit{constellation}, and \\(\\mathbb{R}^n\\) is called the \\textit{signal space}.\n","protection":"Sphere packings can be used to transmist information using electromagnetic signals. The primary noise channel for such signals is the \\textit{additive Gaussian white-noise channel (AGWN)}, which adds a random Gaussian-distributed displacement with variance \\(\\sigma^2\\) to each signal point.\nProtection of a constellation thus depends on how far apart its points are in terms of the Euclidean distance.\nAs usual, there is a tradeoff between packing of space and level of protection.\nFor a given \\(n,M,P\\), the \\textit{Gaussian channel coding problem} asks to find a set of \\(M\\) codewords of norm \\(\\leq nP\\) that minimizes the error probability during transmission; see \\cite[Ch. 3]{doi:10.1007/978-1-4757-6568-7}.\n\nThe \\textit{minimum distance} \\(d\\) of a constellation is the infimum over distances between any two of it''s points.\nThe \\textit{density} \\(\\Delta\\) is the fraction of the total volume of space that is occupied by spheres of an optimal radius centered at each point in the sphere packing.\nDefining a density for infinite constellations can be done using a limit \\cite[pg. 349]{preset:EricZin}.\n\nThe Kabatiansky-Levenshtein bound \\cite{manual:{G. A. Kabatiansky, V. I. Levenshtein, “On Bounds for Packings on a Sphere and in Space”, Probl. Peredachi Inf., 14:1 (1978), 3–25; Problems Inform. Transmission, 14:1 (1978), 1–17}} says that any sphere packing must satistfy \\(\\frac{1}{n}\\log_{2}\\Delta\\lesssim-0.5990\\) asymptotically with dimension \\(n\\).\nOther bounds include the Rogers bound \\cite{doi:10.1112/plms/s3-8.4.609}.\nFor more details, see \\cite[Ch. 10.4]{preset:EricZin}\\cite[Ch. 1]{doi:10.1007/978-1-4757-6568-7}.\n\nThe \\textit{covering problem} asks how one can cover all of space by overlapping spheres in the most efficient way.\nThe \\textit{thickness} \\(\\Theta\\) (a.k.a. covering density or sparsity) of a covering is defined in the same way as the (packing) density, but with the spheres' \\textit{covering radius} now being the smallest one such that the spheres cover all space.\n\nThere is an upper bound on the thickness of a covering in dimensions \\(n>3\\) \\cite{doi:10.1112/S0025579300001030} as well as an asymptotic lower bound \\cite{doi:10.1112/S0025579300002059},\n\\begin{align}\n  \\frac{n}{e\\sqrt{e}}\\lesssim\\Theta\\leq n\\ln n+n\\ln\\ln n+5n~.\n\\end{align}\n\nSphere packings can be used as \\textit{quantizers} or \\textit{analog-to-digital converters}, which perform data compression by rounding a vector of real numbers to the point in the packing that is closest to the vector.\nThe set of all points closest to a point \\(x\\) is called the \\textit{Voronoi cell of \\(x\\)}.\nThe \\textit{quantizer problem} asks to find a sphere packing that yields that minimizes a dimensionless dimension-dependent quantity proportional to the average mean squared error per dimension; see \\cite[Sec. 3.2]{doi:10.1007/978-1-4757-6568-7}.\nFor dimension \\(n\\), this minimum is known as \\(G_n\\). It is known only for \\(n=1,2\\) and is attained by the integer and hexagonal lattices, respectively.\n","features":{"rate":"The rate of a code consisting of \\(M\\) codewords that represent a signal of bandwidth \\(W\\) and duration \\(T\\) is defined as\n\\begin{align}\n  R=\\frac{1}{T}\\log_{2}M\\quad\\quad\\text{bits/s}~.\n\\end{align}\n\nThe Shannon capacity of the AGWN channel for a signal whose power is \\(P\\) is\n\\begin{align}\n  C=W\\log_{2}\\left(1+\\frac{P}{\\sigma^{2}}\\right)\\,.\n\\end{align}\nRandom sphere packings achieve this capacity \\cite{doi:10.1002/j.1538-7305.1959.tb03905.x}; see the book \\cite{doi:10.1007/978-1-4757-6568-7} for more details.\nTradeoffs between various parameters have been analyzed \\cite{doi:10.1002/j.1538-7305.1963.tb04013.x}. Deterministic sets of constellations from quadrature rules can also achieve capacity \\cite{doi:10.1109/ALLERTON.2010.5706965}.\n","decoders":["Each signal point is assigned its own Voronoi cell, and a received point is mapped back to the center of the Voronoi cell that it is located upon reception."]},"notes":["Database of sphere packings \\cite{manual:{Agrell, E. \"Database of sphere packings, 2019.\" Online: http://codes. se/packings. Accessed (2015).}}."],"relations":{"parents":[{"code_id":"block"},{"code_id":"group_classical","detail":"Sphere-packing alphabets \\(\\mathbb{R}^n\\) are infinite fields, which are groups under addition."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-02"},{"user_id":"VictorVAlbert","date":"2022-02-16"}]},"_zoodb":{"id":"analog","source_file_path":"codes/classical/analog/analog.yml","source_file_modification_token":1678631058710.016}},"antipode":{"code_id":"antipode","physical":"reals","logical":"reals","name":"Antipode lattice code","introduced":"\\cite{doi:10.1007/BF01232378}","description":"Lattice code constructed via the antipode construction.\n","relations":{"parents":[{"code_id":"points_into_lattices"}],"cousins":[{"code_id":"anticode","detail":"The antipode and anticode construcions are morally similar \\cite{doi:10.1007/978-1-4757-6568-7}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"antipode","source_file_path":"codes/classical/analog/lattice/antipode.yml","source_file_modification_token":1670025425872.035}},"barnes_wall":{"code_id":"barnes_wall","physical":"reals","logical":"reals","name":"Barnes-Wall (BW) lattice code","short_name":"BW","introduced":"\\cite{doi:10.1017/S1446788700025064,doi:10.24033/asens.1241}","description":"Member of a family of \\(2^{m+1}\\)-dimensional lattices, denoted as BW\\(_{2^{m+1}}\\), that are the densest lattices known.\nMembers include the integer square lattice \\(\\mathbb{Z}^2\\), \\(D_4\\), the Gosset \\(E_8\\) lattice, and the \\(\\Lambda_{16}\\) lattice, corresponding to \\(m\\in\\{0,1,2,3\\}\\), respectively.\n","protection":"BW lattices in dimension \\(2^{m+1}\\) have a nominal coding gain of \\(2^{m/2}\\).\nTheir kissing number is \\(K_{\\text{min}} = \\prod_{i=1}^{m+1} (2^i + 2)\\).\n","relations":{"parents":[{"code_id":"points_into_lattices"}],"cousins":[{"code_id":"reed_muller","detail":"BW lattice codes are lattice analogues of RM codes in that both can be constructed recursively via a \\(|u|u+v|\\) construction \\cite{doi:10.1049/el:19840043,doi:10.1109/18.21245}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"barnes_wall","source_file_path":"codes/classical/analog/lattice/bw/barnes_wall.yml","source_file_modification_token":1671665864784.3804}},"bw32":{"code_id":"bw32","physical":"reals","logical":"reals","name":"\\(BW_{32}\\) Barnes-Wall lattice code","short_name":"\\(BW_{32}\\)","introduced":"\\cite{doi:10.1017/S1446788700025064}","description":"BW lattice in dimension \\(32\\).\n","relations":{"parents":[{"code_id":"barnes_wall"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-22"}]},"_zoodb":{"id":"bw32","source_file_path":"codes/classical/analog/lattice/bw/bw32.yml","source_file_modification_token":1671665864784.4863}},"lambda16":{"code_id":"lambda16","physical":"reals","logical":"reals","name":"\\(\\Lambda_{16}\\) Barnes-Wall lattice code","short_name":"\\(\\Lambda_{16}\\)","introduced":"\\cite{doi:10.1017/S1446788700025064}","description":"BW lattice in dimension \\(16\\).\n","protection":"Exhibits the densest known lattice packing in 16 dimensions.'\n","relations":{"parents":[{"code_id":"barnes_wall"}],"cousins":[{"code_id":"reed_muller","detail":"The RM\\((1,4)\\) code can be used to obtain the \\(\\Lambda_{16}\\) Barnes-Wall lattice code \\cite[Ex. 10.7.2]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-22"}]},"_zoodb":{"id":"lambda16","source_file_path":"codes/classical/analog/lattice/bw/lambda16.yml","source_file_modification_token":1678631058710.1292}},"leech":{"code_id":"leech","physical":"reals","logical":"reals","name":"\\(\\Lambda_{24}\\) Leech lattice code","short_name":"Leech","introduced":"\\cite{doi:10.4153/CJM-1967-017-0}","description":"Even unimodular lattice in 24 dimensions that exhibits optimal packing.\n","protection":"The \\(\\Lambda_{24}\\) Leech lattice has a nominal coding gain of \\(4\\). It exhibits the densest packing \\cite{arxiv:1603.06518} and highest kissing number of 196560 in 24 dimensions.\n","notes":["Popular summary of solution to the sphere-packing problem in \\href{https://www.quantamagazine.org/sphere-packing-solved-in-higher-dimensions-20160330/}{Quanta Magazine}."],"relations":{"parents":[{"code_id":"niemeier"},{"code_id":"univ_opt_analog","detail":"The \\(\\Lambda_{24}\\) Leech lattice code is universally optimal \\cite{arxiv:1902.05438}."}],"cousins":[{"code_id":"golay","detail":"The \\(\\Lambda_{24}\\) Leech lattice can be obtained by lifting the Golay code to \\(\\mathbb{Z}_4\\) \\cite{doi:10.1109/18.312154}, appending a parity check, and applying construction \\(A_4\\) \\cite{doi:10.1007/3-540-57843-9_20} (see also \\cite{doi:10.1007/978-1-4757-6568-7}). Half of the lattice can be obtained in a different construction \\cite[Ex. 10.7.3]{preset:EricZin}."},{"code_id":"sharp_config","detail":"Several spherical sharp configrations are derived from the \\(\\Lambda_{24}\\) Leech lattice \\cite{arxiv:math/0607446}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"leech","source_file_path":"codes/classical/analog/lattice/bw/leech.yml","source_file_modification_token":1682250129446.0093}},"construction_a":{"code_id":"construction_a","physical":"reals","logical":"reals","name":"Construction-\\(A\\) code","introduced":"\\cite{doi:10.4153/CJM-1967-017-0}","description":"Sphere packing constructed from a binary \\((n,K)\\) code using Construction \\(A\\) \\cite{doi:10.1007/978-1-4757-6568-7}.\nEach binary codeword \\(c\\) of the code is mapped to an infinite set of points \\(x\\) such that \\(x = c\\) modulo two.\nIf the underlying binary code is linear, then the resulting set of points forms a lattice.\n","relations":{"parents":[{"code_id":"analog"}],"cousins":[{"code_id":"bits_into_bits","detail":"Each binary code yields a sphere packing under Construction \\(A\\)."},{"code_id":"binary_linear","detail":"Every binary linear code yields a lattice code under Construction \\(A\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"construction_a","source_file_path":"codes/classical/analog/lattice/construction_a.yml","source_file_modification_token":1680994436843.0396}},"coxeter_todd":{"code_id":"coxeter_todd","physical":"reals","logical":"reals","name":"Coxeter-Todd \\(K_{12}\\) lattice code","short_name":"\\(K_{12}\\)","introduced":"\\cite{doi:10.4153/CJM-1953-043-4}","description":"Even integral lattice in dimension \\(12\\) that exhibits optimal packing.\nIt's automorphism group was discovered by Mitchell \\cite{doi:10.2307/2370513}.\nFor more details, see \\cite[Sec. 4.9]{doi:10.1007/978-1-4757-6568-7}\\cite{doi:10.1017/S0305004100060746}.\n","protection":"The \\(K_{12}\\) lattice exhibits the densest known lattice packing in 12 dimensions.'\n","relations":{"parents":[{"code_id":"points_into_lattices"}],"cousins":[{"code_id":"hexacode","detail":"The hexacode can be used to obtain the Coxeter-Todd \\(K_{12}\\) lattice code \\cite[Ex. 10.5.6]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-12"}]},"_zoodb":{"id":"coxeter_todd","source_file_path":"codes/classical/analog/lattice/coxeter_todd.yml","source_file_modification_token":1684508734538.9695}},"an_dual":{"code_id":"an_dual","physical":"reals","logical":"reals","name":"\\(A_n^{\\perp}\\) lattice code","short_name":"\\(A_n^{\\perp}\\)","description":"Stub.","protection":"Exhibits the thinnest covering in two dimensions and the thinnest lattice covering in dimensions three \\cite{manual:{Bambah, R. P., and H. Gupta. \"On lattice coverings by spheres.\" Proceedings of the National Institute of Sciences of India. Vol. 20. Indian National Science Academy, 1954.}}, four \\cite{manual:{Delaunay, B. N., and S. S. Ryskov. \"Solution of the problem of least dense lattice covering of a four-dimensional space by equal spheres.\" Sov. Math. Dokl. Vol. 4. 1963.}}, and five \\cite{manual:{S. S. Ryshkov, E. P. Baranovskii, “Solution of the problem of least dense lattice covering of five-dimensional space by equal spheres”, Dokl. Akad. Nauk SSSR, 222:1 (1975), 39–42},manual:{S. S. Ryshkov, E. P. Baranovskii, “C-types of n-dimensional lattices and 5-dimensional primitive parallelohedra (with application to the theory of coverings)”, Trudy Mat. Inst. Steklov., 137, 1976, 3–131; Proc. Steklov Inst. Math., 137 (1976), 1–140}}.\n","relations":{"parents":[{"code_id":"points_into_lattices"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-26"}]},"_zoodb":{"id":"an_dual","source_file_path":"codes/classical/analog/lattice/dual/an_dual.yml","source_file_modification_token":1678631058710.3997}},"bcc":{"code_id":"bcc","physical":"reals","logical":"reals","name":"Body-centered cubic (bcc) lattice code","short_name":"\\(bcc\\)","description":"Three-dimensional lattice consisting of all points \\((x,y,z)\\) whose integer components are either all even or all odd.\n","protection":"The bcc lattice has density \\(\\Delta=\\pi\\sqrt{3}/8\\approx 0.6802\\). It exhibits the thinnest lattice covering \\cite{manual:{Bambah, R. P., and H. Gupta. \"On lattice coverings by spheres.\" Proceedings of the National Institute of Sciences of India. Vol. 20. Indian National Science Academy, 1954.}} in three dimensions.\nIt solves the lattice quantizer problem in three dimensions with \\(G_3 = \\frac{19}{192\\cdot 2^{1/3}}\\approx 0.0785\\) \\cite{doi:10.1137/0604005}.\n","relations":{"parents":[{"code_id":"an_dual","detail":"The bcc lattice is the dual of the \\(A_3=D_3\\) fcc lattice."}],"cousins":[{"code_id":"dthree","detail":"The bcc and fcc lattices are dual to each other."},{"code_id":"dual_lattice","detail":"The bcc and fcc lattices are dual to each other."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-26"}]},"_zoodb":{"id":"bcc","source_file_path":"codes/classical/analog/lattice/dual/bcc.yml","source_file_modification_token":1678631058710.4565}},"dual_lattice":{"code_id":"dual_lattice","physical":"reals","logical":"reals","name":"Dual lattice code","description":"Also called the \\textit{reciprocal} or \\textit{polar} lattice code.\nFor any \\(n\\)-dimensional lattice \\(L\\), the dual lattice is\n\\begin{align}\nL^{\\perp} = \\{ y\\in \\mathbb{R}^{n} ~|~ x \\cdot y \\in \\mathbb{Z} ~\\forall~ x \\in L\\},\n\\end{align}\nwhere the Euclidean inner product is used.\n\nA lattice that is contained in its dual, \\(L \\subseteq L^\\perp\\), is called \\textit{integral}.\nThe Gram matrix of such a lattice has integer entries, and its dual is contained in a suitably scaled version of itself, \\(L^{\\perp} \\subseteq L/\\det L\\).\nIntegral lattices are classified into \\textit{even} or \\textit{odd}, where the norm squared of every lattice vector is an even or odd integer, respectively.\n\nA lattice that is equal to its dual, \\(L^\\perp = L\\), is called \\textit{unimodular} or \\textit{self-dual}.\n","protection":"The Gram matrix of \\(L^{\\perp}\\) is the inverse of that of \\(L\\).\nThe generator matrix of \\(L^{\\perp}\\) is the transposed inverse of that of \\(L\\).\n","relations":{"parents":[{"code_id":"points_into_lattices"}],"cousins":[{"code_id":"dual","detail":"Dual lattices are lattice analogues of dual codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-25"}]},"_zoodb":{"id":"dual_lattice","source_file_path":"codes/classical/analog/lattice/dual/dual_lattice.yml","source_file_modification_token":1684508734539.157}},"self_dual_lattice":{"code_id":"self_dual_lattice","physical":"reals","logical":"reals","name":"Unimodular lattice code","description":"Also called a \\textit{self-dual lattice code}.\nA lattice that is equal to its dual, \\(L^\\perp = L\\).\nUnimodular lattices have \\(\\det L = \\pm 1\\).\n","protection":"The minimum norm of a unimodular lattice satisfies\n\\begin{align}\n  \\mu\\leq2\\left[\\frac{n}{24}\\right]+2~,\n\\end{align}\nunless \\(n = 23\\) \\cite{doi:10.1006/jnth.1998.2306}.\n","relations":{"parents":[{"code_id":"dual_lattice"}],"cousins":[{"code_id":"self_dual","detail":"Unimodular lattices are lattice analogues of self-dual codes. There are several parallels between (doubly-even) self-dual binary codes and (even) unimodular lattices \\cite{doi:10.1007/978-1-4757-6568-7,doi:10.1007/3-540-30731-1}."},{"code_id":"self_dual_additive","detail":"There are parallels between self-dual additive codes over \\(\\mathbb{Z}_{2k}\\) and even unimodular lattices \\cite{doi:10.1109/18.761269}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-22"}]},"_zoodb":{"id":"self_dual_lattice","source_file_path":"codes/classical/analog/lattice/dual/self_dual_lattice.yml","source_file_modification_token":1682420107451.2979}},"niemeier":{"code_id":"niemeier","physical":"reals","logical":"reals","name":"Niemeier lattice code","introduced":"\\cite{doi:10.1016/0022-314X(73)90068-1}","description":"One of the 24 positive-definite even unimodular lattices of rank 24.\n","relations":{"parents":[{"code_id":"self_dual_lattice","detail":"Niemeier lattice codes are even and unimodular."}],"cousins":[{"code_id":"self_dual","detail":"Niemeier lattice codes can be constructed from ternary self-dual codes of length 24 \\cite{doi:10.1016/0012-365X(93)E0088-L}."},{"code_id":"quaternary_over_z4","detail":"Niemeier lattice codes can be constructed from quaternary codes over \\(\\mathbb{Z}_4\\) via Construction \\(A_4\\) \\cite{doi:10.1016/S0012-365X(99)00032-1}."},{"code_id":"octacode","detail":"The octacode can be used to construct a Niemeier lattice code via Construction \\(A_4\\) \\cite{doi:10.1016/S0012-365X(99)00032-1}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"niemeier","source_file_path":"codes/classical/analog/lattice/niemeier.yml","source_file_modification_token":1682250129446.2407}},"points_into_lattices":{"code_id":"points_into_lattices","physical":"reals","logical":"reals","name":"Lattice-based code","description":"Encodes states (codewords) in coordinates of an \\(n\\)-dimensional lattice, i.e., a discrete set of points in Euclidean space \\(\\mathbb{R}^n\\) that forms a group under vector addition when the set is translated such that one point is at the origin. The number of codewords may be infinite because the coordinate space is infinite-dimensional, so various restricted versions have to be constructed in practice. Since lattices are closed under addition, lattice-based codes can be thought of as linear codes over the reals.\n\nA \\(n\\)-dimensional lattice-based code can be defined using a generator matrix \\(G\\) of rank \\(n\\), where the rows of \\(G\\) are the lattice translation vectors \\(g_i\\).\nAny lattice point \\(x\\) is a linear combination of translation vectors with integer coefficients \\(c_i\\), \\(x = c_1 g_1 + c_2 g_2 + \\cdots + c_n g_n\\).\nA lattice-based code can also be defined using the Gram matrix \\(GG^T\\).\n\nThe \\textit{automorphism group} of a lattice is the group of all isometries that preserve the origin and map the lattice into itself.\nThis group is a subgroup of the orthogonal group \\(O(n)\\), which is the group of isometries in Euclidean space.\nAn orthogonal matrix \\(U\\) leaves the lattice invariant if there exists an integer matrix \\(A\\) of determinant \\(\\pm 1\\) such that\n\\begin{align}\n\\label{eq:lattice-auto}\n  AG=GU~.\n\\end{align}\nThe \\textit{affine automorphism group} is the group obtained from adding lattice translations to the automorphism group.\n","protection":"Lattices are characterized by the \\textit{minimum (Euclidean) distance} \\(d_{\\text{min}}\\) between two lattice points, the \\textit{kissing number} \\(K_{\\text{min}}\\) of nearest neighbors at each lattice point, and the \\textit{volume} \\(V=\\det G\\), which is the volume of the lattice's \\textit{fundamental region} that can be used to tile all of \\(\\mathbb{R}^n\\).\n\nThe minimum Euclidean distance is an analogue of the minimum distance of binary codes. Half of this distance is called the \\textit{packing radius}.\n\nThe \\textit{nominal coding gain} \\(\\gamma_{c}\\) (a.k.a. \\textit{Hermite parameter}) of an \\(n\\)-dimensional lattice is\n\\begin{align}\n  \\gamma_{c}=\\left(d_{\\text{min}}/\\sqrt[n]{V}\\right)^{2}~,\n\\end{align}\ncharacterizing the ratio of the level of protection to the required spatial resources.\nThe \\textit{density} of a lattice is the fraction of the total volume of space that is occupied by spheres of \\textit{packing radius} \\(\\frac{1}{2}d_{\\text{min}}\\) centered at each point in the lattice,\n\\begin{align}\n  \\Delta=\\frac{\\text{volume of one sphere}}{\\sqrt{V}}~.\n\\end{align}\n\nThe covering radius of a lattice is defined similarly as above, but with the spheres' \\textit{covering radius} now being the smallest one such that the spheres cover all space.\nIn general, finding the covering radius of lattice is \\(NP\\)-hard \\cite{manual:{van Emde, Boas P. \"Another NP-complete partition problem and the complexity of computing short vectors in lattices.\" TR (1981).}}.\n\nThe \\textit{lattice quantizer problem} is to find a lattice whose \\textit{fundamental Voronoi cell} \\(\\Pi\\), the Voronoi cell at the origin, has the smallest possible normalized second moment,\n\\begin{align}\n  G(\\Pi)=\\frac{\\frac{1}{n}\\int_{\\Pi}x\\cdot x\\,dx}{\\text{Vol}(\\Pi)^{1+2/n}}\\,.\n\\end{align}\nHigher-dimensional lattices yield quantizers with lower normalized second moments than the 1D integer lattice \\cite{manual:{P. L. Zador, Development and evaluation of procedures for quantiZing multivariate distributions, Ph.D. Dissertation, Stanford Univ., 1963},doi:10.1109/TIT.1982.1056490}.\n","features":{"rate":"Lattice codes with minimal-distance decoding achieve the capacity of the AGWN channel \\cite{doi:10.1109/18.651040,doi:10.1109/TIT.1975.1055409,manual:{R. de Budaand W. Kassem, About lattices and the random coding theorem, in Abstracts of Papers, IEEE Inter. Symp. Info. Theory 1981, IEEE Press, NY 1981, p. 145},manual:{W. Kassem, Optimal Lattice Codes for the Gaussian Channel, Ph.D Thesis, McMaster Univ., Hamilton, Ontario, 1981,doi:10.1109/18.651040}}.\n"},"notes":["See books \\cite{doi:10.1007/978-1-4757-6568-7,doi:10.1007/b98975} for introductions and overviews of lattices.","See Catalogue of Lattices \\cite{manual:{G. Nebe and N. J. A. Sloane. \"Catalogue of Lattices.\" http://www.math.rwth-aachen.de/~Gabriele.Nebe/LATTICES/index.html}} for more information.","Tables of bounds on kissing numbers \\cite{manual:{H. Cohn. \"Kissing numbers.\" https://cohn.mit.edu/kissing-numbers}}.","See Refs. \\cite{manual:{Cannon, J., Bosma, W., Fieker, C., & Steel, A. (2008). HANDBOOK OF MAGMA FUNCTIONS.},doi:10.1145/190347.190362,doi:10.1006/jsco.1996.0125} for various examples and implementations in Magma."],"relations":{"parents":[{"code_id":"analog"},{"code_id":"group_linear","detail":"Lattice-based codes are linear codes over \\(G=\\mathbb{R}^n\\). Because any orthogonal matrix leaving the lattice invariant has a corresponding integer matrix (see lattice code description), integer representations of groups can be used to obtain lattices \\cite[Ch. 3, Sec. 4.2]{doi:10.1007/978-1-4757-6568-7}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-02"},{"user_id":"VictorVAlbert","date":"2022-02-16"}]},"_zoodb":{"id":"points_into_lattices","source_file_path":"codes/classical/analog/lattice/points_into_lattices.yml","source_file_modification_token":1684508734539.3613}},"an":{"code_id":"an","physical":"reals","logical":"reals","name":"\\(A_n\\) lattice code","short_name":"\\(A_n\\)","description":"Lattice-based \\(n\\)-dimensional code that can be simply defined in \\(n+1\\) dimensions as the set of integer vectors \\(x\\) lying in the hyperplane \\(x_0+x_1+\\cdots+x_{n} = 0\\).\nIts generator matrix can be represented by\n\\begin{align}\n  G=\\begin{pmatrix}-1 & \\phantom{-}1 & 0 & 0 & \\cdots & 0 & 0\\\\\n  0 & -1 & \\phantom{-}1 & 0 & \\cdots & 0 & 0\\\\\n  0 & 0 & -1 & \\phantom{-}1 & \\cdots & 0 & 0\\\\\n  \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots\\\\\n  0 & 0 & 0 & 0 & \\cdots & -1 & \\phantom{-}1\n  \\end{pmatrix}~.\n\\end{align}\n","protection":"The lattice has determinant \\(n+1\\), kissing number \\(n(n+1)\\), packing radius \\(1/\\sqrt{2}\\), covering radius \\(\\sqrt{\\frac{a\\left(n+1-a\\right)}{n+1}}\\) (with \\(a\\lfloor (n+1)/2 \\rfloor\\)), and density \\(V_n/2^n\\) (with \\(V_n\\) the volume of the unit \\(n\\)-sphere).\n","relations":{"parents":[{"code_id":"root"}],"cousins":[{"code_id":"an_dual"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-15"}]},"_zoodb":{"id":"an","source_file_path":"codes/classical/analog/lattice/root/an.yml","source_file_modification_token":1684508734539.4766}},"dfour":{"code_id":"dfour","physical":"reals","logical":"reals","name":"\\(D_4\\) hyper-diamond lattice code","short_name":"\\(D_4\\)","description":"BW lattice in dimension \\(4\\), which is the lattice corresponding to the \\([4,1,4]\\) repetition and \\([4,3,2]\\) SPC codes via the mod-two lattice construction.\n","protection":"The \\(D_4\\) lattice has a density of \\(\\pi^2/16\\approx 0.6169\\) and nominal coding gain of \\(\\sqrt{2}\\). It exhibits the densest lattice packing in four dimensions \\cite{doi:10.1007/BF01442912}.\n","relations":{"parents":[{"code_id":"dn"},{"code_id":"barnes_wall"},{"code_id":"self_dual_lattice"},{"code_id":"construction_a"}],"cousins":[{"code_id":"repetition","detail":"The four-bit repetition code yields the \\(D_4\\) hyper-diamond lattice code via the mod-two lattice construction."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"dfour","source_file_path":"codes/classical/analog/lattice/root/dfour.yml","source_file_modification_token":1682250129446.329}},"dn":{"code_id":"dn","physical":"reals","logical":"reals","name":"\\(D_n\\) checkerboard lattice code","short_name":"\\(D_n\\)","description":"Lattice code consisting of all points whose coordinates add up to an even integer.\nIts generator matrix can be represented by\n\\begin{align}\n  G=\\begin{pmatrix}-1 & -1 & 0 & 0 & \\cdots & 0 & 0\\\\\n  \\phantom{-}1 & -1 & 0 & 0 & \\cdots & 0 & 0\\\\\n  0 & \\phantom{-}1 & -1 & 0 & \\cdots & 0 & 0\\\\\n  0 & 0 & \\phantom{-}1 & -1 & \\cdots & 0 & 0\\\\\n  \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots\\\\\n  0 & 0 & 0 & 0 & \\cdots\\phantom{-} & 1 & -1\n  \\end{pmatrix}~.\n\\end{align}\n","protection":"Exhibits the densest lattice packing and highest known kissing number in four and five \\cite{manual:{Sur les formes quadratiques positives. (Zus. Mit S. Zolotareff) Korkine in: Mathematische Annalen}} dimensions.\n","relations":{"parents":[{"code_id":"root"}],"cousins":[{"code_id":"parity_check","detail":"\\([n,n-1,2]\\) SPC codes yield \\(D_n\\) checkerboard lattice codes via the mod-two lattice construction \\cite[Ex. 10.5.1]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-12"}]},"_zoodb":{"id":"dn","source_file_path":"codes/classical/analog/lattice/root/dn.yml","source_file_modification_token":1684508734539.5908}},"dthree":{"code_id":"dthree","physical":"reals","logical":"reals","name":"\\(D_3\\) face-centered cubic (fcc) lattice code","short_name":"\\(D_3 fcc\\)","description":"Laminated three-dimensional lattice consisting of layers of hexagonal lattices.","protection":"The \\(D_3\\) fcc lattice exhibits the densest lattice packing \\cite{manual:{C.F. Gauss, Besprechung des Buchs von L.A. Seeber, Untersuchungen uber die Eigenschaften der positiven terndren quadratischen Formen usw. Gottingsche Gelehrte Anzeigen, July 9, 1831 = Werke, II, pp. 188-196, 1876.}}, highest kissing number of 12, and the thinnest lattice covering in three dimensions.","relations":{"parents":[{"code_id":"dn","detail":"The \\(D_3\\) root lattice is equivalent to the \\(A_3\\) root lattice \\cite[Ch. 10]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"dthree","source_file_path":"codes/classical/analog/lattice/root/dthree.yml","source_file_modification_token":1678631058710.9624}},"eeight":{"code_id":"eeight","physical":"reals","logical":"reals","name":"\\(E_8\\) Gosset lattice code","short_name":"\\(E_8\\)","introduced":"\\cite{manual:{Gosset, Thorold. \"On the regular and semi-regular figures in space of n dimensions.\" Messenger of Mathematics 29 (1900): 43-48.}}","description":"BW lattice in dimension \\(8\\), which is the lattice corresponding to the \\([8,4,4]\\) Hamming code via the mod-two lattice construction.\n","protection":"The \\(E_8\\) lattice has a nominal coding gain of \\(2\\).\nIt exhibits the densest lattice packing \\cite{manual:{Blichfeldt, H. F. \"On the minimum value of positive real quadratic forms in 6 variables.\" Bulletin of American Math. Soc 31 (1925): 386.},doi:10.1007/BF01454863,doi:10.1007/BF01201341,doi:10.1112/plms/s3-13.1.549}, densest packing \\cite{arxiv:1603.06518}, and highest kissing number of 240 \\cite{manual:{Vetchinkin, N. M. \"Uniqueness of classes of positive quadratic and highest kissing number of 240 in eight dimensions\"}} in eight dimensions.\n","notes":["Popular summary of solution to the sphere-packing problem in \\href{https://www.quantamagazine.org/sphere-packing-solved-in-higher-dimensions-20160330/}{Quanta Magazine}."],"relations":{"parents":[{"code_id":"root"},{"code_id":"barnes_wall"},{"code_id":"construction_a"},{"code_id":"self_dual_lattice","detail":"The \\(E_8\\) Gosset lattice code is even and unimodular."},{"code_id":"univ_opt_analog","detail":"The \\(E_8\\) Gosset lattice code is universally optimal \\cite{arxiv:1902.05438}."}],"cousins":[{"code_id":"hamming844","detail":"The \\([8,4,4]\\) extended Hamming code yields the \\(E_8\\) Gosset lattice code via the mod-two lattice construction \\cite[Ex. 10.5.2]{preset:EricZin}."},{"code_id":"octacode","detail":"The octacode yields the \\(E_8\\) Gosset lattice code via Construction \\(A_4\\) \\cite{doi:10.1007/3-540-57843-9_20,doi:10.1109/18.370138}."},{"code_id":"q-ary_hamming","detail":"The \\([4,2,3]_3\\) ternary Hamming code can be used to obtain the \\(E_8\\) Gosset lattice code \\cite[Ex. 10.5.5]{preset:EricZin}."},{"code_id":"repetition","detail":"The \\([8,1,8]\\) repetition code can be used to obtain the \\(E_8\\) Gosset lattice code \\cite[Ex. 10.7.1]{preset:EricZin}."},{"code_id":"sharp_config","detail":"Several spherical sharp configrations are derived from the \\(E_8\\) Gosset lattice code \\cite{arxiv:math/0607446}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"eeight","source_file_path":"codes/classical/analog/lattice/root/eeight.yml","source_file_modification_token":1683723710985.7783}},"eseven":{"code_id":"eseven","physical":"reals","logical":"reals","name":"\\(E_7\\) root lattice code","short_name":"\\(E_7\\)","description":"Lattice in dimension \\(7\\).\n","protection":"The \\(E_7\\) root lattice exhibits the densest lattice packing \\cite{manual:{Blichfeldt, H. F. \"On the minimum value of positive real quadratic forms in 6 variables.\" Bulletin of American Math. Soc 31 (1925): 386.},doi:10.1007/BF01454863,doi:10.1007/BF01201341,doi:10.1112/plms/s3-13.1.549,manual:{Vetchinkin, N. M. \"Uniqueness of classes of positive quadratic and highest known kissing number in seven dimensions.\"}}.","relations":{"parents":[{"code_id":"root"}],"cousins":[{"code_id":"hamming743","detail":"The \\([7,4,3]\\) Hamming code yields the \\(E_7^{\\perp}\\) root lattice code via the mod-two lattice construction \\cite{doi:10.1137/0605031}. The \\([7,3,4]\\) little Hamming code yields the \\(E_7\\) root lattice code via the same construction \\cite[Ex. 10.5.3]{preset:EricZin}\\cite{doi:10.1137/0605031}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-12"}]},"_zoodb":{"id":"eseven","source_file_path":"codes/classical/analog/lattice/root/eseven.yml","source_file_modification_token":1687727505566.337}},"esix":{"code_id":"esix","physical":"reals","logical":"reals","name":"\\(E_6\\) root lattice code","short_name":"\\(E_6\\)","description":"Lattice in dimension \\(6\\).\n","protection":"The root \\(E_6\\) lattice exhibits the densest lattice packing \\cite{manual:{Blichfeldt, H. F. \"On the minimum value of positive real quadratic forms in 6 variables.\" Bulletin of American Math. Soc 31 (1925): 386.},doi:10.1007/BF01454863,doi:10.1007/BF01201341,doi:10.1112/plms/s3-13.1.549,manual:{Vetchinkin, N. M. \"Uniqueness of classes of positive quadratic forms, on which values of Hermite constants are reached for 6≤n≤8.\" Trudy Matematicheskogo Instituta imeni VA Steklova 152 (1980): 34-86.}} and highest known kissing number in six dimensions.","relations":{"parents":[{"code_id":"root"}],"cousins":[{"code_id":"q-ary_repetition","detail":"The \\([3,1,3]_3\\) ternary repetition code can be used to obtain the \\(E_6\\) root lattice code \\cite[Ex. 10.5.4]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-29"}]},"_zoodb":{"id":"esix","source_file_path":"codes/classical/analog/lattice/root/esix.yml","source_file_modification_token":1678631058711.1992}},"hexagonal":{"code_id":"hexagonal","physical":"reals","logical":"reals","name":"\\(A_2\\) hexagonal lattice code","description":"Two-dimensional lattice that exhibits optimal packing, solving the packing, kissing, covering and quantization problems.\nIts dual is the \\textit{honeycomb lattice}.\nIt's generator matrix is\n\\begin{align}\n  V=\\begin{pmatrix}1 & 0\\\\\n    -1/2 & \\sqrt{3}/2\n      \\end{pmatrix}~.\n\\end{align}\nAll possible sublattices are characterized in Refs. \\cite{doi:10.1016/0012-365X(95)00354-Y,doi:10.1515/zna-1995-0802} from the point of view of information transmission over the AGWN channel.\n","protection":"The hexagonal lattice exhibits the densest packing with density \\(\\Delta = \\pi/\\sqrt{12} \\approx 0.9069\\) \\cite[Sec. 1.4]{doi:10.1007/978-1-4757-6568-7}, the highest kissing number of 6, and the thinnest covering with thickness \\(\\Theta = 2\\pi/3\\sqrt{3}\\approx 1.2092\\) \\cite{doi:10.2307/2371320} in two dimensions.\nIt solves the quantizer problem in two dimensions with \\(G_2 = \\frac{5}{36\\sqrt{3}}\\) \\cite{manual:{L. Fejes Toth, Sur Ia representation d' une population infinie par une nombre fini d'elements, AMAH 10 (1959), 299-304},doi:10.1007/978-3-642-65234-9,doi:10.1109/TIT.1979.1056067,doi:10.1109/TIT.1982.1056492}.\nIt also solves the Gaussian channel coding problem \\cite{doi:10.1007/978-3-642-65234-9}.\n","realizations":["Wireless communication \\cite{doi:10.1109/TCOM.1962.1088634,doi:10.1109/TCOM.1974.1092061}."],"relations":{"parents":[{"code_id":"root"}],"cousins":[{"code_id":"polygon","detail":"The Voronoi cell of the hexagonal lattice is the hexagon."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"hexagonal","source_file_path":"codes/classical/analog/lattice/root/hexagonal.yml","source_file_modification_token":1678631058711.2886}},"hypercubic":{"code_id":"hypercubic","physical":"reals","logical":"reals","name":"\\(\\mathbb{Z}^n\\) hypercubic lattice code","short_name":"\\(\\mathbb{Z}^n\\)","description":"Lattice-based code consisting of all integer vectors in \\(n\\) dimensions.\nIts generator matrix is the \\(n\\)-dimensional identity matrix.\nIts automorphism group consists of all coordinate permutations and sign changes.\n","protection":"The \\(\\mathbb{Z}\\) integer lattice solves the lattice quantization problem in one dimension with a second moment of \\(G_1 = 1/12\\).\nThe lattice has determinant 1, kissing number \\(2n\\), packing radius \\(1/2\\), covering radius \\(\\sqrt{n}/2\\), and density \\(V_{n}/\\sqrt{2^{n}(n+1)}\\) (with \\(V_n\\) the volume of the unit \\(n\\)-sphere).\n","relations":{"parents":[{"code_id":"root"},{"code_id":"self_dual_lattice","detail":"The hypercubic lattice code is odd and unimodular."}],"cousins":[{"code_id":"barnes_wall","detail":"The hypercubic lattice is the \\(m=1\\) BW lattice."},{"code_id":"points_into_lattices","detail":"The generator matrix of a lattice-based code serves as a linear transformation that can be applied to the hypercubic lattice to obtain said code \\cite[Ch. 10]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-12"}]},"_zoodb":{"id":"hypercubic","source_file_path":"codes/classical/analog/lattice/root/hypercubic.yml","source_file_modification_token":1684508734539.7283}},"root":{"code_id":"root","physical":"reals","logical":"reals","name":"Root lattice code","short_name":"Root","description":"A lattice that is symmetric under a specific crystallographic reflection group; see \\cite[Table 4.1]{doi:10.1007/978-1-4757-6568-7} for the list of crystallographic reflection groups and their corresponding root lattices.\nThe root-lattice family consists of lattices \\(A_n\\), \\(\\mathbb{Z}^n\\), or \\(D_n\\) for dimension \\(n\\), or \\(E_{i}\\) for \\(i\\in\\{6,7,8\\}\\).\nTheir generator matrices can be taken to be the root matrices of the corresponding reflection groups.\n","protection":"The densest lattice packings in dimensions \\(3\\) through \\(8\\) are root lattices \\cite[Table 1.1]{doi:10.1007/978-1-4757-6568-7}.\n","relations":{"parents":[{"code_id":"points_into_lattices"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-12"}]},"_zoodb":{"id":"root","source_file_path":"codes/classical/analog/lattice/root/root.yml","source_file_modification_token":1671665864785.5737}},"fsk":{"code_id":"fsk","physical":"reals","logical":"reals","name":"Frequency-shift keying (FSK) code","short_name":"FSK","description":"Stub.\n","relations":{"parents":[{"code_id":"modulation"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"}]},"_zoodb":{"id":"fsk","source_file_path":"codes/classical/analog/modulation/fsk.yml","source_file_modification_token":1678631058711.4958}},"modulation":{"code_id":"modulation","physical":"reals","logical":"reals","name":"Modulation scheme","description":"A sphere packing mapped into a time-dependent electromagnetic signal \\cite{doi:10.1007/b100498,doi:10.1017/9781316822708}.\nThere is a close relation between abstract real-space encodings and modulation schemes, and certain simple sphere packings are often synonymous with their corresponding modulation schemes.\n\nLinear modulation schemes encode points into amplitudes of electromagnetic waveforms.\n\\textit{Pulse-amplitude modulation (PAM)} associates each point with a real-valued amplitude of one quadrature of an electromagnetic waveform \\cite[Sec. 10.5]{doi:10.1017/9781316822708}.\n\\textit{Quadrature amplitude modulation (QAM)} associates each pair of points with a complex-valued two-quadrature amplitude of band-limited signal \\cite[Ch. 16]{doi:10.1017/9781316822708}.\n","notes":["See the book \\cite{manual:{Proakis, John G., and Masoud Salehi. Digital communications. Vol. 4. New York: McGraw-hill, 2001.}} for an introduction to modulation schemes."],"relations":{"parents":[{"code_id":"points_into_balls"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"}]},"_zoodb":{"id":"modulation","source_file_path":"codes/classical/analog/modulation/modulation.yml","source_file_modification_token":1684671427306.2192}},"pam":{"code_id":"pam","physical":"reals","logical":"reals","name":"Pulse-amplitude modulation (PAM) code","short_name":"PAM","description":"Encodes a \\(q\\)-ary digit into a constellation of equally spaced points on the real line.\nFor example, a \\(q\\)-PAM scheme for \\(q=8\\) could encode the constellation \\(\\{ \\pm \\alpha,\\pm 3\\alpha,\\pm 5\\alpha, \\pm 7\\alpha \\}\\) with real scaling factor \\(\\alpha\\).\nThe points in the constellation are typically associated with one quadrature of an electromagnetic signal.\n","relations":{"parents":[{"code_id":"qam","detail":"PAM codes can be thought of as QAM codes restricted to the real line. A \\(q\\times q\\)-QAM code is informationally equivalent to two \\(q\\)-PAM codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"}]},"_zoodb":{"id":"pam","source_file_path":"codes/classical/analog/modulation/pam.yml","source_file_modification_token":1668026466464.6973}},"points_into_balls":{"code_id":"points_into_balls","physical":"reals","logical":"reals","name":"Bounded-energy code","alternative_names":["Spherical cluster"],"description":"Code whose codewords are points lie on or inside a real or complex sphere whose radius squared is called the \\textit{energy}.\n","relations":{"parents":[{"code_id":"analog","detail":"Bounded-energy codes are sphere packings constrained to lie on or inside a sphere."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-15"}]},"_zoodb":{"id":"points_into_balls","source_file_path":"codes/classical/analog/modulation/points_into_balls.yml","source_file_modification_token":1684508734539.9531}},"ppm":{"code_id":"ppm","physical":"reals","logical":"reals","name":"Pulse-position modulation (PPM) code","short_name":"PPM","description":"An analog code encoding into \\(q\\) different signals such that each codeword corresponds to a signal.\n","realizations":["Greek hydraulic semaphore system \\cite{manual:{Michael Lahanas. \"Ancient Greek Communication Methods\". https://web.archive.org/web/20141102224501/http://www.mlahanas.de/Greeks/Communication.htm. Archived from the original on 2014-11-02.},doi:10.1049/iet-com.2019.0051}.","Telegraph time-division multiplexing.","Radio-control, fiber-optic communications, and deep-space communications."],"relations":{"parents":[{"code_id":"modulation"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"}]},"_zoodb":{"id":"ppm","source_file_path":"codes/classical/analog/modulation/ppm.yml","source_file_modification_token":1678631058711.618}},"qam":{"code_id":"qam","physical":"reals","logical":"reals","name":"Quadrature-amplitude modulation (QAM) code","short_name":"QAM","description":"Encodes into points into a subset of points lying on in \\(\\mathbb{R}^{2}\\), here treated as \\(\\mathbb{C}\\).\nEach pair of points is associated with a complex amplitude of an electromagnetic signal, and information is encoded into both the norm and phase of that signal \\cite[Ch. 16]{doi:10.1017/9781316822708}.\n\nQAM schemes with \\(q\\) complex coordinates are often called \\(q\\)-QAM, and \\(q\\) is often a power of two in order to further concatenate with a binary code.\n","features":{"rate":"Nearly achieves Shannon AWGN capacity for two-dimensional constellations in the limit of infinite signal to noise \\cite[Fig. 11.8]{doi:10.1017/CBO9780511811401}."},"realizations":["Optical communication (e.g., Ref. \\cite{doi:10.1109/JLT.2015.2510034}).","Telephone-line modems: 1971 Codex 9600C and international standard V.29 used 16-QAM \\cite{manual:{International Telecommunication Union-T, Recommendation V.29: 9600 Bits Per Second Modem Standardized For Use on Point-to-Point 4-Wire Leased Telephone-Tpe Circuits, 1993}}."],"relations":{"parents":[{"code_id":"modulation"}],"cousins":[{"code_id":"points_into_lattices","detail":"QAM encodings often consist of lattice constellations, i.e., finite sets of points scooped out of an infinite 2D lattice."},{"code_id":"multimodegkp","detail":"Finite-energy GKP codes are quantum analogues of lattice-based QAM codes in that both use a subset of points on a lattice."},{"code_id":"gray","detail":"2D Gray codes are often concatenated with \\(n=1\\) lattice-based QAM codes so that the Hamming distance between the bitstrings encoded into the points is a discretized version of the Euclidean distance between the points."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"}]},"_zoodb":{"id":"qam","source_file_path":"codes/classical/analog/modulation/qam.yml","source_file_modification_token":1678631058711.7065}},"univ_opt_analog":{"code_id":"univ_opt_analog","physical":"reals","logical":"reals","name":"Universally optimal sphere packing","introduced":"\\cite{arxiv:math/0607446}","description":"A periodic sphere packing that (weakly) minimizes all completely monotonic potentials of square Euclidean distance among all periodic packings of the same density.\n","relations":{"parents":[{"code_id":"analog"},{"code_id":"univ_opt"}],"cousins":[{"code_id":"hexagonal","detail":"The hexagonal lattice code is universally optimal among all lattices, but has not been proven to be optimal over all periodic packings \\cite{doi:10.1017/S0017089500007047}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-28"}]},"_zoodb":{"id":"univ_opt_analog","source_file_path":"codes/classical/analog/univ_opt_analog.yml","source_file_modification_token":1678631058711.774}},"binary_group_orbit":{"code_id":"binary_group_orbit","physical":"bits","logical":"bits","name":"Binary group-orbit code","introduced":"\\cite{doi:10.1002/j.1538-7305.1956.tb02379.x,doi:10.1002/j.1538-7305.1960.tb03958.x}","description":"Bianry legnth-\\(n\\) whose codewords correspond to points in an orbit of some \\textit{initial vector} under a \\textit{generating group} \\(G\\), which is a subgroup of the group of bit-string permutations and translations, i.e., the \\textit{automorphism group} of binary codes under the Hamming distance.\n","relations":{"parents":[{"code_id":"bits_into_bits"},{"code_id":"group_orbit","detail":"Binary group-orbit codes are group-orbit codes in Hamming space."}],"cousins":[{"code_id":"slepian_group","detail":"Binary group-orbit codes can be mapped into Slepian group-orbit codes via various mappings \\cite[Ch. 8]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-18"}]},"_zoodb":{"id":"binary_group_orbit","source_file_path":"codes/classical/bits/binary_group_orbit.yml","source_file_modification_token":1684508734540.0542}},"binary_linear":{"code_id":"binary_linear","physical":"bits","logical":"bits","name":"Linear binary code","description":"An \\((n,2^k,d)\\) linear code is denoted as \\([n,k]\\) or \\([n,k,d]\\), where \\(d\\) is the code's distance. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword. A code that is not linear is called \\textit{nonlinear}.\n\nLinear codes can be defined in terms of a \\textit{generator matrix} \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its \\textit{standard} or \\textit{systematic form} \\(G = [I_k~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) binary matrix.\n","protection":"Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set for which no two elements of the set add up to a codeword.\n\nLinear codes admit a \\textit{parity check matrix} \\(H\\), whose columns make up a set of \\textit{parity checks}, i.e., a maximal linearly independent set of vectors that are in the kernel of \\(G\\). It follows that\n\\begin{align}\n  G H^{\\text{T}} = 0 \\mod 2~.\n\\end{align}\n\nThe decision problem corresponding to finding the minimum distance is also \\(NP\\)-complete \\cite{doi:10.1109/18.641542}, and approximating the weight enumerator is \\(\\#P\\)-complete \\cite{arXiv:cs/0304044}.\n","features":{"rate":"A family of linear codes \\(C_i = [n_i,k_i,d_i]\\) is \\textit{asymptotically good} if the asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.","decoders":["Decoding an arbitary linear binary code is \\(NP\\)-complete \\cite{doi:10.1109/TIT.1978.1055873}.","Slepian's standard-array decoding \\cite{doi:10.1002/j.1538-7305.1960.tb03958.x}.","Recursive maximum likelihood decoding \\cite{arXiv:1408.1310}.","Transformer neural net for soft decoding \\cite{arxiv:2203.14966}."]},"notes":["Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by A. E. Brouwer \\cite{manual:{Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.}}, are maintained by M. Grassl at this \\href{http://codetables.markus-grassl.de/}{website}."],"relations":{"parents":[{"code_id":"binary_group_orbit","detail":"The set of codewords of a binary linear code can be thought of as an orbit of a particular codeword under the translation group formed by the code \\cite[Thm. 8.4.2]{preset:EricZin}. However, binary group-orbit codes do not have to be linear; see \\cite[Remark 8.4.3]{preset:EricZin}."},{"code_id":"q-ary_linear","detail":"Linear binary codes are linear \\(q\\)-ary codes for \\(q=2\\)."}],"cousins":[{"code_id":"binary_ltc","detail":"Linear binary codes with distances \\(\\frac{1}{2}n-\\sqrt{t n}\\) for some \\(t\\) are called almost-orthogonal and are locally testable with query complexity of order \\(O(t)\\) \\cite{doi:10.1109/SFCS.2005.16}. This was later improved to codes with distance \\(\\frac{1}{2}n-O(n^{1-\\gamma})\\) for any positive \\(\\gamma\\) \\cite{doi:10.1109/FOCS.2007.8}, provided that the number of codewords is polynomial in \\(n\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-16"},{"user_id":"VictorVAlbert","date":"2022-03-21"}]},"_zoodb":{"id":"binary_linear","source_file_path":"codes/classical/bits/binary_linear.yml","source_file_modification_token":1684508734540.2302}},"bits_into_bits":{"code_id":"bits_into_bits","physical":"bits","name":"Binary code","description":"Encodes \\(K\\) states (codewords) in \\(n\\) binary coordinates and has distance \\(d\\). Usually denoted as \\((n,K,d)\\). The distance is the minimum Hamming distance between a pair of distinct codewords.\n","protection":"A binary code \\(C\\) \\textit{corrects} \\(t\\) errors in the Hamming distance if\n\\begin{align}\n  \\forall x \\in C~,~D(x,x+y) < D(x' , x+y)\n\\end{align}\nfor all codewords \\(x' \\neq x\\) and all \\(y\\) such that \\(|y|=t\\), where \\(D\\) is the \\textit{Hamming distance} and \\(|y| = D(y,0) \\). A code corrects \\(t\\) errors if and only if \\(d \\geq 2t+1\\), i.e., a code corrects errors on \\(t \\leq \\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.\nThe number of correctable errors is called the \\textit{decoding radius}, and it is upper bounded by half of the distance.\nIn addition, a code detects errors on up to \\(d-1\\) coordinates, and corrects erasure errors on up to \\(d-1\\) coordinates.\n\nPerformance of binary codes can also be measured with respect to deletions and insertions of bits into the codewords. In this case, the metric measuring distance of an error word to the nearest codeword is the \\textit{deletion distance}: given vectors \\(u,v\\), this distance is one-half the smallest number of deletions and insertions needed to change \\(u\\) to \\(v\\). A code \\(C\\) corrects \\(e\\) delections if all codewords are separated by at least \\(e+1\\) in the deletion distance \\cite{arxiv:math/0207197}.\n","features":{"rate":"The rate of a binary code is usually defined as \\(R=\\frac{1}{n}\\log_{2}K\\) bits per symbol.","decoders":["For few-bit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}.","Given a received string \\(x\\) and an error bound \\(e\\), a \\textit{list decoder} returns a list of all codewords that are at most \\(e\\) from \\(x\\) in Hamming distance. The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\)."]},"relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-06"},{"user_id":"VictorVAlbert","date":"2022-02-16"},{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"bits_into_bits","source_file_path":"codes/classical/bits/bits_into_bits.yml","source_file_modification_token":1680994436843.252}},"combinatorial_design":{"code_id":"combinatorial_design","physical":"bits","logical":"bits","name":"Combinatorial design code","description":"A constant-weight binary code that is mapped into a combinatorial \\(t\\)-design.\nThe mapping proceeds as follows for a length-\\(n\\) code with codewords of constant weight \\(w\\).\nA \\(c\\) corresponds to a \\textit{block} of the design, with the codeword's \\(j\\)th coordinate labeling whether or not element \\(j\\) is contained in the block.\nThere are a total of \\(n\\) \\textit{elements}, and the constant weight of the code implies that each block contains a fixed number \\(w\\) of elements.\nThe code supports an \\(S(t,w,n)\\) \\textit{Steiner system} if each subset of \\(t\\leq w\\) elements is contained in exactly one block.\nMore generally, the code supports a \\textit{combinatorial \\(t\\)-design}, or, more precisely, a \\(t-(n,w,\\lambda)\\)-design, if each such \\(t\\)-subset is contained in exactly \\(\\lambda \\geq 1\\) blocks.\n\nFor example, the eight codewords of weight \\(w=3\\) of the \\([7,4,3]\\) Hamming code support a \\(2-(7,3,1)\\)-design a.k.a. an \\(S(2,3,7)\\) Steiner system.\nThe codeword \\(1000110\\) corresponds to a block containing elements 1, 5, and 6.\nSimilarly, the other seven codewords correspond to blocks 257, 367, 147, 246, 345, and 123.\nEach pair of elements is contained in exactly one block.\n\nCombinatorial \\(t\\)-designs exist for all \\(t\\) \\cite{doi:10.1016/0012-365X(87)90061-6}.\n","notes":["See \\cite{preset:HKSdesigns} for more on combinatorial designs."],"relations":{"parents":[{"code_id":"bits_into_bits"},{"code_id":"constant_weight"}],"cousins":[{"code_id":"q-ary_digits_into_q-ary_digits","detail":"Designs can be constructed from \\(q\\)-ary codes by taking the supports of a subset of codewords of constant weight."},{"code_id":"q-ary_cyclic","detail":"The supports of all fixed-weight codewords of a \\(q\\)-ary cyclic code support a combinatorial \\(1\\)-design \\cite[Corr. 5.2.4]{preset:HKSdesigns}."},{"code_id":"reed_muller","detail":"Fixed-weight RM codewords of weight less than \\(2^m\\) support combinatorial 3-designs \\cite[Ex. 5.2.7]{preset:HKSdesigns}."},{"code_id":"hamming743","detail":"Weight-three and weight-four codewords of the \\([7,4,3]\\) Hamming code support combinatorial \\(2-(7,3,1)\\) and \\(2-(7,4,2)\\) designs, respectively \\cite[Ex. 5.2.5]{preset:HKSdesigns}."},{"code_id":"hamming","detail":"Weight-three codewords of the \\([2^r-1,2^r-r-1, 3]\\) Hamming code support the Steiner system \\(S(2,3,2^r-1)\\) \\cite[pg. 89]{preset:splag}."},{"code_id":"extended_hamming","detail":"Weight-four codewords of the \\([2^r,2^r-r-1, 4]\\) extended Hamming code support the Steiner system \\(S(3,4,2^r)\\) \\cite[pg. 89]{preset:splag}."},{"code_id":"golay","detail":"The supports of the weight-seven (weight-eight) codewords of the (extended) Golay code support the Steiner system \\(S(4,7,23)\\) (\\(S(5,6,12)\\)) \\cite[pg. 89]{preset:splag}. Its blocks are called octads."},{"code_id":"ternary_golay","detail":"The supports of the weight-five (weight-six) codewords of the (extended) ternary Golay code support the Steiner system \\(S(4,5,11)\\) (\\(S(5,6,12)\\)) \\cite[pg. 89]{preset:splag}. Its blocks are called hexads."},{"code_id":"perfect","detail":"Perfect codes and combinatorial designs are related \\cite{doi:10.1137/1016056}."},{"code_id":"dual","detail":"Linear codes and their duals are related to combinatorial designs via the Assmus-Mattson theorem \\cite{doi:10.1016/S0021-9800(69)80115-8} (see \\cite[Sec. 5.4]{preset:HKSdesigns})."},{"code_id":"self_dual","detail":"Self-dual extremal codes yield combinatorial \\(\\leq 5\\)-designs using the Assmus-Mattson theorem \\cite{doi:10.1016/S0021-9800(69)80115-8} (see \\cite[Sec. 5.4]{preset:HKSdesigns}). See \\cite[Table 1.61, pg. 683]{doi:10.1201/9781003040897} for a table of combinatorial designs obtained from self-dual codes."},{"code_id":"gallager","detail":"Some Steiner systems can be used to construct Gallager codes \\cite{doi:10.1007/978-1-4613-0165-3_6}."},{"code_id":"algebraic_ldpc","detail":"Combinatorial designs can be used to construct explicit LDPC codes \\cite{doi:10.1109/ITW.2001.955146,doi:10.1109/GLOCOM.2001.965562,doi:10.1109/TCOMM.2003.816946}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-24"}]},"_zoodb":{"id":"combinatorial_design","source_file_path":"codes/classical/bits/combinatorial_design.yml","source_file_modification_token":1683723710985.9084}},"nearly_perfect":{"code_id":"nearly_perfect","physical":"bits","logical":"bits","name":"Nearly perfect code","introduced":"\\cite{doi:10.1016/0012-365X(72)90025-8,manual:{N. V. Semakov, V. A. Zinov'ev, G. V. Zaitsev, “Uniformly Packed Codes”, Probl. Peredachi Inf., 7:1 (1971), 38–50; Problems Inform. Transmission, 7:1 (1971), 30–39}}","description":"An \\((n,K,2t+1)\\) binary code is nearly perfect if parameters \\(n\\), \\(K\\), and \\(t\\) are such that the Johnson bound\n\\begin{align}\n  \\frac{{n \\choose t}\\left(\\frac{n-t}{t+1}-\\left\\lfloor \\frac{n-t}{t+1}\\right\\rfloor \\right)}{\\left\\lfloor \\frac{n}{t+1}\\right\\rfloor }+\\sum_{j=0}^{t}{n \\choose j}\\leq2^{n}/K\n\\end{align}\nbecomes an equality (\\cite{doi:10.1017/CBO9780511807077}, Sec. 2.3.5; see also Ref. \\cite{preset:MacSlo}, Ch. 17).\nAll nearly perfect binary codes are either perfect, or correspond to either punctured Preparata codes or one of the \\(2^{2^r-2-r},2^r-2,3)\\) codes for \\(r\\geq 3\\) \\cite{manual:{Kauko Lindström. \"The nonexistence of unknown nearly perfect binary codes.\" PhD diss., Turun yliopisto, 1975.}}.\n\nSimilar definitions can be made for \\(q\\)-ary codes, but all nearly perfect \\(q\\)-ary codes must be perfect \\cite{manual:{K. Lindstrom and M. J. Aaltonen, \"The nonexistence of nearly perfect nonbinary codes for 1 =< e =< 10\", Ann. Univ. Turku, Ser. A I, No. 172, 1976.},doi:10.1016/S0019-9958(77)90519-8}.\n","relations":{"parents":[{"code_id":"bits_into_bits"},{"code_id":"quasi_perfect","detail":"Nearly perfect codes are quasi-perfect (\\cite{preset:MacSlo}, pg. 533)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"}]},"_zoodb":{"id":"nearly_perfect","source_file_path":"codes/classical/bits/covering/nearly_perfect.yml","source_file_modification_token":1680994436843.3547}},"perfect_binary":{"code_id":"perfect_binary","physical":"bits","logical":"bits","name":"Perfect binary code","description":"An \\((n,K,2t+1)\\) binary code is perfect if parameters \\(n\\), \\(K\\), and \\(t\\) are such that the binary Hamming (a.k.a. sphere-packing) bound\n\\begin{align}\n\\sum_{j=0}^{t} {n \\choose j} \\leq 2^{n}/K\n\\end{align}\nbecomes an equality. For example, for a code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\).\nPerfect codes are those for which balls of Hamming radius \\(t\\) exactly fill the space of all \\(n\\) binary strings.\n\nAny perfect linear binary code is either a binary repetition code, a binary Hamming code, or the binary Golay code \\cite{doi:10.1016/S0019-9958(77)90519-8}.\n\nFor codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-h(t/n),\n\\end{align}\nwhere \\(h\\) is the binary entropy function.\n","relations":{"parents":[{"code_id":"nearly_perfect","detail":"Perfect binary codes are nearly perfect, and \\(t+1\\) divides \\(n-t\\) for such codes. In addition, any perfect code can be extended to a nearly perfect code."},{"code_id":"perfect"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"},{"user_id":"MustafaDoger","date":"2022-04-01"},{"user_id":"VictorVAlbert","date":"2022-03-21"},{"user_id":"VictorVAlbert","date":"2021-12-01"}]},"_zoodb":{"id":"perfect_binary","source_file_path":"codes/classical/bits/covering/perfect_binary.yml","source_file_modification_token":1678631058712.1956}},"bch":{"code_id":"bch","physical":"bits","logical":"bits","name":"Binary BCH code","introduced":"\\cite{doi:10.1016/s0019-9958(60)90287-4,doi:10.1016/S0019-9958(60)90870-6,manual:{A. Hocquenghem, Codes correcteurs d'Erreurs, Chiffres (Paris), vol.2, pp.147-156, 1959.}}","description":"Cyclic binary code of odd length \\(n\\) whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\) (see \\ref{topic:Cyclic-to-polynomial-correspondence}). More precisely, the generator polynomial of a BCH code of \\textit{designed distance} \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called \\textit{narrow-sense} when \\(b=1\\), and are called \\textit{primitive} when \\(n=2^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the \\textit{multiplicative order} of \\(2\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(2^m-1\\). The dimension of a BCH code with \\(\\delta=2t+1\\) is at least \\(n-mt\\). The field \\(GF(2^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\n","protection":"By the BCH bound, BCH code with designed distance \\(\\delta\\) has true distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the \\textit{Bose distance}; the true distance may still be larger than that.\n","features":{"decoders":["Peterson decoder with runtime of order \\(O(n^3)\\) \\cite{doi:10.1109/TIT.1960.1057586,manual:{S. Arimoto, \"Encoding and decoding of p-ary group codes and the correction system,\" Information Processing in Japan (in Japanese), vol. 2, pp. 320-325, Nov. 1961.}} (see exposition in Ref. \\cite{preset:Blahut}).","Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1969.1054260,preset:Berlekamp} and modification by Burton \\cite{doi:10.1109/TIT.1971.1054655}; see also \\cite{preset:PetersonWeldon,doi:10.1007/978-3-7091-2945-6}.","Sugiyama et al. modification of the extended Euclidean algorithm \\cite{doi:10.1016/S0019-9958(75)90090-X,doi:10.1017/CBO9780511606267}.","Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426}."]},"notes":["See books \\cite{preset:MacSlo,preset:LinCostello,doi:10.1017/CBO9780511807077} for expositions on BCH codes and code tables.","See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes.","See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Cyclic Codes (BCH-Bound).” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html}}."],"realizations":["Satellite communication \\cite{manual:{Cheung, K-M., and F. Pollara. \"Phobos lander coding system: Software and analysis.\" The Telecommunications and Data Acquisition Report (1988).}}"],"relations":{"parents":[{"code_id":"binary_cyclic"},{"code_id":"q-ary_bch"}],"cousins":[{"code_id":"quasi_perfect","detail":"Only double error-correcting BCH codes \\([2^m-1,n-2m,5]\\) are quasi-perfect \\cite{doi:10.1016/S0019-9958(60)90877-9,doi:10.1109/TIT.1979.1056043} (see also Ref. \\cite{preset:MacSlo}, Ch. 9)."},{"code_id":"griesmer","detail":"The \\([15,5,7]\\) BCH code extended with a parity check saturates the Griesmer bound (\\cite{doi:10.1201/9781315371993}, pg. 157)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-04"},{"user_id":"MuhammadJunaidAftab","date":"2022-04-21"},{"user_id":"NolanCoble","date":"2021-12-15"},{"user_id":"VictorVAlbert","date":"2021-12-15"},{"user_id":"ManasiShingane","date":"2021-12-05"}]},"_zoodb":{"id":"bch","source_file_path":"codes/classical/bits/cyclic/bch.yml","source_file_modification_token":1680994436843.457}},"binary_cyclic":{"code_id":"binary_cyclic","physical":"bits","logical":"bits","name":"Cyclic linear binary code","description":"A binary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called \\textit{primitive} when \\(n=2^r-1\\) for some \\(r\\geq 2\\). A \\textit{shortened cyclic code} is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes.\n","protection":"Shift bound \\cite{doi:10.1109/TIT.1986.1057134} gives a lower bound on the distance of cyclic binary codes.","features":{"decoders":["Meggitt decoder \\cite{doi:10.1109/TIT.1961.1057659}.","Information set decoding (ISD) \\cite{doi:10.1109/TIT.1962.1057777}, a probabilistic decoding strategy that essentially tries to guess \\(k\\) correct positions in the received word, where \\(k\\) is the size of the code. Then, an error vector is constructed to map the received word onto the nearest codeword, assuming the \\(k\\) positions are error free. When the Hamming weight of the error vector is low enough, that codeword is assumed to be the intended transmission.","Permutation decoding \\cite{doi:10.1002/j.1538-7305.1964.tb04075.x}."]},"notes":["See Ch. 7 of Ref. \\cite{preset:MacSlo} for an exposition on cyclic codes.","See Ref. \\cite{doi:10.1109/18.119714} for tables of the best binary cyclic codes of odd lengths 101 to 127."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"q-ary_cyclic"}],"cousins":[{"code_id":"binary_ltc","detail":"Cyclic linear codes cannot be \\(c^3\\)-LTCs \\cite{doi:10.1109/TIT.2005.851735}. Codeword symmetries are in general an obstruction to achieving such LTCs \\cite{doi:10.1007/978-3-642-16367-8_12}."}]},"_meta":{"changelog":[{"user_id":"MazinKarjikar","date":"2022-12-30"},{"user_id":"VictorVAlbert","date":"2022-07-13"}]},"_zoodb":{"id":"binary_cyclic","source_file_path":"codes/classical/bits/cyclic/binary_cyclic.yml","source_file_modification_token":1678631058712.3948}},"binary_duadic":{"code_id":"binary_duadic","physical":"bits","logical":"bits","name":"Binary duadic code","introduced":"\\cite{doi:10.1109/TIT.1984.1056944}","description":"Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is \\textit{even-like} or \\textit{odd-like} duadic. Duadic codes exist for lengths \\(n\\) that are products of powers of primes, with each prime being \\(\\pm 1\\) modulo \\(8\\) \\cite{doi:10.1007/978-3-7091-2786-5_1}.\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are \\textit{even-like}, i.e., \\(\\sum_i c_i = 0\\), or \\textit{odd-like}, i.e., \\(\\sum_i c_i = 1\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\nA pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an \\textit{even-like duadic pair} if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]\\) codes.\n","protection":"Since duadic codes are cyclic, the BCH bound can be used to determine their minimum distance.","notes":["Reviews of duadic codes \\cite{doi:10.1007/978-3-7091-2786-5_1,doi:10.1017/CBO9780511807077}."],"relations":{"parents":[{"code_id":"binary_cyclic"},{"code_id":"q-ary_duadic"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-07"},{"user_id":"YijiaXu","date":"2022-04-25"}]},"_zoodb":{"id":"binary_duadic","source_file_path":"codes/classical/bits/cyclic/binary_duadic.yml","source_file_modification_token":1678631058712.4775}},"binary_quad_residue":{"code_id":"binary_quad_residue","physical":"bits","logical":"bits","name":"Binary quadratic-residue (QR) code","short_name":"Binary QR","description":"Member of a quadruple of cyclic binary codes of prime length \\(n=8m\\pm 1\\) for \\(m\\geq 1\\) constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see \\ref{topic:Cyclic-to-polynomial-correspondence}) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called \\textit{augmented} quadratic-residue codes, while the remaining codes are called \\textit{expurgated}.\n","notes":["Introduction of quadratic-residue codes in Refs. \\cite{preset:MacSlo,doi:10.1017/CBO9780511807077}."],"relations":{"parents":[{"code_id":"binary_duadic","detail":"QR codes are duadic codes of prime length satisfying certain relations \\cite{doi:10.1007/978-3-7091-2786-5_1}."},{"code_id":"q-ary_quad_residue"}],"cousins":[{"code_id":"group","detail":"The self-dual \\([48,24,12]\\) extended quadratic residue code is a group-algebra code \\cite{doi:10.1007/s10623-011-9530-0}\\cite[Ex. 16.5.1]{preset:HKSalgebra}."},{"code_id":"divisible","detail":"Extended binary quadratic residue codes of length \\(8m\\) are self-dual doubly-even codes \\cite[pg. 82]{doi:10.1007/978-1-4757-6568-7}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-15"},{"user_id":"YijiaXu","date":"2022-04-25"}]},"_zoodb":{"id":"binary_quad_residue","source_file_path":"codes/classical/bits/cyclic/binary_quad_residue.yml","source_file_modification_token":1682250129446.5867}},"golay":{"code_id":"golay","physical":"bits","logical":"bits","name":"Golay code","introduced":"\\cite{manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}","description":"A \\([23, 12, 7]\\) perfect binary linear code with connections to various areas of mathematics, e.g., lattices \\cite{doi:10.1007/978-1-4757-6568-7} and sporadic simple groups \\cite{preset:MacSlo}. Adding a parity bit to the code results in the \\([24, 12, 8]\\) \\textit{extended Golay code}. Up to equivalence, both codes are unique for their respective parameters.\n\nTo construct the Golay code, one can use the great dodecahedron to generate codewords by placing message bits on the faces and calculating the parity bits that live on the 12 vertices of the inner icosahedron.\n","features":{"decoders":["Majority decoding for the extended Golay code \\cite{doi:10.1016/0097-3165(71)90043-4}.","Decoder for the extended Golay code using the hexacode \\cite{doi:10.1109/TIT.1986.1057197}.","Both Golay codes have a trellis representation and can thus be decoded using trellis decoding \\cite{doi:10.1142/9789814287517_0004,doi:10.1049/el:19931456}.","Bounded-distance decoder requiring at most 121 real operations \\cite{doi:10.1109/18.412695}."]},"realizations":["Extended Golay code used in the Voyager 1 and 2 spacecraft, transmitting hundreds of color pictures of Jupiter and Saturn in their 1979, 1980, and 1981 fly-bys \\cite{doi:10.1029/JA092iA13p14873}.","Extended Golay code used in American military standards for automatic link establishment in high frequency radio systems \\cite{manual:{E. E. Johnson. An Efficient Golay Codec For MIL-STD-188-141A and FED-STD-1045. Department of Electrical and Computer Engineering, New Mexico State University, 1991.}}.","Proofs of the quantum mechanical Kochen-Specker theorem \\cite{arxiv:2206.04209}."],"notes":["The automorphism group of the Golay code is the Mathieu group \\(\\mathcal{M}_{23}\\), and the automorphism group of the extended Golay code is the Mathieu group \\(\\mathcal{M}_{24}\\), two of the sporadic simple groups."],"relations":{"parents":[{"code_id":"perfect_binary","detail":"The Golay code is perfect."},{"code_id":"binary_quad_residue","detail":"The Golay code is a binary quadratic residue code with generator polynomial \\(r(x)\\) over \\(GF(2)\\) with length \\(n=23\\) (\\cite{preset:MacSlo}, Ch. 16)."},{"code_id":"bch","detail":"The Golay code is equivalent to a BCH code with Bose distance 5 (\\cite{preset:MacSlo}, Ch. 20)."},{"code_id":"delsarte_optimal_q-ary","detail":"The Golay code and two of its shortened versions are \\(q\\)-ary sharp configurations \\cite[Table 12.1]{preset:HKSbounds}."}],"cousins":[{"code_id":"nearly_perfect","detail":"The extended Golay code is nearly perfect."},{"code_id":"self_dual","detail":"The extended Golay code is self-dual."},{"code_id":"group","detail":"The extended Golay code is a group-algebra code for various groups \\cite{doi:10.1109/TIT.2008.928260,doi:10.1007/s10623-017-0440-7,doi:10.1016/0097-3165(90)90069-9}\\cite[Ex. 16.5.1]{preset:HKSalgebra}."},{"code_id":"univ_opt_q-ary","detail":"The Golay code and several of its extended, shortened, and punctured versions are LP universally optimal codes \\cite{arxiv:1212.1913}."}]},"_meta":{"changelog":[{"user_id":"VikramAmin","date":"2023-01-21"},{"user_id":"VictorVAlbert","date":"2022-01-21"},{"user_id":"VictorVAlbert","date":"2022-08-10"},{"user_id":"NoahBerthusen","date":"2022-03-02"}]},"_zoodb":{"id":"golay","source_file_path":"codes/classical/bits/cyclic/golay.yml","source_file_modification_token":1682250129446.6914}},"gold":{"code_id":"gold","physical":"bits","logical":"bits","name":"Gold code","introduced":"\\cite{doi:10.1109/TIT.1967.1054048}","description":"Member of the family of \\([2^r-1, 2r ]\\) cyclic binary linear code characterized by the generator polynomial of degree \\(r\\) of two maximum-period sequences of period \\(2^r-1\\) with absolute cross-correlation \\( \\leq 2^{(r+2)/2}\\). Gold codewords are generated using \\(m\\)-sequences \\(x\\) and \\(y\\), which are codewords of simplex codes with check polynomials of degree \\(r\\) \\cite{doi:10.1109/TIT.1967.1054048}.","features":{"encoders":["Information bits are initialized in the shift registers of the two \\(m\\)-sequences \\(x\\) and \\(y\\)."],"decoders":["General decoding is done by building a sparse parity check matrix, followed by applying an iterative message passing alogirithm. \\cite{doi:10.1007/s11265-006-7278-y}."]},"realizations":["Used in for synchronization purposes in telecommunication \\cite{manual:{Mujtaba Hamid and Andy Miller, \\emph{Gold Code Generators in Virtex Devices}, (2000)}}","GPS C/A for satellite navigation \\cite{doi:10.1002/j.2161-4296.1978.tb01325.x}."],"relations":{"parents":[{"code_id":"binary_cyclic"}],"cousins":[{"code_id":"simplex","detail":"Simplex codes are used to make gold codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-02"},{"user_id":"khalilguy","date":"2022-01-02"}]},"_zoodb":{"id":"gold","source_file_path":"codes/classical/bits/cyclic/gold.yml","source_file_modification_token":1678631058712.7856}},"melas":{"code_id":"melas","physical":"bits","logical":"bits","name":"Melas code","introduced":"\\cite{doi:10.1147/rd.43.0364,doi:10.1137/S0895480193243365}","description":"Cyclic \\([2^m -1, 2^m - 1 - 2m, 5]\\) linear code with generator polynomial is \\(g(x) = p(x)p(x)^{\\star}\\), where \\(p(x)\\) is a primitive polynomial of degree \\(m\\) that is the minimal polynomial over \\(GF(2)\\) of an element \\(\\alpha\\) of order \\(2^m -1\\) in \\(GF(2^m)\\), \\(m\\) is odd and greater that five, and '\\(\\star\\)' denotes reciprocation \\cite{doi:10.1007/s12095-015-0135-8}.","features":{"decoders":["Algebraic decoder \\cite{doi:10.1007/s12095-015-0135-8}."]},"relations":{"parents":[{"code_id":"binary_cyclic"},{"code_id":"reversible"}],"cousins":[{"code_id":"quaternary_over_z4","detail":"The even-weight subcode of the Melas code can be lifted to a code over \\(\\mathbb{Z}_4\\) \\cite{doi:10.1007/s12095-015-0135-8}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-02"},{"user_id":"khalilguy","date":"2022-01-02"}]},"_zoodb":{"id":"melas","source_file_path":"codes/classical/bits/cyclic/melas.yml","source_file_modification_token":1678631058712.8882}},"zetterberg":{"code_id":"zetterberg","physical":"bits","logical":"bits","name":"Zetterberg code","introduced":"\\cite{doi:10.1109/TIT.1962.1057682}","description":"Family of binary cyclic \\([2^{2s}+1,2^{2s}-4s+1]\\) codes with distance \\(d>5\\) generated by the minimal polynomial \\(g_s(x)\\) of \\(\\alpha\\) over \\(GF(2)\\), where \\(\\alpha\\) is a primitive \\(n\\)th root of unity in the field \\(GF(2^{4s})\\). They are quasi-perfect codes and are one of the best known families of double-error correcting binary linear codes","protection":"Correct at least all weight-2 errors.","features":{"rate":"The rate is given by \\(1-\\frac{4s}{n}\\), which is asymptotically good, with a minimum distance of 5.","decoders":["Kallquist first described an algebraic decoding theorem \\cite{manual:{P. Kallquist, \"Decoding of Zetterberg codes,\" in Proc. Fourth Joint Swedish-Soviet Workshop on Inform. Theory, Gotland, Sweden, Aug. 27-Sept. 1, 1989, p. 305-300}}. A faster version was later provided in Ref. \\cite{doi:10.1109/18.149509} and further modified in Ref. \\cite{doi:10.1109/LCOMM.2010.07.100784}."]},"realizations":["Code used to provide better protection of data transmission with its double error correcting capacity \\cite{doi:10.1109/TIT.1961.1057659}."],"relations":{"parents":[{"code_id":"binary_cyclic"},{"code_id":"quasi_perfect","detail":"Zetterberg codes are quasi-perfect, with each \\(n\\)-bit string at most three bit-flips away from a codeword \\cite{doi:10.1109/18.149509}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"},{"user_id":"XiaozhenFu","date":"2022-03-30"}]},"_zoodb":{"id":"zetterberg","source_file_path":"codes/classical/bits/cyclic/zetterberg.yml","source_file_modification_token":1664458794961.7605}},"hadamard":{"code_id":"hadamard","physical":"bits","logical":"bits","name":"Hadamard code","description":"Also known as a \\textit{Walsh code} or \\textit{Walsh-Hadamard code}.\nAn \\([2^m,m,2^{m-1}]\\) balanced binary code dual to an extended Hamming Code.\n\nThe \\([2^m,m+1,2^{m-1}]\\) \\textit{augmented Hadamard code} can be constructed by adding the all-zero bit.\nIts codewords are the rows of the \\(2^m\\)-dimensional Hadamard matrix \\(H\\) and its negation \\(-H\\) with the mapping \\(+1\\to 0\\) and \\(-1\\to 1\\). Its codewords form a \\(2^m\\)-dimensional biorthogonal spherical code under the antipodal mapping.\n\nThe \\([2^m-1,m,2^{m-1}]\\) \\textit{shortened Hadamard code} is a binary simplex code. Its codewords form a \\(2^m\\)-simplex spherical code under the antipodal mapping.\n","relations":{"parents":[{"code_id":"long","detail":"The Hadamard code is a subcode of the long code and can be obtained by restricting the long-code construction to only linear functions."},{"code_id":"balanced","detail":"Each Hadamard codeword has length \\(2^m\\) and Hamming weight of \\(2^{m-1}\\), making this code balanced."},{"code_id":"ldc","detail":"Hadamard codes are locally decodable \\cite{doi:10.1561/0400000030}."}],"cousins":[{"code_id":"dual","detail":"The Hadamard code is the dual of the extended Hamming Code. Conversely, the shortened Hadamard code is the dual of the Hamming Code."},{"code_id":"hamming","detail":"The shortened Hadamard code is the dual of the Hamming Code."},{"code_id":"extended_hamming","detail":"The Hadamard code is the dual of the extended Hamming Code."},{"code_id":"reed_muller","detail":"The augmented Hadamard code is the RM\\((1,m)\\) code."},{"code_id":"simplex_spherical","detail":"The shortened Hadamard code maps to a \\((2^m,2^m+1)\\) simplex spherical code under the antipodal mapping \\cite[Sec. 6.5.2]{manual:{Forney, G. D. (2003). 6.451 Principles of Digital Communication II, Spring 2003.}}\\cite[pg. 18]{preset:EricZin}."},{"code_id":"biorthogonal","detail":"The augmented Hadamard code maps to a \\((2^m,2^{m+1})\\) biorthogonal spherical code under the antipodal mapping \\cite{doi:10.1109/18.720542}\\cite[Sec. 6.4]{manual:{Forney, G. D. (2003). 6.451 Principles of Digital Communication II, Spring 2003.}}\\cite[pg. 19]{preset:EricZin}."},{"code_id":"delsarte_optimal_q-ary","detail":"Hadamard codes for \\(q=4r\\) are sharp configurations \\cite[Table 12.1]{preset:HKSbounds}."},{"code_id":"univ_opt_q-ary","detail":"Several punctured versions of Hadamard codes are LP universally optimal codes \\cite{arxiv:1212.1913}."},{"code_id":"binary_ltc","detail":"The Hadamard code is the first code to be identified as locally testable \\cite{doi:10.1016/0022-0000(93)90044-W}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2021-12-18"},{"user_id":"DhruvDevulapalli","date":"2021-12-17"}]},"_zoodb":{"id":"hadamard","source_file_path":"codes/classical/bits/easy/hadamard.yml","source_file_modification_token":1683723710986.022}},"extended_hamming":{"code_id":"extended_hamming","physical":"bits","logical":"bits","name":"Extended Hamming code","introduced":"\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x,doi:10.1002/j.1538-7305.1950.tb00463.x,manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}","description":"Member of an infinite family of binary linear codes with parameters \\([2^r,2^r-r-1, 4]\\) for \\(r \\geq 2\\) that are extensions of the Hamming codes by a parity-check bit.\n","relations":{"parents":[{"code_id":"binary_linear"}],"cousins":[{"code_id":"univ_opt_q-ary","detail":"Several extended Hamming codes are LP universally optimal codes \\cite{arxiv:1212.1913}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-12"},{"user_id":"VictorVAlbert","date":"2022-03-22"},{"user_id":"DhruvDevulapalli","date":"2021-12-17"}]},"_zoodb":{"id":"extended_hamming","source_file_path":"codes/classical/bits/easy/hamming/extended_hamming.yml","source_file_modification_token":1682250129446.868}},"hamming":{"code_id":"hamming","physical":"bits","logical":"bits","name":"Hamming code","introduced":"\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x,doi:10.1002/j.1538-7305.1950.tb00463.x,manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}","description":"Member of an infinite family of perfect linear codes with parameters \\([2^r-1,2^r-r-1, 3]\\) for \\(r \\geq 2\\).\nTheir \\(r \\times (2^r-1) \\) parity-check matrix \\(H\\) has all possible non-zero \\(r\\)-bit strings as its columns.\nAdding a parity check yields the \\([2^r,2^r-r-1, 4]\\) \\textit{extended Hamming code}.\n","protection":"Can detect 1-bit and 2-bit errors, and can correct 1-bit errors.","features":{"rate":"Asymptotic rate \\(k/n = 1-\\frac{\\log n}{n} \\to 1\\) and normalized distance \\(d/n \\to 0\\)."},"realizations":["Commonly used when error rates are very low, for example, computer RAM or integrated circuits \\cite{doi:10.1109/SBCCI.2002.1137643}.","Hamming-code based matrix embedding used in steganography \\cite{manual:{Crandall, Ron. \"Some notes on steganography.\" Posted on steganography mailing list 1998 (1998): 1-6.},doi:10.1007/3-540-45496-9_21}."],"notes":["See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes."],"relations":{"parents":[{"code_id":"perfect_binary"},{"code_id":"q-ary_hamming"},{"code_id":"reed_muller","detail":"Binary Hamming codes are equivalent to RM\\(^*(r-2,r)\\)."},{"code_id":"bch","detail":"Binary Hamming codes are binary primitive narrow-sense BCH codes \\cite[Corr. 5.1.5]{doi:10.1017/CBO9780511807077}. Binary Hamming codes are cyclic \\cite[Thm. 12.22]{preset:Hill}."},{"code_id":"univ_opt_q-ary","detail":"Binary Hamming codes and several of their extended, punctured, and shortened versions are LP universally optimal codes \\cite{arxiv:1212.1913}."}],"cousins":[{"code_id":"extended_hamming"},{"code_id":"quantum_hamming"},{"code_id":"nearly_perfect","detail":"Shortened Hamming codes \\([2^r-2,2^r-r-2,3]\\) are nearly perfect (\\cite{preset:MacSlo}, pg. 533)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-12"},{"user_id":"VictorVAlbert","date":"2022-03-22"},{"user_id":"DhruvDevulapalli","date":"2021-12-17"}]},"_zoodb":{"id":"hamming","source_file_path":"codes/classical/bits/easy/hamming/hamming.yml","source_file_modification_token":1682250129446.9272}},"hamming743":{"code_id":"hamming743","physical":"bits","logical":"bits","name":"\\([7,4,3]\\) Hamming code","introduced":"\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x,doi:10.1002/j.1538-7305.1950.tb00463.x,manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}","description":"Second-smallest member of the Hamming code family with generator matrix\n\\begin{align}\n\\left(\\begin{array}{ccccccccccc}\n  1 & 0 & 0 & 0 & 1 & 1 & 0\\\\\n  0 & 1 & 0 & 0 & 1 & 0 & 1\\\\\n  0 & 0 & 1 & 0 & 0 & 1 & 1\\\\\n  0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{array}\\right)~.\n\\end{align}\nUp to equivalence, this is the only nontrivial length-seven perfect binary code containing the zero vector.\n\nThe Hamming code can be extended by a parity-check bit to yield the \\([8,4,4]\\) extended Hamming code, the smallest doubly-even self-dual code.\nIt can be shortened to yield the \\([6,3,3]\\) \\textit{shortened Hamming code}.\nIts dual is the \\([7,3,4]\\) \\textit{little Hamming code}, also known as the \\(S(2,3)\\) simplex code.\n","protection":"Can detect 1-bit and 2-bit errors, and can correct 1-bit errors.","relations":{"parents":[{"code_id":"hamming"},{"code_id":"binary_quad_residue","detail":"\\([7,4,3]\\) Hamming code is a quadratic-residue code with generator polynomial \\(1+x+x^3\\) \\cite{preset:MacSlo}."}],"cousins":[{"code_id":"incidence_matrix","detail":"The \\([7,4,3]\\) Hamming code parity-check matrix corresponds to points in the Fano plane \\(PG_2(2)\\) \\cite[Ex. 21.4.2]{preset:HKSgraphs}."},{"code_id":"hamming844","detail":"The Hamming code can be extended by a parity-check bit to yield the \\([8,4,4]\\) extended Hamming code, the smallest doubly-even self-dual code."},{"code_id":"steane","detail":"The Steane code is constructed from the \\([7,4,3]\\) classical Hamming code."},{"code_id":"griesmer","detail":"Starting with the \\([6,3,3]\\) shortened Hamming code and applying the \\((u|u+v)\\) construction recursively using the repetition code yields a family of \\([2^m,m+1,2^{m-1}]\\) codes for \\(m\\geq1\\) that saturate the Griesmer bound \\cite[pg. 90]{doi:10.1201/9781315371993}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-21"}]},"_zoodb":{"id":"hamming743","source_file_path":"codes/classical/bits/easy/hamming/hamming743.yml","source_file_modification_token":1687727505566.4736}},"hamming844":{"code_id":"hamming844","physical":"bits","logical":"bits","name":"\\([8,4,4]\\) extended Hamming code","introduced":"\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x,doi:10.1002/j.1538-7305.1950.tb00463.x,manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}","description":"Extension of the \\([7,4,3]\\) Hamming code by a parity-check bit.\nThe smallest doubly-even self-dual code.\n","relations":{"parents":[{"code_id":"extended_hamming"}],"cousins":[{"code_id":"divisible","detail":"The extended Hamming code code is the smallest double-even self-dual code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-21"}]},"_zoodb":{"id":"hamming844","source_file_path":"codes/classical/bits/easy/hamming/hamming844.yml","source_file_modification_token":1682250129447.0293}},"one_hot":{"code_id":"one_hot","physical":"bits","logical":"bits","name":"One-hot code","description":"Also known as an \\textit{\\(1\\)-in-\\(n\\)} code. A length-\\(n\\) binary code whose codewords are those with Hamming weight one. The reverse of this code, where all codewords have Hamming weight \\(n-1\\) is called a \\textit{one-cold} code.\n","realizations":["The bi-quinary code, a combination of one-hot 1-in-2 and 1-in-5 one-hot codes to encode decimal digits, was used in several early computers (\\cite{doi:10.1201/9781315115870}, Ch. 27).","Marking the state of a finite automaton \\cite{doi:10.1109/43.41505}.","Used in machine-learning based classification tasks because one-hot encodings, as opposed to integer encodings, do not presume an order \\cite{doi:10.5120/ijca2017915495}."],"relations":{"parents":[{"code_id":"binary_cyclic"},{"code_id":"constant_weight"}],"cousins":[{"code_id":"ppm","detail":"The PPM code is an continuous analogue of the one-hot code."},{"code_id":"quantum_ppm","detail":"The PPM c-q code is an continuous analogue of the one-hot code designed for transmission through quantum channels."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-14"}]},"_zoodb":{"id":"one_hot","source_file_path":"codes/classical/bits/easy/one_hot.yml","source_file_modification_token":1678631058713.2285}},"parity_check":{"code_id":"parity_check","physical":"bits","logical":"bits","name":"Single parity-check (SPC) code","short_name":"SPC","description":"Also known as a \\textit{sum-zero}, \\textit{zero-sum}, or \\textit{even-weight} code. An \\([n,n-1,2]\\) linear binary code whose codewords consist of the message string appended with a parity-check bit such that the parity (i.e., sum over all coordinates of each codeword) is zero. If the Hamming weight of a message is odd (even), then the parity bit is one (zero). This code requires only one extra bit of overhead and is therefore inexpensive.","protection":"This code cannot protect information, it can only detect 1-bit error.","features":{"rate":"The code rate is \\(\\frac{n}{n+1}\\to 1\\) as \\(n\\to\\infty\\).","decoders":["If the receiver finds that the parity information of a codeword disagrees with the parity bit, then the receiver will discard the information and request a resend.","Wagner's rule yields a procedure that is linear in \\(n\\) \\cite{doi:10.1109/TIT.1954.1057466} (see \\cite[Sec. 29.7.2]{doi:10.1017/9781316822708} for a description)."]},"realizations":["Can be realized on almost every communication device. SPCs are some of the earliest error-correcting codes (\\cite{doi:10.1201/9781315115870}, Ch. 27)."],"relations":{"parents":[{"code_id":"binary_cyclic","detail":"Since permutations preserve parity, the cyclic permutation of an SPC codeword is another codeword. The generator polynomial of the code is \\(x-1\\)."},{"code_id":"q-ary_parity_check"},{"code_id":"reed_muller","detail":"RM\\((m-1,m)\\) are parity-check codes."},{"code_id":"nearly_perfect"},{"code_id":"mds"},{"code_id":"divisible","detail":"Binary SPCs are two-divisible."},{"code_id":"delsarte_optimal_q-ary","detail":"The SPC code is a binary sharp configuration \\cite[Table 12.1]{preset:HKSbounds}."}],"cousins":[{"code_id":"repetition","detail":"Binary SPCs and repetition codes are dual to each other."},{"code_id":"binary_linear","detail":"Any \\([n,k,d]\\) code with odd distance can be \\textit{extended} to an \\([n+1,k,d+1]\\) code by adding a bit storing the sum of codeword coordinates."},{"code_id":"ldgm","detail":"Concatenated SPCs are LDGM \\cite{doi:10.1109/20.917609}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"},{"user_id":"VictorVAlbert","date":"2022-07-20"},{"user_id":"VictorVAlbert","date":"2021-12-15"},{"user_id":"YijiaXu","date":"2021-12-14"}]},"_zoodb":{"id":"parity_check","source_file_path":"codes/classical/bits/easy/parity_check.yml","source_file_modification_token":1682250129447.1106}},"repetition":{"code_id":"repetition","physical":"bits","logical":"bits","name":"Repetition code","description":"\\([n,1,n]\\) binary linear code encoding one bit of information into an \\(n\\)-bit string. The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information. The idea is to increase the code distance by repeating the logical information several times. It is a \\((n,1)\\)-Hamming code.","protection":"Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates. The generator matrix is \\(G=\\left[\\begin{smallmatrix}1 & 1&\\cdots& 1 & 1 \\end{smallmatrix}\\right]\\).","features":{"rate":"Code rate is \\(\\frac{1}{n}\\), code distance is \\(n\\).","decoders":["Calculate the Hamming weight \\(d_H\\) of the code. If \\(d_H\\leq \\frac{n-1}{2}\\), decode the code as 0. If \\(d_H\\geq \\frac{n+1}{2}\\), decode the code as 1.","Automaton-like decoders for the repetition code on a 2D lattice, otherwise known as the classical 2D Ising model, were developed by Toom \\cite{manual:{A. L. Toom, “Nonergodic Multidimensional System of Automata”, Probl. Peredachi Inf., 10:3 (1974), 70–79; Problems Inform. Transmission, 10:3 (1974), 239–246},doi:10.1007/978-1-4612-2168-5_18}. An automaton by Gacs yields a decoder for a 1D lattice \\cite{doi:10.1023/A:1004823720305}."],"threshold":["Suppose each bit has probability \\(p\\) of being received correctly, independent for each bit. The probability that a repetition code is received correctly is \\(\\sum_{k=0}^{(n-1)/2}\\frac{n!}{k!(n-k)!}p^{n-k}(1-p)^{k}\\). If \\(\\frac{1}{2}\\leq p\\), then one can always increase the probability of success by increasing the number of physical bits \\(n\\); see section 2.2.1 Ref. \\cite{arXiv:2111.08894} for a pedagogical explanation."],"fault_tolerance":["Triple modular redundancy (TMR) error-correction protocol \\cite{doi:10.1147/rd.62.0200} for fault-tolerant memory operations and classical gate operations; see section 2.6 and 2.7 Ref. \\cite{arXiv:2111.08894} for a pedagogical explanation."]},"realizations":["Repetition codes, in conjunction with other codes, were used in magnetic disks \\cite{doi:10.1109/TCOM.1984.1096094}.","Communication protocol such as FlexRay \\cite{doi:10.1016/C2012-0-07058-5} is using repetition code'"],"relations":{"parents":[{"code_id":"binary_cyclic","detail":"The repetition code is cyclic with generator polynomial \\(1+x+\\cdots+x^{n-1}\\)."},{"code_id":"nearly_perfect"},{"code_id":"reed_muller","detail":"RM\\((0,m)\\) are repetition codes."}],"cousins":[{"code_id":"perfect_binary","detail":"Repetition codes are perfect for odd \\(n\\)."},{"code_id":"quantum_repetition"},{"code_id":"hamming","detail":"The triple repetition code \\([3,1,3]\\) is the smallest Hamming code."}]},"_meta":{"changelog":[{"user_id":"Baobach","date":"2023-02-22"},{"user_id":"VictorVAlbert","date":"2022-09-28"},{"user_id":"VictorVAlbert","date":"2022-05-27"},{"user_id":"VictorVAlbert","date":"2021-12-15"},{"user_id":"YijiaXu","date":"2021-12-14"}]},"_zoodb":{"id":"repetition","source_file_path":"codes/classical/bits/easy/repetition.yml","source_file_modification_token":1681805027414.0293}},"weight_two":{"code_id":"weight_two","physical":"bits","logical":"bits","name":"Weight-two code","introduced":"\\cite{manual:{R. W. Hamming, Letter, April 5, 1978.}}","description":"A length-\\(n\\) binary code whose codewords all have Hamming weight two. Such codes provide slightly extra redundancy for storage of small-scale information such as ZIP codes or decimal digits.\n\nFor example, the two-in-five code has a size 10, thereby providing an encoding for the decimal digits 0 through 9. Such a code detects some single bit-flips as well as unidirectional errors using the fact that each codeword is weight-two. The code fails for any sequence of flips that maintains the constant weight.\n","realizations":["Two-in-five, also known as the two-out-of-five code, was used in the United States Postal Service's POSTNET barcode system as well as the Postal Alpha-numeric Encoding Technique (PLANET).","Two-in-five code forms the numerical part of the \\textit{Code 39} barcode encoding.","Two-in-five code was used on early IBM computers \\cite{doi:10.1145/1457838.1457879,manual:{T. M. Thompson, \\emph{From Error-Correcting Codes Through Sphere Packings To Simple Groups}, Mathematical Association of America, 1983.}}."],"notes":["See Ref. \\cite{preset:HKStwoweight} on weight-two codes."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"constant_weight"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-12"}]},"_zoodb":{"id":"weight_two","source_file_path":"codes/classical/bits/easy/weight_two.yml","source_file_modification_token":1682250129447.1897}},"fountain":{"code_id":"fountain","physical":"bits","logical":"bits","name":"Fountain code","introduced":"\\cite{doi:10.1145/285243.285258}","description":"Code based on the idea of generating an endless stream of custom encoded packets for the receiver. The code is designed so that the receiver can recover the original transmission of size \\(Kl\\) bits after receiving at least \\(K\\) packets each of \\(l\\) bits.\n\nThe simplest example of a fountain code is the random linear fountain code. Take some message of size \\(Kl\\) and split into \\(K\\) packets, \\(p_0, p_1, ..., p_K\\). For each packet \\(\\hat{p}_n\\) to be transmitted do the following: Generate \\(K\\) random bits \\(G_{nk}\\) and let \\(\\hat{p}_n\\) be the bitwise sum of the source packets when \\(G_{nk}\\) is 1,\n\\begin{align}\n\\hat{p}_n = \\sum_{k=1}^K p_k G_{kn}~.\n\\end{align}\nError correction can then be applied to each packet.\n","protection":"Designed to protect against erasures during broadcasting of information by a sender to multiple receivers.","features":{"rate":"Random linear fountain codes approach the Shannon limit as the file size \\(K\\) increases. However, they do not have a fixed encoding rate.","decoders":["Invert the fragment generator matrix resulting from the continuous encoding process. If exactly \\(K\\) packets are received, then the probability of decoding correctly is \\(0.289\\). Extra packets increase this probability exponentially. The decoding runtime is dominated by the matrix inversion step, which takes order \\(O(n^3)\\) time."]},"realizations":["Designed for servers sending data to many recipients, such as during broadcasting or file distribution \\cite{doi:10.1109/TIT.2006.874390,doi:10.1109/MASS.2012.6502540}."],"notes":["Review on fountain codes can be found in Refs. \\cite{doi:10.1049/ip-com:20050237,manual:{Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7–12). IEEE.}}."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"ldgm"}],"cousins":[{"code_id":"random"},{"code_id":"distributed_storage","detail":"There are proposals \\cite{arXiv:1401.0734,arXiv:1705.07983} adapting fountain codes to distributed storage systems."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-15"},{"user_id":"NoahBerthusen","date":"2022-02-25"}]},"_zoodb":{"id":"fountain","source_file_path":"codes/classical/bits/fountain/fountain.yml","source_file_modification_token":1678631058713.7983}},"luby_transform":{"code_id":"luby_transform","physical":"bits","logical":"bits","name":"Luby transform (LT) code","short_name":"LT","introduced":"\\cite{doi:10.1109/SFCS.2002.1181950}","description":"Erasure codes based on fountain codes. They improve on random linear fountain codes by having a much more efficient encoding and decoding algorithm.\n\nLT codes can be constructed as follows. First, randomly choose a degree \\(d_n\\) from a degree distribution depending on total size \\(K\\). Then, randomly choose \\(d_n\\) distinct source packets and let the packet to be transmitted \\(\\hat{p}_n\\) be the bitwise sum of the chosen input packets. This forms a graph connecting encoded packets to source packets.\n","features":{"decoders":["Sum-Product Algorithm (SPA), often called a peeling decoder \\cite{doi:10.1017/CBO9780511791338,manual:{David J. C. MacKay. 2002. Information Theory, Inference & Learning Algorithms. Cambridge University Press, USA}}, similar to belief propagation \\cite{doi:10.1145/3501714.3501727}."]},"relations":{"parents":[{"code_id":"raptor","detail":"Raptor codes using a trivial pre-code are LT codes. Typically, Raptor codes have constant-sized more overhead but are faster to decode."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-26"},{"user_id":"ThomasWrona","date":"2022-05-02"},{"user_id":"NoahBerthusen","date":"2022-04-21"}]},"_zoodb":{"id":"luby_transform","source_file_path":"codes/classical/bits/fountain/luby_transform.yml","source_file_modification_token":1683723710986.3833}},"raptor":{"code_id":"raptor","physical":"bits","logical":"bits","name":"Raptor (RAPid TORnado) code","short_name":"Raptor","introduced":"\\cite{doi:10.1109/TIT.2006.874390,manual:{Petar Maymounkov, \\emph{Online codes}, Technical report, New York University, 2002.}}","description":"Raptor codes are concatenated erasure codes with two layers: an outer \\textit{pre-code} and a Luby-Transform (LT) inner code.\nThe pre-code is a linear binary erasure code, which is applied first to the input to create some redundant data.\nThe LT code is then applied to the intermediate symbols from the pre-code to generate final output symbols to be transmitted.\n\nThe parameters for a Raptor code are \\( (k, C, \\Omega(x)) \\), with \\(C\\) being the pre-code with dimension \\( k \\), and \\( \\Omega(x) \\) being the degree distribution for the LT code.\n\nThe times to encode and decode source blocks are both linear. The space requirement is \\(1/R \\), where \\(R\\) is the rate of the pre-code. Raptor codes with the simplest output distribution (LT code) are called \\textit{pre-code-only} (PCO).\n","protection":"As a type of fountain code, a Raptor code is designed to correct erasures. The error probability of Raptor codes is measured in terms of its overhead, which is how many additional symbols are received above the dimension of the input \\(k\\). This relationship can vary widely depending on the input pre-code and degree distribution. For a well-designed degree distribution, the error probability of a Raptor code is directly related to the error probability of the pre-code's decoder. In other words, if there is a linear time decoder for the pre-code that has subexponentially small error probability, then the Raptor code's error probability will decrease exponentially with increasing overhead (past the \\(n-k\\) overhead symbols necessary for the pre-code).","features":{"decoders":["Raptor codes can be decoded using inactivation decoding \\cite{arXiv:1706.05814}, a combination of belief-propogation and Gaussian elimination decoding."]},"realizations":["Two versions of Raptor codes have been standardized by IETF: \\href{https://datatracker.ietf.org/doc/html/rfc5053}{R10} and the more recent \\href{http://tools.ietf.org/html/rfc6330}{RaptorQ}. RaptorQ is used in mobile multimedia broadcasts as specified in ETSI technical specifications. It is also used in the mobile \\href{https://www.atsc.org/wp-content/uploads/2016/01/A331S33-174r6-Signaling-Delivery-Sync-FEC.pdf}{Next Gen TV} standard.","Raptor codes are useful in scenarios where erasure (i.e. weak signal or noisy channel) is common, such as in military or disaster scenarios."],"notes":["There is an open source RaptorQ implementation in \\href{https://openrq-team.github.io/openrq/}{Java} and \\href{https://github.com/cberner/raptorq}{Rust}."],"relations":{"parents":[{"code_id":"fountain"}],"cousins":[{"code_id":"tornado","detail":"Tornado codes, which can be used as a pre-code for raptor codes, also use a multi-layer approach where redundant symbols are created by one code for another code to use as input."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-25"},{"user_id":"ThomasWrona","date":"2022-04-11"}]},"_zoodb":{"id":"raptor","source_file_path":"codes/classical/bits/fountain/raptor.yml","source_file_modification_token":1678631058714.102}},"tornado":{"code_id":"tornado","physical":"bits","logical":"bits","name":"Tornado code","introduced":"\\cite{doi:10.1145/285243.285258,doi:10.1145/258533.258573,doi:10.1109/18.910575}","description":"Stub.","features":{"rate":"Come arbitrarily close to the capacity of the binary erasure channel.","encoders":["Linear-time encoder."],"decoders":["Linear-time peeling decoder \\cite{doi:10.1109/18.910575}. This decoder either terminates when it has removed a given erasure pattern or when it is stuch in a \\textit{stopping set}."]},"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"ldpc"}],"cousins":[{"code_id":"fountain","detail":"Tornado codes, the precursor to fountain codes, are much slower to encode and decode in the low-rate regime applicable to scalable data transmission \\cite{manual:{Joshi, G., Rhim, J. B., Sun, J., & Wang, D. (2010). Fountain codes. In Global telecommunications conference (GLOBECOM 2010) (pp. 7–12). IEEE.},doi:10.1109/TIT.2006.874390}."},{"code_id":"ldpc","detail":"Tornado codes are similar to LDPC codes, but they use a highly irregular weight distribution for the underlying graphs \\cite{doi:10.1109/TIT.2006.874390}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-26"},{"user_id":"ThomasWrona","date":"2022-05-02"}]},"_zoodb":{"id":"tornado","source_file_path":"codes/classical/bits/fountain/tornado.yml","source_file_modification_token":1679678315320.2402}},"justesen":{"code_id":"justesen","physical":"bits","logical":"bits","name":"Justesen code","introduced":"\\cite{doi:10.1109/TIT.1972.1054893}","description":"Binary linear code resulting from generalized concatenation of a Reed-Solomon (RS) outer code with multiple inner codes sampled from the Wozencraft ensemble, i.e., \\(N\\) distinct binary inner codes of dimension \\(m\\) and length \\(2m\\).\nThe first asymptotically good codes.\n\nJustesen codes are parameterized by \\(m\\), with length \\(n=2mN\\) and dimension \\(k=mK\\), where \\((N=2^m-1,K)\\) is the RS outer code over \\(GF(2^m)\\).\nFurther modifications have improved code parameters \\cite{doi:10.1109/TIT.1973.1055068,doi:10.1016/S0019-9958(74)91016-X,doi:10.1109/TIT.1978.1055861}.\n","features":{"rate":"The first asymptotically good codes. Rate is \\(R_m=k/n=K/2N\\geq R\\) and the relative minumum distance satisfy \\(\\delta_m=d_m/n\\geq 0.11(1-2R)\\), where \\(K=\\left\\lceil 2NR\\right\\rceil\\) for asymptotic rate \\(0<R<1/2\\); see pg. 311 of Ref. \\cite{preset:MacSlo}.\n\nThe code can be improved and extend the range of \\(R\\) from 0 to 1 by \\textit{puncturing}, i.e., by erasing \\(s\\) digits from each inner codeword. This yields a code of length \\(n=(2m-s)N\\) and rate \\(R=mk/(2m-s)N\\). The lower bound of the distance of the punctured code approaches \\(d_m/n=(1-R/r)H^{-1}(1-r)\\) as \\(m\\) goes to infinity, where \\(r\\) is the maximum of 1/2 and the solution to \\(R=r^2/(1+\\log(1-h^{-1}(1-r)))\\), and \\(h\\) is the binary entropy function.\n","decoders":["Generalized minimum distance decoding \\cite{doi:10.1109/TIT.1972.1054893}."]},"realizations":["Generating small-bias sample spaces, i.e., probability distributions that parity functions cannot typically distinguish from the uniform distribution \\cite{doi:10.1145/100216.100244}."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"generalized_concatenated","detail":"Justesen codes can be considered as a generalized concatenation of a Reed-Solomon outer code with \\(N\\) distinct binary inner codes."}],"cousins":[{"code_id":"reed_solomon","detail":"An RS code is the outer code of Justesen codes."},{"code_id":"wozencraft","detail":"Wozencraft ensemble forms the inner codes of Justesen codes."},{"code_id":"random","detail":"The required inner codes are obtained by random sampling from the Wozencraft ensemble, whose length scales logarithmically with \\(n\\)."},{"code_id":"q-ary_bch","detail":"Using more general BCH codes instead of RS codes can improve the parameters of the Justesen codes \\cite{doi:10.1109/TIT.1973.1055068}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-22"},{"user_id":"XiaoXiao","date":"2022-03-25"}]},"_zoodb":{"id":"justesen","source_file_path":"codes/classical/bits/justesen.yml","source_file_modification_token":1680994436843.9421}},"binary_ltc":{"code_id":"binary_ltc","physical":"bits","logical":"bits","name":"Binary linear LTC","description":"A binary linear code \\(C\\) of length \\(n\\) that is a \\((u,R)\\)-LTC with query complexity \\(u\\) and soundness \\(R>0\\).\nMore technically, the code is a \\((u,R)\\)-LTC if the rows of its parity-check matrix \\(H\\in GF(2)^{r\\times n}\\) have weight at most \\(u\\) and if\n\\begin{align}\n  \\frac{1}{r}|H x| \\geq \\frac{R}{n} D(x,C)\n\\end{align}\nholds for any bitstring \\(x\\), where \\(D(x,C)\\) is the Hamming distance between \\(x\\) and the closest codeword to \\(x\\) \\cite[Def. 11]{arxiv:1911.03069}.\n","relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"binary_ltc","source_file_path":"codes/classical/bits/ltc/binary_ltc.yml","source_file_modification_token":1664741378384.5732}},"bsghsv-ltc":{"code_id":"bsghsv-ltc","physical":"bits","logical":"bits","name":"Ben-Sasson-Goldreich-Harsha-Sudan-Vadhan (BGHSV) code","short_name":"BGHSV","introduced":"\\cite{doi:10.1145/1007352.1007361}","description":"Locally testable \\([[n,k,d]]\\) code with \\(n = k^{1+\\epsilon}\\) and query complexity of order \\(O(1/\\epsilon)\\) for any \\(\\epsilon > 0\\).\n","relations":{"parents":[{"code_id":"binary_ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"bsghsv-ltc","source_file_path":"codes/classical/bits/ltc/bsghsv-ltc.yml","source_file_modification_token":1664741378384.634}},"bssvw-ltc":{"code_id":"bssvw-ltc","physical":"bits","logical":"bits","name":"Ben-Sasson-Sudan-Vadhan-Wigderson (BSVW) code","short_name":"BSVW","introduced":"\\cite{doi:10.1145/780542.780631}","description":"Locally testable \\([[n,k,d]]\\) code with \\(n = k \\cdot 2^{\\tilde{O}(\\sqrt{\\log k})}\\) and asymptotically constant query complexity.\n","relations":{"parents":[{"code_id":"binary_ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"bssvw-ltc","source_file_path":"codes/classical/bits/ltc/bssvw-ltc.yml","source_file_modification_token":1664741378384.7012}},"dinur":{"code_id":"dinur","physical":"bits","logical":"bits","name":"Dinur code","introduced":"\\cite{doi:10.1145/1236457.1236459}","description":"Member of infinite family of locally testable \\([[n,n/\\text{polylog}(n),d]]\\) codes with vanishing rate. Code construction relies on a construction utilizing tensor-product codes \\cite{arXiv:cs/0408066}.\n","relations":{"parents":[{"code_id":"binary_ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"dinur","source_file_path":"codes/classical/bits/ltc/dinur.yml","source_file_modification_token":1664741378384.7734}},"gs-ltc":{"code_id":"gs-ltc","physical":"bits","logical":"bits","name":"Goldreich-Sudan code","introduced":"\\cite{doi:10.1145/1162349.1162351}","description":"Locally testable \\([[n,k,d]]\\) code with \\(n = k^{1+O(1/u)}\\) and distance \\(\\Omega(n)\\) for query complexity \\(u\\). The same work also presented a probabilistic construction of codes of size \\(k^{1+o(1)}\\).\n","relations":{"parents":[{"code_id":"binary_ltc","detail":"Goldreich-Sudan codes resulted from what is often referred to as the first systematic study of LTCs."}],"cousins":[{"code_id":"random"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-29"}]},"_zoodb":{"id":"gs-ltc","source_file_path":"codes/classical/bits/ltc/gs-ltc.yml","source_file_modification_token":1664741378384.8682}},"kmrs-ltc":{"code_id":"kmrs-ltc","physical":"bits","logical":"bits","name":"Kopparty-Meir-Ron-Zewi-Saraf (KMRS) code","short_name":"KMRS","introduced":"\\cite{doi:10.1145/3051093,doi:10.1109/TIT.2018.2809788}","description":"Member of a family of locally testable binary linear codes with constant rate, constant relative distance, and subpolynomial query complexity \\(u = (\\log n)^{O(\\log \\log n)}\\)). Later work by Gopi, Kopparty, Oliveira, Ron-Zewi, and Saraf \\cite{doi:10.1109/TIT.2018.2809788} showed that related concatenated codes achieve the Gilbert-Varshamov bound.\n","relations":{"parents":[{"code_id":"binary_ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"kmrs-ltc","source_file_path":"codes/classical/bits/ltc/kmrs-ltc.yml","source_file_modification_token":1664741378384.932}},"long":{"code_id":"long","physical":"bits","logical":"bits","name":"Long code","introduced":"\\cite{doi:10.1145/502090.502098,doi:10.1137/S0097539796302531}","description":"Locally testable \\([[2^{2^k},k,d]]\\) code. The encoder maps a \\(k\\)-bit string into a codeword that consists of the values of all Boolean functions on the \\(k\\)-bit string. The code is not practical, but is useful for certain probabilistically checkable proof (PCP) constructions \\cite{arxiv:1002.3864}.\n","relations":{"parents":[{"code_id":"binary_ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"long","source_file_path":"codes/classical/bits/ltc/long.yml","source_file_modification_token":1664741378385.006}},"lr-cayley-complex":{"code_id":"lr-cayley-complex","physical":"bits","logical":"bits","name":"Left-right Cayley complex code","introduced":"\\cite{arxiv:2111.04808}","description":"Binary code constructed on a left-right Cayley complex using a pair of base codes \\(C_A,C_B\\) and an expander graph \\cite{doi:10.1090/S0273-0979-06-01126-8} such that codewords for a fixed graph vertex are codewords of the tensor code \\(C_A \\otimes C_B\\). A family of such codes is one of the first \\(c^3\\)-LTCs.\n","relations":{"parents":[{"code_id":"binary_ltc","detail":"Left-right Cayley complex codes yield one of the first two families of \\(c^3\\)-LTCs."}],"cousins":[{"code_id":"tensor","detail":"Left-right Cayley complex codewords for a fixed graph vertex are codewords of a tensor code."},{"code_id":"expander","detail":"Left-right Cayley complex codes can be viewed as Tanner-like codes on expander graphs \\cite{doi:10.1090/S0273-0979-06-01126-8}, but with bits defined on squares and constraints on edges (as opposed to edges and vertices, respectively, for expander codes). Expander codes are also typically not locally testable \\cite{doi:10.1145/780542.780594}."},{"code_id":"balanced_product","detail":"Left-right Cayley complexes can be obtained via a balanced product of \\(G\\)-graphs \\cite{arxiv:2111.04808}."},{"code_id":"quantum_tanner","detail":"Applying the CSS construction to two left-right Cayley complex codes yields quantum Tanner codes, and one can simultaneously prove a linear distance for the quantum code and local testability for one of its constituent classical codes \\cite{arxiv:2202.13641}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-29"}]},"_zoodb":{"id":"lr-cayley-complex","source_file_path":"codes/classical/bits/ltc/lr-cayley-complex.yml","source_file_modification_token":1683723710986.4924}},"anticode":{"code_id":"anticode","physical":"bits","logical":"bits","name":"Anticode","introduced":"\\cite{doi:10.1049/el:19700293,doi:10.1049/el:19740269}","description":"Code for which the distance between any two codewords is less than or equal to some value \\(\\delta\\) called the maximum distance. Anticodes can be used to construct codes that saturate the Griesmer bound; see Refs. \\cite{doi:10.1201/9781315371993,doi:10.1016/S0012-365X(99)00183-1,preset:MacSlo} for more details.","relations":{"parents":[{"code_id":"bits_into_bits"}],"cousins":[{"code_id":"griesmer","detail":"Several anticode (e.g., \\cite{manual:{B. I. Belov, V. N. Logachev, V. P. Sandimirov, “Construction of a Class of Linear Binary Codes Achieving the Varshamov-Griesmer Bound”, Probl. Peredachi Inf., 10:3 (1974), 36–44; Problems Inform. Transmission, 10:3 (1974), 211–217},manual:{R. Hill, \"Optimal Linear Codes in: C. Mitchell (Ed.) Crytography and Coding.\" (1992): 75-104.}}) and related \\cite{manual:{B. I. Belov, \"A conjecture on the Griesmer bound.\" Optimization Methods and Their Applications,(Russian), Sibirsk. Energet. Inst. Sibirsk. Otdel. Akad. Nauk SSSR, Irkutsk 182 (1974): 100-106.}} constructions saturate the Griesmer bound; see Refs. \\cite{doi:10.1201/9781315371993,doi:10.1016/S0012-365X(99)00183-1,preset:MacSlo} for more details."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"}]},"_zoodb":{"id":"anticode","source_file_path":"codes/classical/bits/nonlinear/anticode.yml","source_file_modification_token":1680994436844.3198}},"batch":{"code_id":"batch","physical":"bits","logical":"bits","name":"Batch code","introduced":"\\cite{doi:10.1145/1007352.1007396}","description":"Binary code designed for minimizing the total amount of storage and the worst-case maximal load on any devices in a distributed system.\n\nAn \\((n,N,k,m,t)\\) batch code encodes a length-\\(n\\) string \\(x_1,\\cdots,x_n\\) into an \\(m\\)-tuple of strings of total length \\(N\\) (are also called buckets), such that for each \\(k\\)-tuple of distinct indices \\(i_1,i_2,...,i_k\\), the entries \\(x_{i_1},...,x_{i_k}\\) can be decoded by reading at most \\(t\\)-symbols from each bucket. If each bucket of a batch code contains a single symbol, then the \\((n,N,k,m)\\) batch code is \\textit{primitive}.\n\nA multi-user generalization of batch code is named multiset batch code. If, for any multiset \\(i_1, i_2, ..., i_k \\in [n]\\), there is a partition of buckets into subsets \\(S_1, ..., S_k \\subset [m]\\) such that each \\(x_{i_j}\\) can be recovered by reading at most one symbol from each bucket in \\(S_j\\), then the \\((n, N, k, m)\\) code is a \\textit{multiset batch code}.\n\nCombining two batch codes \\(C_1\\) and \\(C_2\\), which are \\((n_1,N_1,k_1,m_1)\\) and \\((n_2,N_2,k_2,m_2)\\) batch codes respectively, yields a composite batch code \\(C_1\\otimes C_2\\), which is an \\((n_1, m_1N_2, k_1 k_2, m_1 m_2)\\) batch code.\n","relations":{"parents":[{"code_id":"bits_into_bits"},{"code_id":"locally_recoverable","detail":"A systematic batch code with restricted size of reconstruction sets can recover any query of \\(t\\) information symbols with recovery sets of size \\(r\\) \\cite{doi:10.1007/978-3-319-70293-3_16,doi:10.1109/TIT.2021.3131620}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-07"},{"user_id":"YijiaXu","date":"2022-04-25"}]},"_zoodb":{"id":"batch","source_file_path":"codes/classical/bits/nonlinear/batch.yml","source_file_modification_token":1680994436844.38}},"conference":{"code_id":"conference","physical":"bits","logical":"bits","name":"Conference code","introduced":"\\cite{doi:10.1111/j.1749-6632.1970.tb56492.x}\\cite[pg. 55]{preset:MacSlo}","description":"A member of the family of \\((n,2n+2,(n-1)/2)\\) non-linear binary codes for \\(n=1\\) modulo 4 that are constructed from conference matrices.\n\nA \\textit{conference matrix} \\(H\\) is a symmetric \\(n+1\\)-dimensional matrix with zero on its diagonal and \\(\\pm 1\\) elsewhere that satisfies \\(H H^T = n I_{n+1} \\), where \\(I_n\\) is the \\(n\\)-dimensional identity matrix.\nBy multiplying rows and columns by \\(-1\\), \\(H\\) can be \\textit{normalized} to the form \\(\\left(\\begin{smallmatrix}0 & f\\\\\nf^{T} & J\n\\end{smallmatrix}\\right)\\), where \\(J\\) is an \\(n\\)-dimensional matrix satisfying \\(J^{T}J=nI_{n}-F\\) for some matrix \\(F\\) satisfying \\(JF=FJ=0\\).\nThe code is made up of the \\(2n\\) rows of the two matrices \\(\\frac{1}{2}\\left(I+F\\pm J\\right)\\) along with the all-zeroes and all-ones vectors.\n","relations":{"parents":[{"code_id":"bits_into_bits"},{"code_id":"univ_opt_q-ary","detail":"Conference codes are LP universally optimal codes \\cite{arxiv:1212.1913}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-30"}]},"_zoodb":{"id":"conference","source_file_path":"codes/classical/bits/nonlinear/conference.yml","source_file_modification_token":1680994436844.437}},"gray":{"code_id":"gray","physical":"bits","logical":"bits","name":"Gray code","introduced":"\\cite{manual:{Gray, Frank. \"Pulse code communication.\" United States Patent Number 2632058 (1953).},doi:10.1002/j.1538-7305.1958.tb03887.x,doi:10.1137/0209013}","description":"The first Gray code \\cite{manual:{Gray, Frank. \"Pulse code communication.\" United States Patent Number 2632058 (1953).}}, now called the \\textit{binary reflected Gray code}, is a trivial code that orders length-\\(n\\) binary strings such that nearest-neighbor strings differ by only one digit.\n\nA simple example is the case \\(n=2\\), also known as the \\textit{Gray map}, which produces the ordering \\(0\\to 00\\), \\(1\\to 01\\), \\(2\\to 11\\), and \\(3\\to 10\\).\nThe Gray map differs in the last two numbers from the usual binary expansion of the natural numbers, which maps \\(0\\to 00\\), \\(1\\to 01\\), \\(2\\to 10\\), and \\(3\\to 11\\).\n\nLayout out the Gray-map output strings counterclockwise on the corners of a 1D square, gray codes have been generalized such that nearest-neighbor strings differ by only one digit when the strings are arranged in higher-dimensional hypercubes \\cite{doi:10.1002/j.1538-7305.1958.tb03887.x}.\nFurther generalizations called \\textit{combinatorial Gray codes} \\cite{doi:10.1137/0209013} refer to methods to generate organize combinatorial objects such that successive objects differ in some particular way. Particular \\(q\\)-ary extensions \\cite{doi:10.1109/TSMCB.2012.2210706} of Gray codes may be useful in digital imaging and signal processing.\n","features":{"encoders":["Efficient encoder for binary reflected Gray code \\cite{doi:10.1145/360336.360343}."]},"realizations":["Three-dimensional imaging \\cite{doi:10.1364/AO.36.004463}.","Broadcasting and communication \\cite{doi:10.1109/12.29465}."],"notes":["See Refs. \\cite{doi:10.1137/S0036144595295272,doi:10.1201/9780429332760-9,arxiv:2202.01280} reviews of various Gray codes."],"relations":{"parents":[{"code_id":"bits_into_bits"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"}]},"_zoodb":{"id":"gray","source_file_path":"codes/classical/bits/nonlinear/gray.yml","source_file_modification_token":1680994436844.6394}},"levenshtein":{"code_id":"levenshtein","physical":"bits","logical":"bits","name":"Levenshtein code","introduced":"\\cite{manual:{V.I. Levenshtein, \\emph{Application of Hadamard matrices to a problem in coding theory}, Problems of Cybernetics, vol. 5, GIFML, Moscow, 1961, 125–136.}}","description":"Binary codes constructed from combining two codes \\(A'\\) constructed out of Hadamard matrices.\n\nLet \\(H_n\\) be a normalized Hadamard matrix. The generator matrix for an \\((n-1,n,n/2)\\) code \\(A_n\\) is obtained by taking \\(H_n\\), replacing the +1's by 0's and the -1's by 1's, and deleting the first column. Taking only the codewords of \\(A_n\\) which begin with 0 and deleting the leading 0 yields the generator matrix of an \\((n-2,n/2,n/2)\\) code \\(A_n'\\).\n\nNext, apply the following way of combining codes. Suppose we have an \\((n_1,M_1,d_1)\\) code \\(C_1\\) and an \\((n_2,M_2,d_2)\\) code \\(C_2\\). The combined \\((an_1+bn_2,\\min(M_1,M_2),ad_1+bd_2)\\) code \\(a C_1\\bigoplus b C_2\\) may be constructed by pasting \\(a\\) copies of \\(C_1\\) and \\(b\\) copies of \\(C_2\\) together and omitting the last \\(|M_1-M_2|\\) rows. Applying this to construct a Levenshtein code with length \\(n\\) and distance \\(d\\), define \\(k=\\lfloor d/(2d-n)\\rfloor\\), \\(a=d(2k+1)-n(k+1)\\), and \\(b=kn-d(2k-1)\\). If \\(n\\) is even, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is even, construct \\(aA_{2k}\\bigoplus\\frac{b}{2}A_{4k+4}'\\). If \\(n\\) is odd and \\(k\\) is odd, construct \\(\\frac{a}{2}A_{4k}'\\bigoplus b A_{2k+2}\\).\n","protection":"Levenshtein codes meet the Plotkin bound \\(K\\leq 2\\left\\lfloor\\frac{d}{2d-n}\\right\\rfloor\\), where \\(K\\) is the number of codewords, \\(d\\) is the distance, and \\(n\\) is the length, and with the assumption that the Hadamard matrices for such parameters exist. The general proof depends on the correctness of Hadamard's conjecture \\cite{preset:MacSlo}.","relations":{"parents":[{"code_id":"bits_into_bits"}],"cousins":[{"code_id":"hadamard","detail":"The augmented Hadamard and Levenshtein codes are both constructed using Hadamard matrices."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"},{"user_id":"RichardBarney","date":"2022-04-05"}]},"_zoodb":{"id":"levenshtein","source_file_path":"codes/classical/bits/nonlinear/levenshtein.yml","source_file_modification_token":1680994436844.6965}},"best":{"code_id":"best","physical":"bits","logical":"bits","name":"Best \\((10,40,4)\\) code","short_name":"Best","introduced":"\\cite{manual:{Best, M.R. 1978. Binary codes with minimum distance four. Report ZW 112/78, Math Centrum, Amsterdam.},doi:10.1109/TIT.1980.1056269}","description":"Binary nonlinear \\((10,40,4)\\) code that is unique \\cite{doi:10.1109/18.333896}.\nUnder Construction \\(A\\), this code yields \\(P_{10c}\\), a non-lattice sphere packing that is the densest known in 10 dimensions \\cite{doi:10.4153/CJM-1971-081-3}\\cite[pg. 140]{doi:10.1007/978-1-4757-6568-7}.\nCodewords can be obtained by applying the Gray map to a nonlinear code over \\(\\mathbb{Z}_4\\) called the \\textit{pentacode} \\cite[Sec. 2]{doi:10.1007/BF01388558}.\n","relations":{"parents":[{"code_id":"bits_into_bits"}],"cousins":[{"code_id":"construction_a","detail":"Using Construction \\(A\\), the Best code yields \\(P_{10c}\\), a non-lattice sphere packing in 10 dimensions that is the densest known \\cite{doi:10.4153/CJM-1971-081-3}\\cite[pg. 140]{doi:10.1007/978-1-4757-6568-7}."},{"code_id":"analog","detail":"Using Construction \\(A\\), the Best code yields \\(P_{10c}\\), a non-lattice sphere packing in 10 dimensions that is the densest known \\cite{doi:10.4153/CJM-1971-081-3}\\cite[pg. 140]{doi:10.1007/978-1-4757-6568-7}."},{"code_id":"q-ary_over_zq","detail":"The Best code is an image of a nonlinear code over \\(\\mathbb{Z}_4\\) under the Gray map \\cite[Sec. 2]{doi:10.1007/BF01388558}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"best","source_file_path":"codes/classical/bits/nonlinear/sphere_packing/best.yml","source_file_modification_token":1680994436844.7754}},"julin12":{"code_id":"julin12","physical":"bits","logical":"bits","name":"Julin-Golay code","short_name":"Julin-Golay","introduced":"\\cite{doi:10.1109/TIT.1954.1057463,doi:10.1109/TIT.1965.1053779,doi:10.4153/CJM-1971-081-3}","description":"One of several nonlinear binary \\((12,144,4)\\) codes based on the Steiner system \\(S(5,6,12)\\) \\cite{manual:{J. A. Barrau, On the combinatory problem of Steiner, Proc. Section of Sciences, Koninklijke Akademie van Wetenschappen te Amsterdam 11 (1908), 352–360.},doi:10.4153/CJM-1964-065-1}\\cite[Sec. 2.7]{preset:MacSlo}\\cite[Sec. 4]{doi:10.1007/BF01388558}\nor their shortened versions, the nonlinear \\((11,72,4)\\), \\((10,38,4)\\), and \\((9,20,4)\\) Julin-Golay codes.\nSeveral of these codes contain more codewords than linear codes of the same length and distance and yield non-lattice sphere-packings that hold records in 9 and 11 dimensions.\n\nThe codewords of the length-12 codes are 132 distinct mod-two pairwise row sums of an \\(11\\)-dimensional matrix derived from the \\(12\\)-dimensional Hadamard matrix \\(H\\) along with their negations, 6 mutually disjoint codewords of weight two, and 6 codewords of weight 10 whose complements are mutually disjoint.\n\nUsing Construction \\(A\\), some Julin-Golay length-12 codes yield 12-dimensional non-lattice sphere packings, collectively called \\(P_{12a}\\), with kissing number 840 \\cite{doi:10.4153/CJM-1971-081-3}\\cite[pg. 139]{doi:10.1007/978-1-4757-6568-7}.\nThis is the highest known kissing number in that dimension.\nThe length-11 code yields \\(P_{11a}\\), a non-lattice sphere packing that is the densest known in 11 dimensions.\nThe length-9 code yields a non-lattice sphere packing called \\(P_{9a}\\) with kissing number 306, the highest known in 9 dimensions.\n\nThe Julin-Golay length-12 codes are not to be confused with the Best \\((12,144,4)\\) code \\cite{manual:{Best, M.R. 1978. Binary codes with minimum distance four. Report ZW 112/78, Math Centrum, Amsterdam.}}, which is not based on a Steiner system \\cite[Sec. 3]{doi:10.1007/BF01388558}.\n","relations":{"parents":[{"code_id":"sloane_whitehead"}],"cousins":[{"code_id":"analog","detail":"Using Construction \\(A\\), the Julin-Golay codes yield non-lattice sphere-packings that hold records in 9 and 11 dimensions."},{"code_id":"construction_a","detail":"Using Construction \\(A\\), the Julin-Golay codes yield non-lattice sphere-packings that hold records in 9 and 11 dimensions."},{"code_id":"q-ary_over_zq","detail":"Julin codes can be obtained from simple nonlinear codes over \\(\\mathbb{Z}_4\\) using the Gray map \\cite{doi:10.1007/BF01388558}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-31"}]},"_zoodb":{"id":"julin12","source_file_path":"codes/classical/bits/nonlinear/sphere_packing/julin12.yml","source_file_modification_token":1682250129447.2993}},"sloane_whitehead":{"code_id":"sloane_whitehead","physical":"bits","logical":"bits","name":"Sloane-Whitehead code","introduced":"\\cite{doi:10.1109/TIT.1970.1054540}","description":"Member of an infinite \\((n,\\lambda\\cdot 2^{n-m-1},3)\\) nonlinear code family for any \\(n\\) satisfying \\(2^m \\leq n < 3.2^{m-1}\\) for some \\(m\\) and for \\(\\lambda\\in\\{20/16,19/16,18/16\\}\\).\nSuch a code has more codewords than any linear code with the same length and distance.\nThe code is constructed by applying the \\((u|u+v)\\) construction recursively to the Julin-Golay codes.\n","relations":{"parents":[{"code_id":"bits_into_bits"},{"code_id":"uplusv"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-31"}]},"_zoodb":{"id":"sloane_whitehead","source_file_path":"codes/classical/bits/nonlinear/sphere_packing/sloane_whitehead.yml","source_file_modification_token":1680994436844.896}},"vasilyev":{"code_id":"vasilyev","physical":"bits","logical":"bits","name":"Vasilyev code","introduced":"\\cite{manual:{J. L. Vasilyev On nongroup close-packed codes (in Russian), Probl. Kibernet., 8 (1962), 337-339, translated in Probleme der Kibernetik 8 (1965), 375-378}}","description":"Member of an infinite \\((2^{m+1}-1,2^{2n-m},3)\\) family of perfect nonlinear codes for any \\(m \\geq 3\\).\nConstructed by applying a modification of the \\((u|u+v)\\) construction to a perfect \\((2^m-1,2^{n-m},3)\\) code, not necessarily linear \\cite[pg. 77]{preset:MacSlo}.\n","relations":{"parents":[{"code_id":"bits_into_bits"},{"code_id":"uplusv"},{"code_id":"perfect_binary","detail":"Vasilyev codes are perfect nonlinear binary codes and are inequivalent to any linear code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-31"}]},"_zoodb":{"id":"vasilyev","source_file_path":"codes/classical/bits/nonlinear/vasilyev.yml","source_file_modification_token":1680994436844.9475}},"vt_single_deletion":{"code_id":"vt_single_deletion","physical":"bits","logical":"bits","name":"Binary Varshamov-Tenengolts (VT) code","short_name":"Binary VT","introduced":"\\cite{manual:{R. R. Varshamov and G. M. Tenengolts, \\emph{Codes which correct single asymmetric errors} (translated to English), Autom. Remote Control, 26(2), 286-290 (1965)},manual:{V. I. Levenshtein, \\emph{Binary codes capable of correcting deletions, insertions and reversals} (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).}}","description":"Nearly optimal binary deletion-correcting code. Given integers \\(n\\geq 1\\) and \\(a\\in\\{0,1,\\dots,n\\}\\), the associated binary Varshamov-Tenengolts code \\(C_{n,a}\\) corresponds to the set\n\n\\begin{align}\nC_{n,a}=\\left\\{x\\in\\{0,1\\}^n: \\sum_{i=1}^n i~x_i = a\\mod (n+1) \\right\\}.\n\\end{align}","protection":"Corrects a single asymmetric error (a \\(0\\) mapped to a \\(1\\)), a single deletion, or a single insertion of an arbitrary bit in an arbitrary position for any choice of \\(a\\).","features":{"rate":"Rate-\\(1\\) code, with \\(\\log n+1\\) bits of redundancy when \\(a=0\\). Nearly optimal.","decoders":["Decoder based on checksums \\(\\sum_{i=1}^n i~x_i^{\\prime}\\) of corrupted codewords \\(x_i^{\\prime}\\) \\cite{manual:{V. I. Levenshtein, \\emph{Binary codes capable of correcting deletions, insertions and reversals} (translated to English), Soviet Physics Dokl., 10(8), 707-710 (1966).},manual:{V. I. Levenshtein, \\emph{Binary codes capable of correcting spurious insertions and deletions of one} (translated to English), Prob. Inf. Transmission, 1(1), 8-17 (1965).}}."]},"relations":{"parents":[{"code_id":"bits_into_bits"}],"cousins":[{"code_id":"binary_linear","detail":"By adapting a construction of Tenengolts \\cite{manual:{G. M. Tenengolts, \\emph{Class of codes correcting bit loss and errors in the preceding bit} (translated to English), Automation and Remote Control, 37(5), 797–802 (1976).}}, binary VT codes can be modified to yield slightly longer linear codes \\cite{arxiv:math/0207197}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-06"},{"user_id":"JoaoRibeiro","date":"2022-07-06"}]},"_zoodb":{"id":"vt_single_deletion","source_file_path":"codes/classical/bits/nonlinear/vt_single_deletion.yml","source_file_modification_token":1680994436845.008}},"polar":{"code_id":"polar","physical":"bits","logical":"bits","name":"Polar code","introduced":"\\cite{doi:10.1109/TIT.2009.2021379}","description":"In its basic version, a binary linear polar code encodes \\(K\\) message bits into \\(N=2^n\\) bits. The linear transformation that defines the code is given by the matrix \\(G^{(n)}=B_N G^{\\otimes n}\\), where \\(B_N\\) is a certain \\(N\\times N\\) permutation matrix, and \\(G^{\\otimes n}\\) is the \\(n\\)th Kronecker power of the \\(2\\times 2\\) \\textit{kernel matrix} \\(G=\\left[\\begin{smallmatrix}1 & 0\\\\ 1 & 1 \\end{smallmatrix}\\right]\\). To encode \\(K\\) message bits, one forms an \\(N\\)-vector \\(u\\) in which \\(K\\) coordinates represent the message bits. The remaining \\(N-K\\) coordinates are set to some fixed values and are said to be \\textit{frozen}. The codeword \\(x \\in \\{0,1\\}^N\\) is obtained as \\(x=u G^{\\otimes n}\\).\n\nThe choice of the frozen coordinates depends on the communication channel, and they correspond to the least reliable bits on the output of the channel under a particular decoding procedure called successive cancellation decoding. If the communication channel is input-symmetric, the values of the frozen bits can be set to zero.\n\nThere are multiple variants of the above basic construction, in particular relying on other kernel matrices \\cite{doi:10.1109/TIT.2010.2080990}.\nThe codes can be defined for nonbinary alphabets, and they can be adjusted to support tasks such as lossless and lossy compression, successive refinement, communication over the mulitple access channel, communication over the wiretap channel, and many others.\n","protection":"Protects against various types of noise in the communication channel, for instance, errors, erasures, or other types of noise. Distance plays no role in the analysis of its properties, and is much lower than the largest possible value given \\(K,N\\). Polar codes often need to be tailored for a given channel, but universal constructions also exist \\cite{doi:10.1109/ISIT.2014.6875073}.","features":{"rate":"Supports reliable transmission at rates \\(K/N\\) approaching the Shannon capacity of the channel under the successive cancellation decoder \\cite{doi:10.1109/TIT.2009.2021379,doi:10.1109/ISIT.2009.5205860}; see also Refs. \\cite{doi:10.1109/TIT.2016.2616117,doi:10.1109/ISIT.2010.5513579}.","decoders":["Successive cancellation (SC) decoder \\cite{doi:10.1109/TIT.2009.2021379}.","Successive cancellation list (SCL) decoder \\cite{doi:10.1109/TIT.2015.2410251} and a modification utilizing sequence repetition (SR-List) \\cite{arXiv:2205.08857}.","Soft cancellation (SCAN) decoder \\cite{doi:10.1109/JSAC.2014.140515,doi:10.1109/ICC.2013.6655247}.","Belief propagation (BP) decoder \\cite{doi:10.1109/LCOMM.2008.080017}.","Noisy quantum gate-vased decoder \\cite{arxiv:2210.10854}."]},"realizations":["Code control channels for the 5G NR (New Radio) interfaces \\cite{manual:{3rd Generation Partnership Project (3GPP), \\emph{Technical specification group radio access network}, 3GPP TS 38.212 V.15.0.0, 2017.}}."],"notes":["For more details, see Ref. \\cite{preset:HKSpolar}.","See Kaiserslautern database \\cite{preset:KLdatabase} and the pretty-good-codes database \\cite{preset:PGCdatabase} for explicit representatives and benchmarking.","Codes have been benchmarked using AFF3CT toolbox \\cite{doi:10.1016/j.softx.2019.100345}.","Polar codes are also useful for source coding \\cite{doi:10.1109/TIT.2010.2040961}."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"generalized_concatenated","detail":"Polar codes can be represented as generalized concatenations of their kernels."}],"cousins":[{"code_id":"reed_muller","detail":"RM codes rely on the same generator matrix, but place message bits in different coordinates. There are families interpolating between the two codes \\cite{doi:10.1109/TCOMM.2014.2345069}."},{"code_id":"polar_for_quantum","detail":"Quantum-classical polar codes generalize polar codes for transmission through channels with quantum output."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-12"},{"user_id":"AlexanderBarg","date":"2021-11-10"},{"user_id":"VictorVAlbert","date":"2021-11-04"}]},"_zoodb":{"id":"polar","source_file_path":"codes/classical/bits/polar.yml","source_file_modification_token":1683723710986.7598}},"classical_fractal_liquid":{"code_id":"classical_fractal_liquid","physical":"bits","logical":"bits","name":"Fractal liquid code","introduced":"\\cite{arXiv:1111.3275,arxiv:1302.6248}","description":"Member of a family of \\([L^D,O(L^{D-1}),O(L^{D-\\epsilon})]_p\\) linear codes on \\(D\\)-dimensional square lattices of side length \\(L\\) and for some prime \\(p\\) and \\(\\epsilon > 0\\) that is based on \\(p\\)-ary generalizations of the Sierpinski triangle.\n","protection":"Parameters of some code families saturate the classical version of the BPT bound \\cite{arxiv:1111.3275}.","relations":{"parents":[{"code_id":"q-ary_linear"}],"cousins":[{"code_id":"hamiltonian","detail":"Fractal liquid codewords form the ground-state space of a class of spin-glass models with three-body interactions."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-12"}]},"_zoodb":{"id":"classical_fractal_liquid","source_file_path":"codes/classical/bits/quantum_inspired/classical_fractal_liquid.yml","source_file_modification_token":1681484685075.8918}},"fibonacci_model":{"code_id":"fibonacci_model","physical":"bits","logical":"bits","name":"Fibonacci code","introduced":"\\cite{arXiv:2002.11738}","description":"The code is defined on an \\(L\\times L/2\\) lattice with one bit on each site, where \\(L=2^N\\) for an integer \\(N\\geq 2\\). The codewords are defined to satisfy the condition that, for each lattice site \\((x,y)\\), the bits on \\((x,y)\\), \\((x+1,y)\\), \\((x-1,y)\\) and \\((x,y+1)\\) (where the lattice is taken to be periodic in both directions) contain an even numbers of \\(1\\)'s.\nThe codewords can be generated using a one-dimensional cellular automaton of length \\(L\\) (periodic). The \\(2^L\\) possible initial states correspond to the \\(2^L\\) codewords. For each generation, the state of each cell is the xor sum of that cell and its two neighbors in the previous generation. After \\(L/2-1\\) generations, the entire history generated by the automaton corresponds to a codeword, where the initial state is the first row of the lattice, the first generation is the second row, etc.\n","protection":"Protects against small weight errors and string-like errors. The code distance is more than \\(L\\), but the exact value is unknown.\n","features":{"decoders":["An efficient algorithm base on minimum-weight perfect matching \\cite{arXiv:2002.11738}, which can correct high-weight errors that span the lattice, with failure rate decaying super-exponentially with \\(L\\)."]},"relations":{"parents":[{"code_id":"binary_linear"}],"cousins":[{"code_id":"haah_cubic","detail":"The Fibonacci code is designed to mimic the fractal properties of (quantum) Haah cubic code so that studying the former can help us toward the development of an efficient algorithm for the latter."}]},"_meta":{"changelog":[{"user_id":"YiTingRickTu","date":"2022-03-28"}]},"_zoodb":{"id":"fibonacci_model","source_file_path":"codes/classical/bits/quantum_inspired/fibonacci_model.yml","source_file_modification_token":1681484685075.9712}},"homological_classical":{"code_id":"homological_classical","physical":"bits","logical":"bits","name":"Graph homology code","introduced":"\\cite{arXiv:quant-ph/0605094}","description":"This code's properties are derived from the size two chain complex associated with a particular graph. Given a connected simplicial (no self loops or muliedges) graph \\(G = (V, E)\\), which is not a tree, with incidence matrix \\(\\Gamma\\) we can construct a code by choosing a parity check matrix which consists of all the linearly independent rows of \\(\\Gamma\\). This is a \\([n,k,d]\\) code with \\(n = |E|\\), \\(k = 1 - \\mathcal{X}(G) = 1-|V|+|E|\\), where \\( \\mathcal{X}(G)\\) is the euler characteristic of the graph. The code distance is equal to the shortest size of a cycle, guaranteed to exist since \\(G\\) is not a tree.\n","relations":{"parents":[{"code_id":"binary_linear"}],"cousins":[{"code_id":"perfect_binary","detail":"A family of homology codes saturate the asymptotic Hamming bound \\cite{arXiv:quant-ph/0605094}."},{"code_id":"generalized_homological_product","detail":"Graph homology (classical) codes were inspired by homology-based quantum code constructions."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"SeyedSajjadNezhadi","date":"2021-12-14"}]},"_zoodb":{"id":"homological_classical","source_file_path":"codes/classical/bits/quantum_inspired/homological_classical.yml","source_file_modification_token":1681484685076.0317}},"newman_moore":{"code_id":"newman_moore","physical":"bits","logical":"bits","name":"Newman-Moore code","introduced":"\\cite{arXiv:cond-mat/9707273}","description":"Member of a family of \\([L^2,O(L),O(L^{\\frac{\\log 3}{\\log 2}})]\\) binary linear codes on \\(L\\times L\\) square lattices that form the ground-state subspace of a class of exactly solvable spin-glass models with three-body interactions.\nThe codewords resemble the Sierpinski triangle on a square lattice, which can be generated by a cellular automaton \\cite{doi:10.1109/12.286310}.\n","protection":"Code parameters nearly saturate the classical version of the BPT bound, based on numerical simulations and analytical arguments \\cite[Appx. A]{arxiv:0909.5200}.","features":{"decoders":["Efficient decoder \\cite{doi:10.1109/12.286310}."]},"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"classical_fractal_liquid"}],"cousins":[{"code_id":"hamiltonian","detail":"Newman-Moore codewords form the ground-state space of a class of exactly solvable spin-glass models with three-body interactions."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-12"}]},"_zoodb":{"id":"newman_moore","source_file_path":"codes/classical/bits/quantum_inspired/newman_moore.yml","source_file_modification_token":1681484685076.0898}},"reed_muller":{"code_id":"reed_muller","physical":"bits","logical":"bits","name":"Reed-Muller (RM) code","short_name":"RM","introduced":"\\cite{doi:10.1109/irepgelc.1954.6499441,doi:10.1109/tit.1954.1057465,manual:{N. Mitani, \\emph{On the transmission of numbers in a sequential computer}, delivered at the National Convention of the Inst. of Elect. Engineers of Japan, November 1951.}}","description":"Member of the RM\\((r,m)\\) family of linear binary codes derived from multivariate polynomials. The code parameters are \\([2^m,\\sum_{j=0}^{r} {m \\choose j},2^{m-r}]\\), where \\(r\\) is the \\textit{order} of the code satisfying \\(0\\leq r\\leq m\\).\nFirst-order RM codes are also called \\textit{biorthogonal} codes, while \\(m\\)th order RM codes are also called \\textit{universe} codes.\n\\textit{Punctured RM codes} RM\\(^*(r,m)\\) are obtained from RM codes by deleting one or more coordinates from each codeword.\n\nGenerator matrices of RM codes are constructed using the \\((u|u+v)\\) construction by starting from the \\(2^m\\)-dimensional matrix \\(F^{(m)}=\\left(\\begin{smallmatrix}1 & 0\\\\\n1 & 1\n\\end{smallmatrix}\\right)^{\\otimes m}\\), labeling its rows top-to-bottom from \\(0\\) to \\(2^m-1\\), converting the labels to binary strings of length \\(m\\), and deleting all rows whose labels have a Hamming weight less than \\(m-r\\). The recursive nature of the tensor product in the matrix \\(F^{(m)}\\) implies that RM\\((r,m)\\) is a subcode of RM\\((r+1,m)\\).\n\nAnother way to generate RM codewords is to list all outcomes of all polynomials of \\(m\\) binary variables of degree at most \\(r\\) \\cite{arXiv:2002.03317} (see also Ch. 13 of Ref. \\cite{preset:MacSlo}).\n","features":{"rate":"Achieves capacity of the binary erasure channel \\cite{doi:10.1109/TIT.2017.2673829}, the binary memoryless symmetric (BMS) channel under bitwise maximum-a-posteriori decoding \\cite{arxiv:2110.14631} (see also Ref. \\cite{arxiv:1411.4590}), and the binary symmetric channel (BSC), solving a long-standing conjecture \\cite{arxiv:2304.02509}.","decoders":["Reed decoder with \\(r+1\\)-step majority decoding corrects \\(\\frac{1}{2}(2^{m-r}-1)\\) errors \\cite{doi:10.1109/irepgelc.1954.6499441} (see also Ch. 13 of Ref. \\cite{preset:MacSlo}).","Sequential code-reduction decoding \\cite{doi:10.1109/TIT.1973.1055023}.","First-order (\\(r=1\\)) RM codes admit specialized decoders \\cite{manual:{E.C. Posner, \\emph{Combinatorial Structures in Planetary Reconnaissance} in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.}}."]},"realizations":["Deep-space communication \\cite{doi:10.1007/bfb0036046,manual:{E.C. Posner, \\emph{Combinatorial Structures in Planetary Reconnaissance} in Error Correcting Codes, ed. H.B. Mann, Wiley, NY 1968.}}. For example, the \\((32, 6, 16)\\) RM code was used for the Mariner 9 spacecraft."],"notes":["See Chs. 13-15 of Ref. \\cite{preset:MacSlo} for details of RM codes and their variants.","See Ref. \\cite{doi:10.1109/TIT.1972.1054732} for the weight distribution of the \\(2^{26}\\) cosets of the \\((32,6)\\) first-order RM code, obtained in part by hand computation."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"uplusv","detail":"All RM codes can be constructed via the \\((u|u+v)\\) construction \\cite[Ch. 13]{preset:MacSlo}."},{"code_id":"generalized_reed_muller","detail":"Binary GRM codes are RM codes."},{"code_id":"evaluation_polynomial","detail":"RM codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine binary space (\\cite{doi:10.1007/978-94-011-3810-9}, pgs. 44-46; \\cite{doi:10.1007/BF02249124,preset:HPAlgCodes})."},{"code_id":"divisible","detail":"An RM\\((r,m)\\) code is \\(2^{\\left\\lceil m/r\\right\\rceil-1}\\)-divisible, according to McEliece's theorem \\cite{doi:10.1016/0097-3165(71)90066-5,doi:10.1016/0012-365X(72)90032-5}."},{"code_id":"group","detail":"RM codes are group-algebra codes \\cite{doi:10.1007/BF01072842,manual:{Charpin, Pascale. Codes idéaux de certaines algèbres modulaires. Diss. 1982.}}\\cite[Ex. 16.4.11]{preset:HKSalgebra}. Consider a binary vector space of dimension \\( m \\). Under addition, this forms a finite group with \\( 2^m \\) elements known as an elementary abelian 2-group -- the direct product of \\( m \\) two-element cyclic groups \\( \\mathbb{Z}_2 \\times \\dots \\times \\mathbb{Z}_2 \\). Denote this group by \\( G_m \\). Let \\( J \\) be the Jacobson radical of the group algebra \\( \\mathbb{F}_2 G_m \\), where \\(\\mathbb{F}_2=GF(2)\\). RM\\((r,m)\\) codes correspond to the ideal \\( J^{m-r} \\). The length of the code is \\( |G_m| = 2^m \\), the distance is \\( 2^{m-r} \\), and the dimension is \\( \\sum_{i=0}^r {m \\choose i} \\). A similar construction exists for choices of a prime \\( p\\neq 2 \\)."}],"cousins":[{"code_id":"bch","detail":"RM\\(^*(r,m)\\) codes are equivalent to subcodes of BCH codes of designed distance \\(2^{m-r}-1\\) while RM\\((r,m)\\) are subcodes of extended BCH codes of the same designed distance \\cite[Ch. 13]{preset:MacSlo}."},{"code_id":"quaternary_over_z4","detail":"RM codes are images of linear quaternary codes over \\(\\mathbb{Z}_4\\) under the Gray map \\cite[Sec. 6.3]{preset:HKSrings}."},{"code_id":"dual","detail":"The codes RM\\((r,m)\\) and RM\\((m-r-1,m)\\) are dual to each other."},{"code_id":"binary_duadic","detail":"Certain punctured RM codes such as RM\\(^*(2,5)\\) are duadic; see Ref. \\cite{doi:10.1017/CBO9780511807077}, Table 6.2."},{"code_id":"binary_cyclic","detail":"Punctured RM codes are cyclic (\\cite{preset:MacSlo}, Ch. 13, Thm. 11), making RM codes extended cyclic codes. RM codes with nonzero evaluation points are cyclic (\\cite{doi:10.1007/978-94-011-3810-9}, pg. 52)."},{"code_id":"binary_ltc","detail":"RM codes can be LTCs in the low- \\cite{doi:10.1109/TIT.2005.856958,doi:10.1137/S0097539704445615} and high-error \\cite{arxiv:math/0604353} regimes."},{"code_id":"biorthogonal","detail":"The RM\\((1,m)\\) maps to a \\((2^m,2^{m+1})\\) biorthogonal spherical code under the antipodal mapping \\cite{doi:10.1109/18.720542}\\cite[Sec. 6.4]{manual:{Forney, G. D. (2003). 6.451 Principles of Digital Communication II, Spring 2003.}}\\cite[pg. 19]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-28"},{"user_id":"AnqiGong","date":"2022-07-28"},{"user_id":"VictorVAlbert","date":"2021-11-04"}]},"_zoodb":{"id":"reed_muller","source_file_path":"codes/classical/bits/reed_muller.yml","source_file_modification_token":1687727505566.5903}},"ta-shma":{"code_id":"ta-shma","physical":"bits","logical":"bits","name":"Ta-Shma zigzag code","introduced":"\\cite{doi:10.1145/3055399.3055408}","description":"Member of a family of \\(\\epsilon\\)-balanced codes that nearly achieves the asymptotic Gilbert-Varshamov bound. The codes have relative distance \\(\\frac{1}{2}-\\frac{\\epsilon}{2}\\) and rate of order \\(\\Omega (\\epsilon^{2+\\beta})\\) for \\(\\beta\\to 0\\) as \\(n\\to\\infty\\) \\cite{arxiv:2011.05500}.\n","features":{"decoders":["Unique and list decoders \\cite{arxiv:2011.05500}."]},"relations":{"parents":[{"code_id":"binary_linear"}],"cousins":[{"code_id":"balanced","detail":"Ta-Shma codes are \\(\\epsilon\\)-balanced."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-16"}]},"_zoodb":{"id":"ta-shma","source_file_path":"codes/classical/bits/ta-shma.yml","source_file_modification_token":1678631058715.6362}},"algebraic_ldpc":{"code_id":"algebraic_ldpc","physical":"bits","logical":"bits","name":"Algebraic LDPC code","description":"LDPC code whose parity check matrix is constructed explicitly (i.e., non-randomly) from a particular graph \\cite{doi:10.1007/BF02579283,doi:10.1109/TIT.2007.892774} or an algebraic structure such as a combinatorial design \\cite{doi:10.1109/ITW.2001.955146,doi:10.1109/GLOCOM.2001.965562,doi:10.1109/TCOMM.2003.816946}, balanced incomplete block design \\cite{doi:10.1109/TIT.2004.828066}, a partial geometry \\cite{doi:10.1109/ISIT.2002.1023582}, or a generalized polygon \\cite{doi:10.1109/ISIT.2001.936086,doi:10.1109/TIT.2005.856936}.\nThe extra structure and/or symmetry \\cite{manual:{Tanner, R. Michael, Deepak Sridhara, and Tom Fuja. \"A class of group-structured LDPC codes.\" Proc. ISTA. 2001.}} of these codes can often be used to gain a better understanding of their properties.\n","relations":{"parents":[{"code_id":"ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"algebraic_ldpc","source_file_path":"codes/classical/bits/tanner/algebraic/algebraic_ldpc.yml","source_file_modification_token":1683723710987.054}},"irregular_ldpc":{"code_id":"irregular_ldpc","physical":"bits","logical":"bits","name":"Irregular LDPC code","introduced":"\\cite{doi:10.1109/18.910576,doi:10.1145/258533.258573}","description":"An LDPC code whose parity-check matrix has a variable number of entries in each row or column.\n","features":{"rate":"Nearly achieve capacity against binary-input additive Gaussian white noise using iterative decoding \\cite{doi:10.1109/18.910578,doi:10.1109/4234.905935}. Such sequences have sublinearly growing distance per block length \\cite{doi:10.1109/TIT.2006.883541}."},"realizations":["Satellite communication after concatenating with a modulation scheme \\cite{doi:10.1109/TCOMM.2004.826370}."],"notes":["Useful tools for designing irregular LDPC codes can be found in Refs. \\cite{doi:10.1109/18.910580,manual:{R. Urbanke, LdpcOpt - a fast and accurate degree distribution optimizer for LDPC code ensembles (2001).}}."],"relations":{"parents":[{"code_id":"multi_edge_ldpc","detail":"Irregular LDPC codes can be formulated as multi-edge LDPC codes \\cite[Sec. XI]{manual:{Richardson, Tom, and Rüdiger Urbanke. \"Multi-edge type LDPC codes.\" Workshop honoring Prof. Bob McEliece on his 60th birthday, California Institute of Technology, Pasadena, California. 2002.}}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"irregular_ldpc","source_file_path":"codes/classical/bits/tanner/irregular/irregular_ldpc.yml","source_file_modification_token":1683723710987.1558}},"multi_edge_ldpc":{"code_id":"multi_edge_ldpc","physical":"bits","logical":"bits","name":"Multi-edge LDPC code","introduced":"\\cite{manual:{Richardson, Tom, and Rüdiger Urbanke. \"Multi-edge type LDPC codes.\" Workshop honoring Prof. Bob McEliece on his 60th birthday, California Institute of Technology, Pasadena, California. 2002.}}","description":"Irregular LDPC code whose construction generalizes those of the original examples of irregular LDPC as well as RA codes.\n","relations":{"parents":[{"code_id":"ldpc"}],"cousins":[{"code_id":"irregular_ldpc","detail":"The multi-edge code construction generalizes generalizes several of the original examples of irregular LDPC codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"multi_edge_ldpc","source_file_path":"codes/classical/bits/tanner/irregular/multi_edge_ldpc.yml","source_file_modification_token":1683723710987.2417}},"protograph_ldpc":{"code_id":"protograph_ldpc","physical":"bits","logical":"bits","name":"Protograph LDPC code","introduced":"\\cite{manual:{Thorpe, Jeremy. \"Low-density parity-check (LDPC) codes constructed from protographs.\" IPN progress report 42.154 (2003): 42-154.},doi:10.1109/GLOCOM.2005.1577834,doi:10.1109/MILCOM.2006.302313}","description":"LDPC code whose parity-check matrix is constructed using the lifting procedure (defined below) applied to the incident matrix of a sparse graph called, in this context, a \\textit{protograph}.\nIts parity check matrix can be put into the form of a block matrix consisting of either a sum of permutation sub-matrices or the zero sub-matrix.\n\n\\begin{defterm}{Lifting}\n\\label{topic:lifting}\nGiven the incidence matrix \\(A\\) of a protograph, each non-zero entry is replaced by a sum of \\(\\ell\\)-dimensional permutation matrices while each zero entry is replaced by the \\(\\ell\\)-dimensional zero matrix.\nThe resulting matrix is called a \\textit{lift} of \\(A\\).\nThe permutation matrices can be chosen randomly or deterministically, with a deterministic lift also called a \\textit{permutation voltage assignment} in the theory of theory of voltage graphs \\cite{doi:10.1109/ISIT.2008.4595095,doi:10.1017/CBO9781139087223}.\n\\end{defterm}\n\nFor example, the lift of a two-dimensional incidence matrix using two-dimensional permutation matrices associated with the group \\(\\mathbb{Z}_2\\) is as follows:\n\\begin{align}\n  \\begin{pmatrix}1 & 1\\\\\n  0 & 1\n  \\end{pmatrix}\\to\\begin{pmatrix}\\begin{smallmatrix}0 & 1\\\\\n  1 & 0\n  \\end{smallmatrix} & \\begin{smallmatrix}0 & 1\\\\\n  1 & 0\n  \\end{smallmatrix}\\\\\n  \\begin{smallmatrix}0 & 0\\\\\n  0 & 0\n  \\end{smallmatrix} & \\begin{smallmatrix}1 & 0\\\\\n  0 & 1\n  \\end{smallmatrix}\n  \\end{pmatrix}~.\n\\end{align}\nHere, the two non-zero entries in the top row are replaced by the exchange permutation while the bottom non-zero entry is replaced by the trivial permutation.\n","protection":"The minimum distance of protograph codes is bounded by a function of the number of commuting permutation-matrix blocks \\cite{doi:10.1007/978-1-4613-0165-3_6}.\n","notes":["For reviews on protograph LDPC codes, see Ref. \\cite{doi:10.1109/COMST.2015.2436705}."],"relations":{"parents":[{"code_id":"multi_edge_ldpc","detail":"LDPC codes based on protographs can be formulated as multi-edge LDPC codes \\cite{doi:10.1109/ITW.2011.6089477}."},{"code_id":"q-ary_protograph_ldpc"}],"cousins":[{"code_id":"algebraic_ldpc","detail":"Some deterministic protograph LDPC codes \\cite{doi:10.1109/ALLERTON.2008.4797704} can be obtained from the theory of voltage graphs \\cite{doi:10.1109/ISIT.2008.4595095,doi:10.1017/CBO9781139087223}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"protograph_ldpc","source_file_path":"codes/classical/bits/tanner/irregular/protograph_ldpc.yml","source_file_modification_token":1683723710987.2942}},"ara":{"code_id":"ara","physical":"bits","logical":"bits","name":"Accumulate-repeat-accumulate (ARA) code","short_name":"ARA","introduced":"\\cite{doi:10.1109/TCOMM.2007.894109}","description":"A generalization of the RA code in which the outer repetition-code encoding step is augmented with an acumulator acting on a fraction of the incoming bits.\nIn addition, the code may be punctured after the final acumulating step.\n","relations":{"parents":[{"code_id":"irregular_ldpc"},{"code_id":"protograph_ldpc","detail":"ARA codes can be formulated as protograph LDPC codes \\cite{doi:10.1109/GLOCOM.2005.1577834}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"ara","source_file_path":"codes/classical/bits/tanner/irregular/ra/ara.yml","source_file_modification_token":1683723710987.3948}},"extended_ira":{"code_id":"extended_ira","physical":"bits","logical":"bits","name":"Extended IRA (eIRA) code","short_name":"eIRA","introduced":"\\cite{manual:{M. Yang, Y. Li, andW.E. Ryan, Design of efficiently-encodable moderate-length high-rate irregular LDPC codes, Proc. 40th Annual Allerton Conference on Communication, Control, and Computing, Champaign, IL., pp. 1415–1424, October 2002.},doi:10.1109/ISIT.2003.1228251,doi:10.1109/TCOMM.2004.826367}","description":"A generalization of the IRA code in which the outer LDGM code is replaced by a random sparse matrix containing no weight-two columns.\n","relations":{"parents":[{"code_id":"irregular_ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"extended_ira","source_file_path":"codes/classical/bits/tanner/irregular/ra/extended_ira.yml","source_file_modification_token":1683723710987.4521}},"ira":{"code_id":"ira","physical":"bits","logical":"bits","name":"Irregular repeat-accumulate (IRA) code","short_name":"IRA","introduced":"\\cite{manual:{Hui Jin, Aamod Khandekar, and Robert McEliece. \"Irregular repeat-accumulate codes.\" Proc. 2nd Int. Symp. Turbo codes and related topics. 2000.},doi:10.7907/Q06G-MW38,manual:{Hui Jin, Aamod Khandekar, and Robert J. McEliece. \"Serial concatenation of interleaved convolutional codes forming turbo-like codes.\" United States Patent Number 7116710B1 (2023).}}","description":"A generalization of the RA code in which the outer 1-in-3 repetition encoding step is replaced by an LDGM code.\nA simple version is when different bits in the RA block are repeated a different number of times.\n\nIRA codes can be optimized against various noise channels \\cite{doi:10.1109/TIT.2004.831778}.\n","features":{"rate":"IRA codes nearly achieve the Shannon capacity of the binary erasure channel using iterative decoding \\cite{manual:{Jin, Hui, Aamod Khandekar, and Robert McEliece. \"Irregular repeat-accumulate codes.\" Proc. 2nd Int. Symp. Turbo codes and related topics. 2000.}}. Puncturing ressens the decoding complexity while still allowing sequences of codes to achive capacity \\cite{doi:10.1109/TIT.2005.850079}.","encoders":["One linear-time encoder for a \\textit{systematic} IRA code consists of first encoding into an \\([n,k]\\) LDGM binary linear code, applying a random permutation, and then applying an acumulator to obtain \\begin{align} (u_{1},u_{1}+u_{2},\\cdots,u_{1}+\\cdots+u_{3K})~. \\end{align}"],"decoders":["Linear-time decoder \\cite{manual:{Jin, Hui, Aamod Khandekar, and Robert McEliece. \"Irregular repeat-accumulate codes.\" Proc. 2nd Int. Symp. Turbo codes and related topics. 2000.}}."]},"realizations":["LDPC codes are used for digital satellite video broadcasting per the DVB-S2 standard \\cite{doi:10.1109/ICARES.2014.7024407,manual:{ETSI, ETSI. \"Digital video broadcasting (dvb); second generation framing structure, channel coding and modulation systems for broadcasting, interactive services, news gathering and other broadband satellite applications.\" Part II: S2-Extensions (DVB-S2X) (2005): 22-27.}} utilize IRA code features and are subject to ongoing litigation; see Ref. \\cite{manual:{Hui Jin, Aamod Khandekar, and Robert J. McEliece. \"Serial concatenation of interleaved convolutional codes forming turbo-like codes.\" United States Patent Number 7116710B1 (2023).}}.","Apple and Broadcom Wi-Fi devices utilize IRA encoding and decoding code features and are subject to ongoing litigation; see Ref. \\cite{manual:{Hui Jin, Aamod Khandekar, and Robert J. McEliece. \"Serial concatenation of interleaved convolutional codes forming turbo-like codes.\" United States Patent Number 7116710B1 (2023).}}."],"relations":{"parents":[{"code_id":"extended_ira"},{"code_id":"protograph_ldpc","detail":"IRA codes can be formulated as protograph LDPC codes \\cite{doi:10.1109/GLOCOM.2005.1577834}."},{"code_id":"concatenated","detail":"IRA codes can be interpreted as serial concatenated codes \\cite{doi:10.1109/18.669119}."}],"cousins":[{"code_id":"ldgm","detail":"IRA codes replace the outer 1-in-3 repetition encoding step in RA codes with an LDGM code."},{"code_id":"mn_ldpc","detail":"MN-LDPC and IRA codes intersect for certain parameters \\cite{manual:{Henry D. Pfister, private communication, 2022}}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"ira","source_file_path":"codes/classical/bits/tanner/irregular/ra/ira.yml","source_file_modification_token":1683723710987.5266}},"ra":{"code_id":"ra","physical":"bits","logical":"bits","name":"Repeat-accumulate (RA) code","short_name":"RA","introduced":"\\cite{manual:{Divsalar, Dariush, Hui Jin, and Robert J. McEliece. \"Coding theorems for\" turbo-like\" codes.\" Proceedings of the annual Allerton Conference on Communication control and Computing. Vol. 36. University Of Illinois, 1998.}}","description":"An LDPC code whose parity-check matrix has weight-two columns arranged in a step-like pattern for its last columns \\cite{manual:{Johnson, Sarah J. \"Introducing low-density parity-check codes.\" University of Newcastle, Australia 1 (2006): 2006.}}.\n","protection":"Minimum-distance upper bounds \\cite{doi:10.1109/TIT.2007.892805,manual:{Tanner, R. Michael. \"On quasi-cyclic repeat-accumulate codes.\" Proc. 37th Allerton Conf., Monticello, IL, Sept. 1999. 1999.}}.\n","features":{"rate":"RA codes are not asymptotically good \\cite{doi:10.1109/TIT.2008.2008114}.","encoders":["An encoder for an RA code acting on a string \\((c_1c_2\\cdots c_K)\\) of logical bits begins by repeating each bit three times to obtain the length-\\(3K\\) bitstring \\((c_1 c_1 c_1 c_2 c_2 c_2 \\cdots c_K c_K c_K)\\), permuting using a random permutation to obtain a bitstring \\(u\\), and applying the mod-two accumulated sum (or \\textit{accumulator}) to obtain \\cite[Ch. 49]{preset:MacKay} \\begin{align} (u_{1},u_{1}+u_{2},\\cdots,u_{1}+\\cdots+u_{3K})~. \\end{align} The first repeating step is effectively using a 1-in-3 repetition code, which can be thought of as the outer code in this concatenated construction."]},"relations":{"parents":[{"code_id":"ira","detail":"IRA codes for which the outer code is a 1-in-3 repetition code reduce to RA codes."},{"code_id":"ara","detail":"ARA codes with no pre-encoding acumulator and no post-acumulator puncturing reduce to RA codes."},{"code_id":"raa","detail":"RAA codes with no second permutation and acumulator reduce to RA codes."}],"cousins":[{"code_id":"qc_ldpc","detail":"There exist quasi-cyclic versions of RA codes \\cite{manual:{M. R. Tanner, \"On quasi-cyclic repeat-accumulate codes.\" PROCEEDINGS OF THE ANNUAL ALLERTON CONFERENCE ON COMMUNICATION CONTROL AND COMPUTING. Vol. 37. The University; 1998, 1999.}}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"ra","source_file_path":"codes/classical/bits/tanner/irregular/ra/ra.yml","source_file_modification_token":1683723710987.6057}},"raa":{"code_id":"raa","physical":"bits","logical":"bits","name":"Repeat-accumulate-accumulate (RAA) code","short_name":"RAA","introduced":"\\cite{doi:10.1109/TIT.2008.2008114}","description":"Generalization of the RA code in which two accumulators and permutations are used.\n","features":{"rate":"Some sequences of non-deterministic RAA codes are asymptotically good \\cite{doi:10.1109/TIT.2008.2008114,doi:10.1109/ISIT.2008.4595333}.","encoders":["An encoder for an RAA code is the same as that for the RA code, followed by a second round of permutation and acumulation."]},"relations":{"parents":[{"code_id":"protograph_ldpc","detail":"RAA codes can be formulated as protograph LDPC codes \\cite{doi:10.1109/ICC.2005.1494433}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"raa","source_file_path":"codes/classical/bits/tanner/irregular/ra/raa.yml","source_file_modification_token":1683723710987.669}},"ldgm":{"code_id":"ldgm","physical":"bits","logical":"bits","name":"Low-density generator-matrix (LDGM) code","short_name":"LDGM","description":"Binary linear code with a sparse generator matrix.\nAlternatively, a member of an infinite family of \\([n,k,d]\\) codes for which the number of nonzero entries in each row and column of the generator matrix are both bounded by a constant as \\(n\\to\\infty\\). The dual of an LDGM code has a sparse parity-check matrix and is called an LDPC code.\n","features":{"rate":"Certain LDGM codes come close to achieving Shannon capacity \\cite{doi:10.1109/LCOMM.2003.813816}."},"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"q-ary_ldgm"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-15"}]},"_zoodb":{"id":"ldgm","source_file_path":"codes/classical/bits/tanner/ldgm.yml","source_file_modification_token":1683723710987.7336}},"ldpc":{"code_id":"ldpc","physical":"bits","logical":"bits","name":"Low-density parity-check (LDPC) code","short_name":"LDPC","introduced":"\\cite{doi:10.1109/TIT.1962.1057683,manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.}}","description":"A binary linear code with a sparse parity-check matrix.\nAlternatively, a member of an infinite family of \\([n,k,d]\\) codes for which the number of nonzero entries in each row and column of the parity-check matrix are both bounded above by a constant as \\(n\\to\\infty\\).\n\nAn LDPC code is \\((j,k)\\)-\\textit{regular} if the parity-check matrix has a fixed number of \\(j\\) nonzero entries in each row and \\(k\\) entries in each column; otherwise, the LDPC code is \\textit{irregular}.\nIrregular LDPC codes are characterized by the fractions \\(v_j\\) of columns of weight \\(j\\) as well as likewise fractions \\(h_j\\) for rows of weight \\(j\\); these are collectively called the \\textit{degree distribution}.\n\nA \\textit{parity check} is performed by taking the inner product of a row of the parity-check matrix with a codeword that has been affected by a noise channel.\nA parity check yields either zero (no error) or one (error).\n\nIn alternative conventions (not used here), LDPC codes are referred to as \\textit{simple LDPC} codes, as opposed to generalized LDPC codes, alternatively named as Tanner codes.\n","features":{"rate":"Some LDPC codes achieve the Shannon capacity of the binary symmetric channel under maximum-likelihood decoding \\cite{doi:10.1109/18.748992,doi:10.1109/TIT.1962.1057683,arXiv:cs/0610022}. Other LDPC codes achieve capacity for smaller block lengths under belief-propagation decoding \\cite{arxiv:1201.2999}. Random LDPC codes achieve list-decoding capacity \\cite{arXiv:1909.06430}.","encoders":["Almost linear-time encoder based on transforming the parity-check matrix into upper triangular form \\cite{doi:10.1109/18.910579}."],"decoders":["Message-passing algorithm called belief propagation (BP) \\cite{manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.},doi:10.1109/18.910577,preset:LinCostello,doi:10.1109/ISCAS.2006.1693779}.","Soft-decision Sum-Product Algorithm (SPA) \\cite{manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.},doi:10.1109/18.910572,doi:10.1109/18.910577} and its simplification the Min-Sum Algorithm (MSA) \\cite{doi:10.1109/TCOMM.2005.852852}.","Linear programming \\cite{manual:{J. Feldman. Decoding Error-Correcting Codes via Linear Programming. PhD thesis, Massachusetts Institute of Technology, 2003.},doi:10.1109/TIT.2004.842696,doi:10.1007/978-1-4939-2864-4_216}.","Iterative LDPC decoders can get stuck at \\textit{stopping sets} of their Tanner graphs \\cite{doi:10.1109/TIT.2002.1003839}, with decoder performance improving with the size of the smallest stopping set; see \\cite[Sec. 21.3.1]{preset:HKSgraphs} for more details. The smallest stopping set size can reach the minimum distance of the code \\cite{doi:10.1109/TIT.2005.864441}.","Ensembles of random LDPC codes under iterative decoders are subject to the \\textit{concentration theorem} \\cite{doi:10.1109/18.910577,doi:10.1109/18.910578}; see \\cite[Thm. 21.7.1]{preset:HKSgraphs} for the case of the BEC.","Reinforcement learning \\cite{arxiv:2112.13934}."]},"notes":["The potential of LDPC codes was noted by Margulis \\cite{doi:10.1007/BF02579283}, but realized by the broader community \\cite{doi:10.1049/el:19970362,doi:10.1109/18.748992} much later after their discovery by Gallager \\cite{doi:10.1109/TIT.1962.1057683,manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.}}.","See book \\cite{doi:10.1093/acprof:oso/9780198570837.001.0001} and reviews \\cite{doi:10.1088/0305-4470/37/6/R01,doi:10.1016/S0924-8099(07)80009-6} for an introduction to LDPC codes, belief-propagation decoding, and connections to statistical mechanics. Other introductory references include Refs. \\cite{doi:10.1109/MCOM.2003.1222728,manual:{Johnson, Sarah J. \"Introducing low-density parity-check codes.\" University of Newcastle, Australia 1 (2006): 2006.},preset:MacKay,doi:10.1201/9780203490310} as well as a review of LDPC codes circa 2005 \\cite{doi:10.1007/978-3-0348-7865-4_5}.","See Kaiserslautern database \\cite{preset:KLdatabase} for explicit representatives of several classes of LDPC codes, including \\(q\\)-ary, WiMAX, multi-edge, and spatially-coupled.","See pretty-good-codes database \\cite{preset:PGCdatabase} for explicit representatives and benchmarking.","LDPC codes have been considered for quantum key distribution \\cite{arxiv:2212.01121}.","Codes have been benchmarked using AFF3CT toolbox \\cite{doi:10.1016/j.softx.2019.100345}."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"q-ary_ldpc"}],"cousins":[{"code_id":"tensor","detail":"Tensor products of random LDPC codes are robustly testable \\cite{doi:10.1007/11830924_29,doi:10.1007/978-3-540-85363-3_24}."},{"code_id":"ldgm","detail":"The dual of an LDPC code has a sparse generator matrix and is called an LDGM code."},{"code_id":"random","detail":"LDPC codes are often constructed non-determinisitically."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-17"},{"user_id":"VictorVAlbert","date":"2022-04-25"},{"user_id":"ArminGerami","date":"2022-04-23"}]},"_zoodb":{"id":"ldpc","source_file_path":"codes/classical/bits/tanner/ldpc.yml","source_file_modification_token":1683723710987.8157}},"array_ldpc":{"code_id":"array_ldpc","physical":"bits","logical":"bits","name":"Array-based LDPC (AB-LDPC) code","short_name":"AB-LDPC","introduced":"\\cite{manual:{Fan, John L. \"Array codes as low-density parity-check codes.\" Proc. 2nd Int. Symp. on Turbo Codes & Related Topics, Brest, France, Sept. 2000.},doi:10.1007/978-1-4615-1525-8_7}","description":"QC-LDPC code constructed deterministically from a disk array code known as a B-code.\nIts parity-check matrix admits a compact representation \\cite{doi:10.1109/ISIT.2002.1023554} and is related to RS codes.\n","realizations":["Certain AB-LDPC codes have been proposed to be used for DSL transmission \\cite{doi:10.1109/ICC.2002.997149}."],"relations":{"parents":[{"code_id":"qc_ldpc"},{"code_id":"algebraic_ldpc"}],"cousins":[{"code_id":"b_array","detail":"AB-LDPC codes are constructed from certain classes of B-codes. B-codes can be viewed as binary codes by mapping their ring elements to permutation matrices (cf. \\hyperref[topic:lifting]{lifting}). The resulting codes turn out to be LDPC \\cite{doi:10.1007/978-1-4615-1525-8_7}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"array_ldpc","source_file_path":"codes/classical/bits/tanner/qc/array_ldpc.yml","source_file_modification_token":1683723710987.9124}},"b_ldpc":{"code_id":"b_ldpc","physical":"bits","logical":"bits","name":"Block LDPC (B-LDPC) code","short_name":"B-LDPC","introduced":"\\cite{doi:10.1109/TIT.2005.851753}","description":"Member of a particular class of irregular QC-LDPC codes with efficient encoders.\n","features":{"encoders":["Efficient encoder \\cite{doi:10.1109/TIT.2005.851753}."]},"relations":{"parents":[{"code_id":"qc_ldpc"},{"code_id":"irregular_ldpc"},{"code_id":"algebraic_ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"b_ldpc","source_file_path":"codes/classical/bits/tanner/qc/b_ldpc.yml","source_file_modification_token":1683723710987.993}},"difference_set":{"code_id":"difference_set","physical":"bits","logical":"bits","name":"Difference-set cyclic (DSC) code","short_name":"DSC","introduced":"\\cite{doi:10.1002/j.1538-7305.1966.tb01686.x}","description":"Cyclic LDPC code constructed deterministically from a difference set.\nCertain DCS codes satisfy more redundant constraints than Gallager codes and thus can outperform them \\cite{doi:10.1007/978-1-4613-0165-3_6}.\n","notes":["See book \\cite{doi:10.1142/9283} for a general theory of linear codes made from difference sets."],"relations":{"parents":[{"code_id":"qc_ldpc"},{"code_id":"algebraic_ldpc"},{"code_id":"cyclic"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"difference_set","source_file_path":"codes/classical/bits/tanner/qc/difference_set.yml","source_file_modification_token":1683723710988.0532}},"qc_ldpc":{"code_id":"qc_ldpc","physical":"bits","logical":"bits","name":"Quasi-cyclic LDPC (QC-LDPC) code","short_name":"QC-LDPC","introduced":"\\cite[Appx. C]{manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.}}\\cite{manual:{H. Jin, T. Richardson, V. Novichkov, \"Error Correction of Algebraic Block Codes\". U.S. Patent, Number US8751902B2 2002},doi:10.1109/ISIEA.2009.5356472,manual:{Tanner, R. Michael, Deepak Sridhara, and Tom Fuja. \"A class of group-structured LDPC codes.\" Proc. ISTA. 2001.},doi:10.1109/ISIT.2002.1023584,doi:10.1109/LCOMM.2003.814716,doi:10.1109/ISIT.2003.1228165,doi:10.1109/TIT.2004.831841}","description":"LDPC code that can be put into quasi-cyclic form.\nIts parity check matrix can be put into the form of a block matrix consisting of either circulant permutation sub-matrices or the zero sub-matrix.\nSuch codes are often constructed by \\hyperref[topic:lifting]{lifting} certain protographs into such block matrices \\cite{arXiv:1108.0840}.\nTheir simple structure makes them useful for several wireless communication standards.\n","protection":"Minimum-distance upper bounds exist \\cite{doi:10.1007/978-1-4613-0165-3_6,doi:10.1109/TIT.2011.2173244}.\n","realizations":["5G NR cellular communication for the traffic channel \\cite{doi:10.1109/MCOM.2018.1700839,doi:10.1109/CSCITA47329.2020.9137797}.","Wireless communication: WiMAX (IEEE 802.16e) \\cite{manual:{LDPC coding for OFDMA PHY. 802.16REVe Sponsor Ballot Recirculation comment, July 2004. IEEE C802.16e04/141r2},doi:10.1109/PIMRC.2006.254126,doi:10.1049/el:20081927}, WiFi 4 (IEEE 802.11n) \\cite{doi:10.1109/ICCT.2013.6820375}, and WPAN (IEEE 802.15.3c) \\cite{doi:10.1109/ASICON.2015.7517004}."],"relations":{"parents":[{"code_id":"protograph_ldpc"},{"code_id":"quasi_cyclic"}],"cousins":[{"code_id":"ld_convolutional","detail":"QC-LDPC codes can be \\textit{unwrapped} to obtain LDPC-CCs by expressing each circulant matrix block as a power of some generating circulant matrix and replacing that generating matrix by the shift operator of the convolutional code \\cite{doi:10.1109/TIT.2004.838370}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"qc_ldpc","source_file_path":"codes/classical/bits/tanner/qc/qc_ldpc.yml","source_file_modification_token":1683723710988.128}},"tsf":{"code_id":"tsf","physical":"bits","logical":"bits","name":"Tanner-Sridhara-Fuja (TSF) code","short_name":"TSF","introduced":"\\cite{manual:{Tanner, R. Michael, Deepak Sridhara, and Tom Fuja. \"A class of group-structured LDPC codes.\" Proc. ISTA. 2001.}}","description":"Array QC-LDPC code constructed from a cyclically shifted identity matrix; see \\cite[Exam. 21.6.5]{preset:HKSgraphs}.\n","relations":{"parents":[{"code_id":"array_ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"tsf","source_file_path":"codes/classical/bits/tanner/qc/tsf.yml","source_file_modification_token":1683723710988.1865}},"generalized_gallager":{"code_id":"generalized_gallager","physical":"bits","logical":"bits","name":"Generalized Gallager code","introduced":"\\cite{doi:10.1109/ICC.1999.767979}","description":"A LDPC code that generalizes the Gallager codes using the Tanner construction.\nWhile Gallager code parity-check matrices consists of repetition code submatrices that are randomly permuted, generalized Gallager code matrices substitute general binary linear codes.\n","relations":{"parents":[{"code_id":"regular_binary_tanner"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"generalized_gallager","source_file_path":"codes/classical/bits/tanner/regular_tanner/generalized_gallager.yml","source_file_modification_token":1683723710988.3057}},"regular_binary_tanner":{"code_id":"regular_binary_tanner","physical":"bits","logical":"bits","name":"Regular binary Tanner code","introduced":"\\cite{doi:10.1109/TIT.1981.1056404}","alternative_names":["Regular binary GLDPC code"],"description":"A binary Tanner code defined on a regular bipartite graph, with the inner code being the same for all vertices.\n\nAn alternative definition maps the variable nodes of the generalized Tanner graph to edges of a regular graph \\(G\\) and the constraint nodes to vertices of \\(G\\).\nBits are placed on edges of \\(G\\) such that each subsequence of bits corresponding to edges in the neighborhood any vertex belong to some \\textit{short} binary linear code \\(C_0\\).\n\nMore technically, let \\(G(V,E)\\) be a \\(\\Delta\\)-regular (not necessarily bipartite) graph with number of vertices \\(|V| = n \\) and number of edges \\(|E| = N = n\\Delta/2\\). Let \\(C_0\\) be a linear binary code of length \\(\\Delta\\) and rate \\(R_0\\). The Tanner code \\(T(G,C_0)\\), whose bits are placed on edges of the graph, consists of the following codewords:\n\\begin{align}\n\\left\\{ c \\in GF(2)^{n}\\,\\text{s.t. }\\forall v\\in V,\\left.c\\right|_{N(v)}\\in C_{0}\\right\\} ~,\n\\end{align}\nwhere \\(\\left.c\\right|_{N(v)}\\) is the subsequence formed by the \\(\\Delta\\) bits located on the neighbors \\(N(v)\\) of the vertex \\(v\\). The dimension of \\(T\\) is at least \\(N -n(\\Delta -\\Delta R_0) = N(2R_0-1)\\geq 0\\) whenever \\(R_0 \\geq \\frac{1}{2}\\).\n","protection":"Minimum-distance bounds in terms of graph and short-code parameters include the bit-oriented or parity-oriented bounds \\cite{doi:10.1109/18.910591} along with others \\cite{doi:10.1109/18.910591,doi:10.1504/IJICoT.2010.032546,arXiv:0708.2462}.\n","features":{"rate":"For a short code \\(C_0\\) with rate \\(R_0\\), the Tanner code has rate \\(R \\geq 2R_0-1\\). If \\(C_0\\) satisfies the Gilbert-Varshamov bound, the rate \\(R \\geq \\delta = 1-2h(\\delta_0)\\), where \\(\\delta\\) (\\(\\delta_0\\)) is the relative distance of the Tanner code (\\(C_0\\)), and \\(h\\) is the binary entropy function.","encoders":["Quadratic algorithm: This technique works for all linear block codes and encodes using matrix multiplication \\cite{doi:10.1145/258533.258575}.","Using the nonabelian Fast Fourier Transform and exploiting the symmetry of the underlying graph, an encoding algorithm that requires \\(O(n^{4/3})\\) has been devised in \\cite{doi:10.1145/258533.258575}.","A modified construction yields codes that may be encoded in linear time yet maintain similar performance \\cite{doi:10.1109/18.556668}."],"decoders":["Parallel decoding algorithm corrects a fraction \\(\\delta_0^2/48\\) of errors for Tanner codes \\cite{doi:10.1109/18.556667}. A modification of said algorithm improves the fraction to \\(\\delta_0^2/4\\) with no extra cost to complexity \\cite{doi:10.1109/18.910593}."]},"realizations":["First hardware implementation was done using a semi-systolic decoding architecture \\cite{doi:10.1016/0166-218X(91)90111-9}."],"relations":{"parents":[{"code_id":"binary_linear"},{"code_id":"tanner","detail":"Regular binary Tanner codes are binary Tanner codes defined on regular sparse bipartite graphs, with the inner code being the same for all vertices."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"},{"user_id":"XiaozhenFu","date":"2022-03-30"},{"user_id":"VictorVAlbert","date":"2021-11-29"}]},"_zoodb":{"id":"regular_binary_tanner","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_binary_tanner.yml","source_file_modification_token":1683723710988.3718}},"expander":{"code_id":"expander","physical":"bits","logical":"bits","name":"Expander code","introduced":"\\cite{doi:10.1109/18.556667}","description":"LDPC code whose parity-check matrix is derived from the adjacency matrix of bipartite expander graph \\cite{doi:10.1090/S0273-0979-06-01126-8} such as a Ramanujan graph or a Cayley graph of a projective special linear group over a finite field \\cite{doi:10.1007/BF02126799,doi:10.1017/CBO9780511615825}.\nExpander codes admit efficient encoding and decoding algorithms and yield an explicit (i.e., non-random) asymptotically good LDPC code family.\n\nThe rate and distance of the expander code depend on specific parameters of the corresponding graph.\nA (\\(n, m, D, \\gamma, \\alpha\\)) bipartite expander graph is defined as a \\(D\\)-left-regular graph with \\(n\\) left nodes, and \\(m\\) right nodes such that for any subset of left nodes \\(S\\) of size at most \\(\\gamma n\\) the neighborhood \\(N(S)\\) is at least of size \\(\\alpha|S|\\). Given a (\\(n, m, D, \\gamma, (1-\\epsilon)D\\)) expander graph, the corresponding expander code has rate of \\(1 - m/n\\) and a distance of at least \\(2(1-\\epsilon)\\gamma n\\) for any \\(\\epsilon < 1/2\\).\nExplicit constructions for expander graphs \\cite{doi:10.1090/S0273-0979-06-01126-8} with any ratio \\(n/m\\) are known where \\(D = \\text{polylog}(n/m)\\), \\(\\gamma = \\Omega(1/D)\\) and arbitrary \\(\\epsilon\\) \\cite{doi:10.1145/509907.510003}.\n","protection":"There exist minimum distance bounds in terms of features of the expander graph \\cite{doi:10.1109/18.556667,arxiv:cs/0406048}.\n","features":{"rate":"The rate is \\(1 - m/n\\) where \\(n\\) is the number of left nodes and \\(m\\) is the number of right nodes in the bipartite expander graph.","encoders":["Multiplication by generator matrix with runtime \\(O(n^2)\\)"],"decoders":["Decoding can be done in \\(O(n)\\) runtime using a greedy \\textit{flip decoder} \\cite{doi:10.1109/18.556667}. The algorithm consists of flipping a bit of the received word if it will result in a greater number of satisfied parity checks. This is repeated until a codeword is reached."],"fault_tolerance":["The flip decoding algorithm is fault tolerant against parity check errors \\cite{doi:10.1109/18.556668}; see also \\href{http://courses.csail.mit.edu/6.440/spring08/index.html}{course notes} by M. Sudan."]},"relations":{"parents":[{"code_id":"regular_ldpc","detail":"Expander codes yield an explicit (i.e., non-random) asymptotically good LDPC code family."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-12"},{"user_id":"JonNelson","date":"2021-12-15"}]},"_zoodb":{"id":"expander","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/expander.yml","source_file_modification_token":1683723710988.4712}},"gallager":{"code_id":"gallager","physical":"bits","logical":"bits","name":"Gallager (GL) code","short_name":"GL","introduced":"\\cite{doi:10.1109/TIT.1962.1057683,manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.}}","description":"The first LDPC code construction.\nThe rows of the parity check matrix of this regular code are divided into equal subsets, and columns in the first subset are randomly permuted to yield the corresponding rows in subsequent subsets.\nFor example, the parity-check matrix\n\\begin{align}\n\\begin{pmatrix}\n1 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 1\\\\\n1 & 0 & 1 & 0\\\\\n0 & 1 & 0 & 1\n\\end{pmatrix}\n\\end{align}\ncontains two subsets, each consisting of two rows, and the last two rows are obtained from the first two by exchanging the second and third columns.\n","protection":"With high probability, random GL codes have constant distance \\cite{manual:{R. Gallagher, \\emph{Low-density parity check codes}. 1963. PhD thesis, MIT Cambridge, MA.}}. There exist GL codes that are able to correct errors of weight less than \\(c n\\) for some constant \\(c\\) in order \\(O(n\\log n)\\) decoding operations \\cite{manual:{V. V. Zyablov, M. S. Pinsker, “Estimation of the error-correction complexity for Gallager low-density codes”, Probl. Peredachi Inf., 11:1 (1975), 23–36; Problems Inform. Transmission, 11:1 (1975), 18–28}}.","features":{"rate":"GL codes nearly achieve Shannon capacity against binary-input additive Gaussian white noise using iterative decoding \\cite{doi:10.1049/el:19970362,doi:10.1109/18.748992}. GL codes can outperform RS codes at short block length \\cite{doi:10.1007/978-1-4613-0165-3_6}."},"relations":{"parents":[{"code_id":"regular_ldpc","detail":"GL codes are the first LDPC codes."},{"code_id":"generalized_gallager"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"gallager","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/gallager.yml","source_file_modification_token":1683723710988.538}},"ha_ldpc":{"code_id":"ha_ldpc","physical":"bits","logical":"bits","name":"Hsu-Anastasopoulos LDPC (HA-LDPC) code","short_name":"HA-LDPC","introduced":"\\cite{arXiv:cs/0509062}","description":"A regular LDPC code obtained from a concatenation of a certain random regular LDPC code and a certain random LDGM code.\n","features":{"rate":"Codes can achieve capacity on the BEC channel under BP decoding \\cite{arXiv:cs/0509062} as well as the capacity of memoryless binary-input symmetric-output channels under MAP decoding \\cite{arXiv:1102.4612}. HA-LDPC codes can achieve the GV bound with asymptotically high probability \\cite{arXiv:cs/0509062}."},"relations":{"parents":[{"code_id":"regular_ldpc"},{"code_id":"multi_edge_ldpc","detail":"HA-LDPC codes can be formulated as multi-edge LDPC codes \\cite{arxiv:1102.4612}."}],"cousins":[{"code_id":"ldgm","detail":"HA-LDPC codes are a concatenation of an LDPC and an LDGM code."},{"code_id":"concatenated","detail":"HA-LDPC codes are a concatenation of an LDPC and an LDGM code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"ha_ldpc","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/ha_ldpc.yml","source_file_modification_token":1683723710988.6172}},"lu_ldpc":{"code_id":"lu_ldpc","physical":"bits","logical":"bits","name":"Lazebnik-Ustimenko (LU) code","short_name":"LU","introduced":"\\cite{doi:10.1016/0166-218X(94)00058-L,doi:10.1109/TIT.2004.834760}","description":"LDPC code whose Tanner graph comes from a particular family of \\(q\\)-regular graphs \\cite{doi:10.1016/0166-218X(94)00058-L} of known girth and relatively large stopping sets.\n","relations":{"parents":[{"code_id":"regular_ldpc"},{"code_id":"algebraic_ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"lu_ldpc","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/lu_ldpc.yml","source_file_modification_token":1683723710988.6763}},"margulis_ldpc":{"code_id":"margulis_ldpc","physical":"bits","logical":"bits","name":"Margulis LDPC code","introduced":"\\cite{doi:10.1007/BF02579283}","description":"Member of a class of LDPC codes deterministically constructed using a class of regular graphs with no short cycles.\nRelated explicit LDPC constructions \\cite{doi:10.1109/ISIT.2001.935867} utilize Ramanujan graphs \\cite{doi:10.1007/BF02126799,doi:10.1017/CBO9780511615825}.\n","features":{"encoders":["Efficient encoder improving over the original Gallager encoder \\cite{doi:10.1007/BF02579283}."]},"relations":{"parents":[{"code_id":"regular_ldpc"},{"code_id":"algebraic_ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"margulis_ldpc","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/margulis_ldpc.yml","source_file_modification_token":1683723710988.7253}},"mn_ldpc":{"code_id":"mn_ldpc","physical":"bits","logical":"bits","name":"MacKay-Neal LDPC (MN-LDPC) code","short_name":"MN-LDPC","introduced":"\\cite{doi:10.1007/3-540-60693-9_13,doi:10.1109/18.748992}","description":"Codes whose parity-check matrix is constructed non-deterministically via the MacKay-Neal prescription.\nThe parity-check matrix of an \\((l,r,g\\))-MN-LDPC code is of the form \\((H_1~H_2)\\), where \\(H_1\\) is a random binary matrix of column weight \\(l\\) and row weight \\(r\\), and \\(H_2\\) is a random binary matrix of column and row weight \\(g\\) \\cite{arxiv:1102.4612}.\n","features":{"rate":"Certain sequences of optimally decoded codes can nearly achieve the Shannon capacity \\cite{doi:10.1007/3-540-60693-9_13,doi:10.1109/18.748992}. A sequence of codes achieves the capacity of memoryless binary-input symmetric-output channels under MAP decoding \\cite{arXiv:1102.4612}.","decoders":["Free-energy minimization and a BP decoder \\cite{doi:10.1007/3-540-60693-9_13}."]},"relations":{"parents":[{"code_id":"regular_ldpc","detail":"MN-LDPC codes re-invigorated the study of LDPC codes about 30 years after their discovery."},{"code_id":"multi_edge_ldpc","detail":"MN-LDPC codes can be formulated as multi-edge LDPC codes \\cite{arxiv:1102.4612}."}],"cousins":[{"code_id":"ldgm","detail":"\\((l,r,1\\))-MN-LDPC codes are LDGM \\cite{arxiv:1102.4612}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"mn_ldpc","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/mn_ldpc.yml","source_file_modification_token":1683723710988.7778}},"pg_ldpc":{"code_id":"pg_ldpc","physical":"bits","logical":"bits","name":"Finite-geometry LDPC (FG-LDPC) code","short_name":"FG-LDPC","introduced":"\\cite{doi:10.1109/18.959255}","description":"LDPC code whose parity-check matrix is the incidence matrix of points and hyperplanes in either a Euclidean or a projective geometry.\nSuch codes are called \\textit{Euclidean-geometry LDPC (EG-LDPC)} and \\textit{projective-geometry LDPC (PG-LDPC)}, respectively.\nSuch constructions have been generalized to incidence matrices of hyperplanes of different dimensions \\cite{doi:10.1109/TIT.2004.840867}.\n","relations":{"parents":[{"code_id":"regular_ldpc"},{"code_id":"algebraic_ldpc"}],"cousins":[{"code_id":"qc_ldpc","detail":"Many FG-LDPC codes can be put into quasi-cyclic form \\cite{doi:10.1109/18.959255,doi:10.1109/TIT.2004.840867}\\cite[pg. 286]{doi:10.1016/C2014-0-03412-0}."},{"code_id":"incidence_matrix","detail":"The parity-check matrix of a PG-LDPC code is the incidence matrix of points and hyperplanes in a projective space."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"pg_ldpc","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/pg_ldpc.yml","source_file_modification_token":1683723710988.8464}},"regular_ldpc":{"code_id":"regular_ldpc","physical":"bits","logical":"bits","name":"Regular LDPC code","description":"An LDPC code whose parity-check matrix has a fixed number of entries for each row or column.\n","relations":{"parents":[{"code_id":"ldpc"},{"code_id":"regular_binary_tanner","detail":"Regular LDPC codes are regular binary Tanner codes defined on sparse graphs whose constraint nodes represent parity-check codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"regular_ldpc","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/regular_ldpc.yml","source_file_modification_token":1683723710988.9062}},"sc_ldpc":{"code_id":"sc_ldpc","physical":"bits","logical":"bits","name":"Spatially coupled LDPC (SC-LDPC) code","short_name":"SC-LDPC","introduced":"\\cite{doi:10.1109/18.782171,manual:{K. Engdahl, K. Sh. Zigangirov, “To the Theory of Low-Density Convolutional Codes. I”, Probl. Peredachi Inf., 35:4 (1999), 12–28; Problems Inform. Transmission, 35:4 (1999), 295–310},doi:10.1023/A:1013815115684,doi:10.1109/18.782171,doi:10.1109/TIT.2010.2095072,doi:10.1109/TIT.2013.2280915}","description":"LDPC code whose parity-check matrix is constructed by \"spatially\" coupling several copies of a regular LDPC parity-check matrix in chain-like fashion (or, more generally, in grid-like fashion) to yield a band matrix.\nA finite-length chain is then capped by imposing either open boundary conditions (yielding \\textit{non-tail-biting} SC-LDPC codes) or open boundary conditions (yielding \\textit{tail-biting} SC-LDPC codes); sometimes extra \\textit{terminating vertices} are added to the ends of the chain.\nMatrices corresponding to translationally invariant chains are called \\textit{time-variant}, and otherwise are called \\textit{time-invariant}.\nThese codes can be constructed, e.g., using the \\hyperref[topic:lifting]{lifting} procedure or using edge-cutting vectors \\cite{doi:10.1109/TCOMM.2018.2867493}.\n","protection":"SC-LDPCs sometimes outperform other LDPC constructions \\cite{doi:10.1109/ISTC.2012.6325232,doi:10.1109/ITA.2007.4357569}.\n","features":{"rate":"Spatial coupling of LDPC codes can increase the achievable rate against BEC, coming close to the capacity \\cite{doi:10.1109/18.782171,doi:10.1109/TIT.2010.2095072,arXiv:cs/0508030}. SC-LDPC codes achieve capacity of the binary memoryless symmetric (BMS) channel \\cite{arxiv:1201.2999,arxiv:1309.7543}."},"relations":{"parents":[{"code_id":"protograph_ldpc","detail":"SC-LDPC codes can be interpreted as protograph LDPC codes \\cite{arxiv:1710.03619}."}],"cousins":[{"code_id":"ld_convolutional","detail":"Infinite-block versions of SC-LDPC are LDPC-CCs."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"sc_ldpc","source_file_path":"codes/classical/bits/tanner/regular_tanner/regular_ldpc/sc_ldpc.yml","source_file_modification_token":1687727505566.7324}},"ecc":{"code_id":"ecc","name":"Error-correcting code (ECC)","short_name":"ECC","description":"Code designed for transmission of classical information through classical channels in a robust way.\n","relations":{"parents":[{"code_id":"oaecc","detail":"Any ECC can be embedded into a quantum Hilbert space, and thus passed through a quantum channel, by associating elements of the alphabet with basis vectors in a Hilbert space over the complex numbers. For example, a bit of information can be embedded into a two-dimensional vector space by associating the two bit values with two basis vectors for the space."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-06"}]},"_zoodb":{"id":"ecc","source_file_path":"codes/classical/ecc.yml","source_file_modification_token":1683723710989.078}},"binary_permutation":{"code_id":"binary_permutation","physical":"groups","logical":"q-ary_digits","name":"Binary permutation-based code","introduced":"\\cite{doi:10.1016/S0019-9958(79)90076-7,doi:10.1016/j.ejc.2009.03.044}","description":"Stub.","relations":{"parents":[{"code_id":"group_classical"}]},"_meta":{"changelog":[{"user_id":"JiaxinHuang","date":"2022-04-08"}]},"_zoodb":{"id":"binary_permutation","source_file_path":"codes/classical/groups/binary_permutation.yml","source_file_modification_token":1680994436845.304}},"group_classical":{"code_id":"group_classical","physical":"groups","name":"Group-alphabet code","description":"Encodes \\(K\\) states (codewords) in coordinates labeled by elements of a group \\(G\\). The number of codewords may be infinite for infinite groups, so various restricted versions have to be constructed in practice.\n","relations":{"parents":[{"code_id":"ecc"}],"cousins":[{"code_id":"group_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-24"}]},"_zoodb":{"id":"group_classical","source_file_path":"codes/classical/groups/group_classical.yml","source_file_modification_token":1678631058716.323}},"group_linear":{"code_id":"group_linear","physical":"groups","name":"Linear code over \\(G\\)","introduced":"\\cite{doi:10.1109/49.29613,doi:10.1109/18.133243,doi:10.1109/18.104333}","description":"Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a group \\(G\\) such that the codewords form a subgroup of \\(G^n\\). In other words, the set of codewords is closed under the group operation.\n\nThe \\textit{automorphism group} of such codes is the group \\(G^n\\) formed by the action of \\(G\\) on each coordinate as well as the coordinate permutation group \\(S_n\\).\n","relations":{"parents":[{"code_id":"group_classical"},{"code_id":"group_orbit","detail":"The set of codewords of a linear code over \\(G\\) can be thought of as an orbit of a particular codeword under the group formed by the code. However, group orbit codes do not have to be linear \\cite[Remark 8.4.3]{preset:EricZin}."}],"cousins":[{"code_id":"group_gkp"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"},{"user_id":"VictorVAlbert","date":"2022-03-24"}]},"_zoodb":{"id":"group_linear","source_file_path":"codes/classical/groups/group_linear.yml","source_file_modification_token":1684508734540.3728}},"rank_modulation":{"code_id":"rank_modulation","physical":"groups","logical":"q-ary_digits","name":"Rank-modulation Gray code (RMGC)","short_name":"RMGC","introduced":"\\cite{doi:10.1109/TIT.1969.1054291,doi:10.1109/ISIT.2008.4595285}","description":"Also known as a \\textit{code in permutations}.\nA family of codes that encode a finite set of size \\(M\\) into a group \\(S_n\\) of permutations of \\([n]=(1,2,...,n)\\).\nThey can be derived from Lee-metric codes, Reed-Solomon codes \\cite{doi:10.1109/ISIT.2011.6034261}, quadratic residue codes and most binary codes.\n","protection":"Protects against errors in the Kendall tau distance on the space of permutations.\nThe Kendall distance between permutations \\(\\sigma\\) and \\(\\pi\\) is defined as the minimum number of adjacent transpositions required to change \\(\\sigma\\) into \\(\\pi\\).\n","features":{"rate":"Rank modulation codes with code distance \\(d=\\Theta(n^{1+\\epsilon})\\) for \\(\\epsilon\\in[0,1]\\) achieve a rate of \\(1-\\epsilon\\) \\cite{doi:10.1109/ISIT.2010.5513604}."},"realizations":["Electronic devices where charges can either increase in an individual cell or decrease in a block of adjacent cells, e.g., flash memories \\cite{doi:10.1109/TIT.2009.2018336}."],"relations":{"parents":[{"code_id":"group_classical","detail":"Group-alphabet codes whose alphabet is based on the permutation group \\(S_n\\) are rank-modulation codes."}],"cousins":[{"code_id":"gray","detail":"The rank-modulation Gray code is an extension of the original binary Gray code to a code on the permutation group \\cite{doi:10.1109/TIT.2009.2018336}."},{"code_id":"reed_solomon","detail":"RS codes can be used to design rank modulation codes \\cite{doi:10.1109/ISIT.2011.6034261}."},{"code_id":"binary_permutation","detail":"Binary permutation-based codes also encode messages into permutations but protect against errors with the Hamming distance."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"},{"user_id":"VictorVAlbert","date":"2022-04-12"},{"user_id":"JiaxinHuang","date":"2022-04-08"}]},"_zoodb":{"id":"rank_modulation","source_file_path":"codes/classical/groups/rank_modulation.yml","source_file_modification_token":1670025425878.1465}},"matrices_into_matrices":{"code_id":"matrices_into_matrices","physical":"matrices","name":"Matrix-based code","description":"Encodes \\(K\\) states (codewords) in an \\(m\\times n\\)-dimensional \\textit{matrix} of coordinates over a field (e.g., the Galois field \\(GF(q)\\) or the complex numbers \\(\\mathbb{C}\\)).","relations":{"parents":[{"code_id":"ecc_finite"},{"code_id":"block"},{"code_id":"group_classical","detail":"Matrix-based code alphabets are fields, which are groups under addition."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-16"}]},"_zoodb":{"id":"matrices_into_matrices","source_file_path":"codes/classical/matrices/matrices_into_matrices.yml","source_file_modification_token":1678631058716.5237}},"matrix_computation":{"code_id":"matrix_computation","physical":"matrices","logical":"matrices","name":"Matrix computation code","description":"Encoding that provides an extra redundancy for distributed matrix computation algorithms such as matrix multiplication. Parallelized algorithms distribute a desired computation over many nodes, and a key performance bottleneck is due to some nodes completing their individual tasks much later than other nodes. Matrix computation codes provide a layer of redundancy such that the computation can be performed without having all nodes finish their piece of the computation.\n","protection":"Allows computation to complete without waiting for \\textit{stragglers}, or nodes that either do not finish or finish their portion of the computation much later than all other nodes.","relations":{"parents":[{"code_id":"matrices_into_matrices","detail":""}],"cousins":[{"code_id":"mds","detail":"The first matrix multiplication code encoded each entry of the matrices to be multiplied into an MDS code \\cite{arXiv:1512.02673}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-06"}]},"_zoodb":{"id":"matrix_computation","source_file_path":"codes/classical/matrices/matrix_computation.yml","source_file_modification_token":1664458795443.2156}},"array":{"code_id":"array","physical":"matrices","name":"Disk array code","description":"Matrix code designed for use in an RAID-type array of hard-drives such that information is protected against erasure of one or more hard drives.\n","notes":["See \\cite[Ch. 14]{doi:10.1002/0471792748}\\cite{preset:BlaumArray} for introductions."],"relations":{"parents":[{"code_id":"matrices_into_matrices"},{"code_id":"distributed_storage"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"array","source_file_path":"codes/classical/matrices/raid/array.yml","source_file_modification_token":1683723710989.1704}},"b_array":{"code_id":"b_array","physical":"matrices","name":"B-code","introduced":"\\cite{doi:10.1109/18.179343}","description":"The first array code, constructed over \\(GF(q)\\).\n","features":{"decoders":["Efficient decoding algorithm against erasures \\cite{doi:10.1109/18.179343}."]},"relations":{"parents":[{"code_id":"array"}],"cousins":[{"code_id":"reed_solomon","detail":"B-codes can be interpreted as RS codes over polynomials whose symbols lie in Galois rings  \\cite{doi:10.1109/18.179343,doi:10.1007/978-1-4615-1525-8_7}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"b_array","source_file_path":"codes/classical/matrices/raid/b_array.yml","source_file_modification_token":1683723710989.238}},"x_array":{"code_id":"x_array","physical":"matrices","name":"X-code","introduced":"\\cite{doi:10.1109/18.746809}","description":"Array code with a simple geometrical construction that achieves optimal encoding and update complexity.\n","relations":{"parents":[{"code_id":"array"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"x_array","source_file_path":"codes/classical/matrices/raid/x_array.yml","source_file_modification_token":1683723710989.3096}},"gabidulin":{"code_id":"gabidulin","physical":"matrices","logical":"matrices","name":"Gabidulin code","introduced":"\\cite{manual:{E. M. Gabidulin, \\textit{Theory of Codes with Maximum Rank Distance}, Problemy Peredachi Informacii, Volume 21, Issue 1, \\emph{3–16} (1985)},doi:10.1109/18.75248}","description":"Also called a \\textit{vector rank-metric code}. A linear code over \\(GF(q^N)\\) that corrects errors over rank metric instead of the traditional Hamming distance. Every element \\(GF(q^N)\\) can be written as an \\(N\\)-dimensional vector with coefficients in \\(GF(q)\\), and the rank of a set of elements is rank of the matrix formed by their coefficients.\n\nGiven \\(X^n=\\text{span}\\{x_i\\}\\), an \\(n\\)-dimensional vector space over \\(GF(q^N)\\) (where \\(q\\) is a power of a prime number), the \\textit{rank metric} \\(d(x, y)\\) is defined via the rank norm \\(r(x, q) = \\mathrm{rank}(A(x))\\), where\n\\begin{align}\nA(x) = \\begin{pmatrix} a_{11} & a_{12} & \\ldots & a_{1n} \\\\ a_{21} & a_{22} & \\ldots & a_{2n} \\\\  a_{N1} & a_{N2} & \\ldots & a_{Nn}~, \\end{pmatrix}\n\\end{align}\nand \\(x_i = a_{1i} u_1 + a_{2i} u_2 + \\ldots + a_{Ni}u_N \\) for some fixed basis \\(\\{u_i\\}_{i=1}^N\\).\n","protection":"Set of vectors \\(\\{x_1, x_2, \\ldots, x_M\\}\\) determines a rank code with distance \\(d=\\min d(x_i, x_j)\\). The code with distance \\(d\\) corrects all errors with rank of the error not greater than \\(\\lfloor (d-1)/2\\rfloor\\).","features":{"decoders":["Fast decoder based on a transform-domain approach \\cite{arXiv:0901.2483}."]},"realizations":["Public-key cryptosystems \\cite{doi:10.1007/s10623-003-6151-2,doi:10.3390/cryptography2040032}.","Digital watermarking. The Gabidulin code provides efficient correction against luminance tampering and image-slicing distortion due to the consistency of the rank against alterations such as column swapping \\cite{doi:10.1109/ICASSP.2018.8462647}."],"relations":{"parents":[{"code_id":"rank_metric","detail":"Gabidulin codes over \\(GF(q^N)\\), when expressed as matrices over \\(GF(q)\\), are rank-metric codes (see Def. 14 in Ref. \\cite{arxiv:1410.1333}). The reverse is not always true since Gabidulin codes are not always \\(GF(q^N)\\)-linear \\cite[Rm. 16]{arxiv:1410.1333}."}],"cousins":[{"code_id":"maximum_rank_distance","detail":"Gabidulin codes over \\(GF(q^N)\\) with maximum rank-distance, when expressed as matrices over \\(GF(q)\\), are MRD codes."},{"code_id":"q-ary_linear","detail":"Gabidulin codes over \\(GF(q^N)\\), when expressed as vectors over \\(GF(q^N)\\), are linear \\(q\\)-ary codes."}]},"_meta":{"changelog":[{"user_id":"MicahShaw","date":"2022-08-09"},{"user_id":"VictorVAlbert","date":"2022-05-25"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"MariannaPodzorova","date":"2021-12-13"}]},"_zoodb":{"id":"gabidulin","source_file_path":"codes/classical/matrices/rank-metric/gabidulin.yml","source_file_modification_token":1678631058716.6294}},"lrpc":{"code_id":"lrpc","physical":"matrices","logical":"matrices","name":"Low-rank parity-check (LRPC) code","short_name":"LRPC","introduced":"\\cite{manual:{Gaborit, P., Murat, G., Ruatta, O., & Zemor, G. (2013, April). Low rank parity check codes and their application to cryptography. In Proceedings of the Workshop on Coding and Cryptography WCC (Vol. 2013).}}","description":"An LRPC code of rank \\(d\\) is a rank-metric code that, when interpreted as a linear code over \\(GF(q^m)\\), admits an \\((n-k)\\times n\\) parity-check matrix whose entries span a subspace of \\(GF(q^m)\\) that is at most \\(d\\)-dimensional.\n","features":{"decoders":["Efficient probabilistic decoder \\cite{manual:{Gaborit, P., Murat, G., Ruatta, O., & Zemor, G. (2013, April). Low rank parity check codes and their application to cryptography. In Proceedings of the Workshop on Coding and Cryptography WCC (Vol. 2013).}}.","Mixed decoder \\cite{doi:10.1007/978-3-319-11659-4_6}."]},"realizations":["Cryptosystem \\cite{manual:{Gaborit, P., Murat, G., Ruatta, O., & Zemor, G. (2013, April). Low rank parity check codes and their application to cryptography. In Proceedings of the Workshop on Coding and Cryptography WCC (Vol. 2013).}} that is a rank-metric analogue of NTRU \\cite{doi:10.1007/BFb0054868} and MDPC \\cite{doi:10.1109/ISIT.2013.6620590} cryptosystems.","Post-quantum cryptography \\cite{doi:10.1007/978-3-319-11659-4_6}."],"relations":{"parents":[{"code_id":"rank_metric"}],"cousins":[{"code_id":"ldpc","detail":"LRPC codes are rank-metric analogues of LDPC codes \\cite{manual:{Gaborit, P., Murat, G., Ruatta, O., & Zemor, G. (2013, April). Low rank parity check codes and their application to cryptography. In Proceedings of the Workshop on Coding and Cryptography WCC (Vol. 2013).}}."}]},"_meta":{"changelog":[{"user_id":"MazinKarjikar","date":"2023-01-16"},{"user_id":"VictorVAlbert","date":"2023-01-16"}]},"_zoodb":{"id":"lrpc","source_file_path":"codes/classical/matrices/rank-metric/lrpc.yml","source_file_modification_token":1674162588685.9014}},"maximum_rank_distance":{"code_id":"maximum_rank_distance","physical":"matrices","logical":"matrices","name":"Maximum-rank distance (MRD) code","short_name":"MRD","introduced":"\\cite{doi:10.1016/0097-3165(78)90015-8,manual:{E. M. Gabidulin, \"Theory of Codes with Maximum Rank Distance\", Problemy Peredachi Informacii, Volume 21, Issue 1, \\emph{3–16} (1985)},doi:10.1109/18.75248}","description":"Also called an \\textit{optimal rank-distance} code. An \\([n\\times m,k,d]_q\\) rank-metric code whose parameters are such that the Singleton-like bound\n\\begin{align}\nk \\leq \\max(n, m) (\\min(n, m) - d + 1)\n\\end{align}\nbecome an equality.\n","realizations":["Useful for error and erasure correction in network coding \\cite{arXiv:cs/0703061,arXiv:0711.0708}."],"relations":{"parents":[{"code_id":"rank_metric"}],"cousins":[{"code_id":"mds","detail":"MRD codes are matrix-code analogues of MDS codes."},{"code_id":"reed_solomon","detail":"MRD rank-metric codes can be thought of as matrix analogues of MDS Reed-Solomon codes as both constructions utilize a Vandermonde matrix \\cite{doi:10.1109/TIT.2008.926449}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-25"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"MariannaPodzorova","date":"2021-12-13"}]},"_zoodb":{"id":"maximum_rank_distance","source_file_path":"codes/classical/matrices/rank-metric/maximum_rank_distance.yml","source_file_modification_token":1674162588686.0142}},"rank_metric":{"code_id":"rank_metric","physical":"matrices","logical":"matrices","name":"Rank-metric code","introduced":"\\cite{doi:10.1016/0097-3165(78)90015-8}","description":"Also called a \\textit{Delsarte code}. Each codeword is a \\textit{matrix} over \\(GF(q)\\), with codewords forming a \\(GF(q)\\)-linear subspace, and with the metric being the rank of the difference of matrices. The distance \\(d\\) is the minimum rank of all nonzero matrices in the code. Rank-metric codes on \\(n\\times m\\) matrices are denoted as \\([n\\times m,k,d]_q\\).\n\nThe number of codewords satisfies \\(k \\leq \\max(n, m) M\\), where \\(M\\) is the maximum rank of all matrices in the code. Codes that achieve this bound with equality are called \\textit{Delsarte optimal anticodes}.\n","protection":"Protects against errors with rank \\(\\leq \\lfloor \\frac{d-1}2 \\rfloor\\).\n\nThe complexity of decoding rank-metric codes is unknown but expected to be harder than that of binary linear codes \\cite{arxiv:1404.3482}.\n","features":{"decoders":["Polynomial-reconstruction Berlekamp-Welch based decoder \\cite{doi:10.1007/11779360_4}.","Berlekamp-Massey based decoder \\cite{doi:10.1109/ISIT.2004.1365435}."]},"realizations":["Identity-Based Encryption \\cite{doi:10.1007/978-3-319-63697-9_7}.","Digital watermarking \\cite{doi:10.1016/j.image.2018.12.015}.","Network coding and streaming media broadcasting \\cite{doi:10.1109/CWIT.2007.375706}."],"notes":["See Ref. \\cite{arXiv:1410.1333} for a discussion of MacWilliams identities and the relationship between rank metric and Gabidulin codes."],"relations":{"parents":[{"code_id":"matrices_into_matrices"}]},"_meta":{"changelog":[{"user_id":"MazinKarjikar","date":"2023-01-16"},{"user_id":"VictorVAlbert","date":"2023-01-16"},{"user_id":"MazinKarjikar","date":"2022-12-30"},{"user_id":"VictorVAlbert","date":"2022-05-25"},{"user_id":"ThomasWrona","date":"2022-05-18"}]},"_zoodb":{"id":"rank_metric","source_file_path":"codes/classical/matrices/rank-metric/rank_metric.yml","source_file_modification_token":1678631058716.722}},"mbr":{"code_id":"mbr","physical":"matrices","logical":"q-ary_digits","name":"Minimum-bandwidth regenerating (MBR) code","short_name":"MBR","description":"Stub.","relations":{"parents":[{"code_id":"regenerating"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"mbr","source_file_path":"codes/classical/matrices/regenerating/mbr.yml","source_file_modification_token":1678631058716.8696}},"msr":{"code_id":"msr","physical":"matrices","logical":"q-ary_digits","name":"Minimum-storage regenerating (MSR) code","short_name":"MSR","description":"Stub.","relations":{"parents":[{"code_id":"regenerating"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"msr","source_file_path":"codes/classical/matrices/regenerating/msr.yml","source_file_modification_token":1678631058716.9568}},"regenerating":{"code_id":"regenerating","physical":"matrices","logical":"q-ary_digits","name":"Regenerating code (RGC)","short_name":"RGC","description":"Stub.","relations":{"parents":[{"code_id":"distributed_storage"},{"code_id":"matrices_into_matrices"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"regenerating","source_file_path":"codes/classical/matrices/regenerating/regenerating.yml","source_file_modification_token":1678631058717.031}},"alamouti":{"code_id":"alamouti","physical":"matrices","logical":"q-ary_digits","name":"Alamouti code","introduced":"\\cite{doi:10.1109/49.730453}","description":"The simplest OSTBC, with two time slots, two channels, and with unitary coding matrix\n\\begin{align}\n  \\begin{pmatrix}c_{1} & c_{2}\\\\\n  -c_{2}^{\\star} & c_{1}^{\\star}\n  \\end{pmatrix}~,\n\\end{align}\nwhere \\(c_i\\) are complex numbers.\n","features":{"rate":"The only OSTBC with unity rate."},"realizations":["Wireless standards since: 3G, LTE, LTE-Advanced, and 5G.","Wireless communication: IEEE 802.11n, IEEE 802.11ad, IEEE 802.11ay, etc."],"relations":{"parents":[{"code_id":"orth_spacetime_block"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"}]},"_zoodb":{"id":"alamouti","source_file_path":"codes/classical/matrices/spacetime/alamouti.yml","source_file_modification_token":1683723710989.4165}},"orth_spacetime_block":{"code_id":"orth_spacetime_block","physical":"matrices","logical":"q-ary_digits","name":"Orthogonal Spacetime Block Code (OSTBC)","short_name":"OSTBC","introduced":"\\cite{doi:10.1109/49.730453}","description":"The codewords are \\(T\\times n\\) matrices as defined for spacetime codes, with the additional condition that columns of the coding matrix are orthogonal. The parameter \\(n\\) is the number of channels, and \\(T\\) is the number of time slots.","protection":"If the matrix \\(C-C'\\), where \\(C\\) and \\(C'\\) are distinct codewords, has minimum rank \\(b\\), the code has diversity order \\(bn_R\\) \\cite[Sec. 28.2.1]{preset:HKSstc}, where \\(n_R\\) is the number of receivers. The maximum possible diversity order is \\(nn_R\\).","features":{"rate":"The greatest rate which can be achieved is \\(\\frac{n_0+1}{2n_0}\\), where either \\(n=2n_0\\) or \\(n=2n_0-1\\) \\cite{doi:10.1109/TIT.2003.817426}.","decoders":["Maximum-likelihood decoding can be achieved with only linear processing \\cite{doi:10.1109/49.753730}."]},"relations":{"parents":[{"code_id":"spacetime_block","detail":"The same construction without the constraint that the codeword matrices are orthogonal."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"},{"user_id":"RichardBarney","date":"2022-04-05"}]},"_zoodb":{"id":"orth_spacetime_block","source_file_path":"codes/classical/matrices/spacetime/orth_spacetime_block.yml","source_file_modification_token":1682250129447.6104}},"spacetime":{"code_id":"spacetime","physical":"matrices","logical":"q-ary_digits","name":"Spacetime code (STC)","short_name":"STC","introduced":"\\cite{doi:10.1109/18.661517}","description":"Code designed for wireless transmission of information (via, e.g., radio waves) such that the sender can send multiple times from multiple locations. A spacetime code uses a modulation scheme to encode a message into signals that are sent at different times through different antennas, thereby utilizing both spatial and temporal (i.e., \\textit{spacetime}) degrees of freedom.\n","notes":["See the chapter \\cite{doi:10.1016/B978-0-12-385055-3.00002-X} or Ref. \\cite{preset:HKSstc} for an introduction to spacetime coding."],"features":{"rate":"Shannon capacity of various multiple-input multiple-output (MIMO) channels has been determined \\cite{doi:10.1109/JSAC.2003.810294}."},"relations":{"parents":[{"code_id":"matrices_into_matrices","detail":""}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"}]},"_zoodb":{"id":"spacetime","source_file_path":"codes/classical/matrices/spacetime/spacetime.yml","source_file_modification_token":1684508734540.5144}},"spacetime_block":{"code_id":"spacetime_block","physical":"matrices","logical":"q-ary_digits","name":"Spacetime block code (STBC)","short_name":"STBC","introduced":"\\cite{doi:10.1109/18.887864,doi:10.1109/18.868472,doi:10.1109/18.825818,doi:10.1109/26.891215}","description":"In a space-time block code, \\(n\\) spatially separated channels transmit symbols in \\(T\\) time slots. These symbols can be arranged in a \\(T\\times n\\) matrix where the columns correspond to the channels, and the rows correspond to the time slots. The codewords \\(\\{X\\}\\) are \\(T\\times n\\) matrices such that the codeword difference matrices have rank \\(n\\), and \\(\\min_{X\\neq 0}\\det(XX^*)\\) is maximized.","protection":"Provides protection against errors due to thermal noise and destructive interference arising from traversing an environment with scattering, reflection, and/or refraction.","realizations":["High data-rate wireless communication, e.g., WiMAX (IEEE 802.16m) \\cite{doi:10.1007/s11235-013-9846-3,doi:10.1109/JSTSP.2008.922508,doi:10.1109/MWC.2006.1678163}."],"relations":{"parents":[{"code_id":"spacetime","detail":"Spacetime codes also use spatial and temporal diversity, but do not necessarily use blocks as codewords."}]},"_meta":{"changelog":[{"user_id":"RichardBarney","date":"2022-04-05"}]},"_zoodb":{"id":"spacetime_block","source_file_path":"codes/classical/matrices/spacetime/spacetime_block.yml","source_file_modification_token":1684508734540.6797}},"spacetime_group":{"code_id":"spacetime_group","physical":"matrices","logical":"q-ary_digits","name":"Multi-channel group-orbit code","introduced":"\\cite{doi:10.1109/18.887864}","description":"Extension of binary group-orbit codes to multi-antenna transmission.\n","relations":{"parents":[{"code_id":"spacetime_block"},{"code_id":"group_orbit"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-18"}]},"_zoodb":{"id":"spacetime_group","source_file_path":"codes/classical/matrices/spacetime/spacetime_group.yml","source_file_modification_token":1684508734540.7698}},"tensor":{"code_id":"tensor","physical":"matrices","name":"Tensor-product code","introduced":"\\cite{doi:10.1109/TIT.1954.1057464,doi:10.1109/TIT.1965.1053802,preset:Forney,doi:10.1109/TIT.1970.1054477}","description":"Also called \\textit{tensor code}, \\textit{Kroneckerian code}, or \\textit{product code}. A matrix-based code constructed out of two linear binary or \\(q\\)-ary codes \\(C_A,C_B\\) in an outer-product construction denoted as \\(C_A \\otimes C_B\\). Its dual is sometimes called the \\textit{check-product} code \\cite[Lemma 3.3]{arxiv:2209.11405}.\n\nCodewords are those matrices whose column vectors are in \\(C_A\\) and whose row vectors are in \\(C_B\\).\nIn other words, the matrix-valued codewords \\(c\\) of a tensor code satisfy the parity check equation \\(H_A c H^{\\text{T}}_B = 0\\).\n","protection":"For linear codes \\(C_A=[n_A,k_A,d_A]\\) and \\(C_B=[n_B,k_B,d_B]\\), the resulting tensor code is \\(C_A \\otimes C_B=[n_A n_B,k_A k_B,d_A d_B]\\).\nTensor codes can be useful for protecting against burst errors \\cite{doi:10.1109/TIT.1971.1054690,doi:10.1109/TIT.1973.1055085}.\n\nMany (but not all \\cite{doi:10.1007/11538462_40}) tensor codes are \\textit{robustly testable} \\cite{arXiv:cs/0408066,doi:10.1007/11830924_29,doi:10.1007/978-3-540-85363-3_24}, a property useful for constructing LTCs \\cite{doi:10.1145/1236457.1236459}, including a family of \\(c^3\\)-LTCs \\cite{arxiv:2111.04808}. Duals of tensor codes formed by two random linear codes are also robustly testable, a property useful for constructing asymptotically good QLDPC codes \\cite{arxiv:2206.07750,arxiv:2206.09973} and proving distance bounds \\cite{arxiv:2208.05537}.\n","features":{"rate":"Rate of the tensor-product code \\(C_A \\otimes C_B\\) is a product of the rates of the codes \\(C_A\\) and \\(C_B\\).","decoders":["The simple decoding algorithm (first decode all columns with \\(C_1\\), then all rows with \\(C_2\\)) corrects up to \\((d_A d_B-1)/4 \\) errors.","Algorithms such as generalized minimum-distance decoding \\cite{doi:10.1109/TIT.1966.1053873} or the min-sum algorithm can decode all errors of weight up to \\((d_A d_B-1)/2\\). Error location may be coupled with Viterbi decoding for every faulty sub-block \\cite{doi:10.1109/TMAG.2005.861043}."]},"realizations":["Construction can be used in magnetic recording by taking the tensor product of a Reed-Solomon code and a parity-check code \\cite{doi:10.1109/TMAG.2005.861043}."],"notes":["See Refs. (\\cite{preset:MacSlo}, Ch. 18; \\cite{manual:{Wolf, Jack Keil. \"An introduction to tensor product codes and applications to digital storage systems.\" 2006 IEEE Information Theory Workshop-ITW 2006 Chengdu. IEEE, 2006.}}) for expositions."],"relations":{"parents":[{"code_id":"matrices_into_matrices"},{"code_id":"generalized_concatenated"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"},{"user_id":"ShashankSule","date":"2022-04-21"}]},"_zoodb":{"id":"tensor","source_file_path":"codes/classical/matrices/tensor.yml","source_file_modification_token":1664741378385.8564}},"block":{"code_id":"block","name":"Block code","description":"A code intended to encode a piece, or block, of a data stream on a \\textit{block} of \\(n\\) symbols.\nEach symbol is taken from some fixed possibly infinite alphabet \\(\\Sigma\\) \\cite[Ch. 3]{doi:10.1007/978-3-642-58575-3}, which can include bits, Galois fields, rings, or real numbers.\n\nThe overall alphabet of the code is \\(\\Sigma^n\\), and \\(n\\) is called the \\textit{length} of the code.\nIn some cases, only a subset of \\(\\Sigma^n\\) is available to use for constructing the code.\nFor example, in the case of spherical codes, one is constrained to \\(n\\)-dimensional real vectors on the unit sphere.\n\nAn alternative more stringent definition (not used here) is in terms of a map encoding logical information from \\(\\Sigma^k\\) into \\(\\Sigma^n\\), yielding an \\((n,k,d)_{\\Sigma}\\) block code, where \\(d\\) is the code distance.\n","protection":"Block codes protect from errors acting on a few of the \\(n\\) symbols. A block code with \\textit{distance} \\(d\\) detects errors acting on up to \\(d-1\\) symbols, and corrects erasure errors on up to \\(d-1\\) symbols.\n","features":{"rate":"The Shannon channel capacity (the maximum of the mutual information over input and output distributions) is the highest rate of information transmission through a classical (i.e., non-quantum) channel with arbitrarily small error rate \\cite{doi:10.1002/j.1538-7305.1948.tb01338.x}. Corrections to the capacity and tradeoff between decoding error, code rate and code length are determined using small \\cite{manual:{V. Strassen, “Asymptotische Absch¨atzungen in Shannons Informationstheorie,” Trans. Third Prague Conference on Information Theory, Prague, 689–723, (1962)},arxiv:0801.2242,doi:10.1109/TIT.2010.2043769}, moderate \\cite{arxiv:1208.1924,doi:10.1109/ALLERTON.2010.5707068,arxiv:1701.03114} and large \\cite{doi:10.1007/978-3-7091-2945-6,doi:10.1017/CBO9780511921889,doi:10.1109/TIT.1973.1055007,doi:10.1109/TIT.1979.1056003} deviation analysis. Sometimes the difference from the asymptotic rate at finite block length can be characterized by the \\textit{channel dispersion} \\cite{doi:10.1109/TIT.2010.2043769,doi:10.1109/TIT.2014.2341919}.","decoders":["Decoding an error-correcting code is equivalent to finding the ground state of some statistical mechanical model \\cite{doi:10.1038/339693a0}."]},"relations":{"parents":[{"code_id":"ecc"}],"cousins":[{"code_id":"block_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-14"}]},"_zoodb":{"id":"block","source_file_path":"codes/classical/properties/block/block.yml","source_file_modification_token":1683723710989.553}},"constant_weight":{"code_id":"constant_weight","name":"Constant-weight code","description":"A block code over a field or a ring whose codewords all have the same Hamming weight \\(w\\).\nThe \\textit{complement} of a binary constant-weight code is a constant-weight code obtained by interchanging zeroes and ones in the codewords.\nThe set of all binary codewords of length \\(n\\) forms the \\textit{Johnson space} \\(J(n,w)\\) \\cite{manual:{Delsarte, Philippe. \"An algebraic approach to the association schemes of coding theory.\" Philips Res. Rep. Suppl. 10 (1973): vi+-97.},doi:10.1016/0097-3165(76)90017-0,doi:10.1137/0134012,doi:10.1007/BF00053379}.\n\nConstant-weight codes that contain all strings of some fixed Hamming weight are known as \\textit{\\(m\\)-in-\\(n\\)} or \\({n \\choose m}\\) codes.\n","protection":"See Ref. \\cite{doi:10.1109/18.887851} for upper bounds on \\(K\\) for \\((n,K,d)_q\\) constant-weight binary codes.\n","realizations":["Radio-network frequency hopping \\cite{doi:10.37236/1162}."],"notes":["Tables of binary constant-weight codes for \\(n \\leq 28\\) \\cite{doi:10.1109/18.59932} and \\(n > 28\\) \\cite{doi:10.37236/1162}. Other code constructions also exist for codes over fields \\cite{doi:10.1109/18.651060} or rings \\cite{doi:10.1016/0012-365X(95)00333-R}.","See book \\cite{preset:MacSlo} for (Johnson) bounds on the size of constant-weight codes."],"relations":{"parents":[{"code_id":"block"}],"cousins":[{"code_id":"constant_excitation","detail":"Constant-weight codes are classical analogues of qubit constant-excitation codes."},{"code_id":"univ_opt_q-ary","detail":"See \\cite[Table 8.4]{doi:10.1007/BF00053379} for constant-weight universally optimal \\(q\\)-ary codes."},{"code_id":"divisible","detail":"Codes whose codewords have a constant weight of \\(m\\) are automatically \\(m\\)-divisible. However, divisible codes are linear by definition while constant-weight codes do not have to be."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-14"},{"user_id":"MicahShaw","date":"2022-05-30"}]},"_zoodb":{"id":"constant_weight","source_file_path":"codes/classical/properties/block/constant_weight.yml","source_file_modification_token":1682420107451.5173}},"cyclic":{"code_id":"cyclic","name":"Cyclic code","introduced":"\\cite{manual:{E. Prange, \\emph{Cyclic Error-Correcting Codes in Two Symbols}, TN-57-/03, (September 1957)},manual:{E. Prange, \\emph{Some cyclic error-correcting codes with simple decoding algorithms}, TN-58-156, (April 1958)},manual:{E. Prange, \\emph{The use of coset equivalence in the analysis and decoding of group codes}, TN-59-/64, (1959)},manual:{E. Prange, \\emph{An algorithm for factoring xn - I over a finite field}. TN-59-/75, (October 1959)},preset:PetersonWeldon}","description":"A code of length \\(n\\) over an alphabet is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword.\n","relations":{"parents":[{"code_id":"quasi_cyclic","detail":"Quasi-cyclic codes with \\(\\ell=1\\) are cyclic."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-20"},{"user_id":"VictorVAlbert","date":"2021-11-30"},{"user_id":"NolanCoble","date":"2021-11-28"}]},"_zoodb":{"id":"cyclic","source_file_path":"codes/classical/properties/block/cyclic/cyclic.yml","source_file_modification_token":1678631058717.219}},"quasi_cyclic":{"code_id":"quasi_cyclic","name":"Quasi-cyclic code","introduced":"\\cite{doi:10.1109/TIT.1967.1053974}","description":"A block code of length \\(n\\) is quasi-cyclic if, for each codeword \\(c_1 \\cdots c_{\\ell} c_{\\ell+1} \\cdots c_n\\), the string \\(c_{n-\\ell+1} \\cdots c_n c_1 \\cdots c_{n-\\ell}\\) where each entry is cyclically shifted by \\(\\ell\\) increments is also a codeword.\n\nThe generator of an \\([mn_0,mk_0]\\) quasi-cyclic linear code is representable as a block matrix of \\(m \\times m\\) circulant matrices \\cite{manual:{Thomas A. Gulliver, \\href{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.3623}{Construction of quasi-cyclic codes}, Thesis, University of New Brunswick, 1989.}}.\n","notes":["A database of quasi-cyclic codes with searchable parameters such as block length and dimension is constructed and displayed \\href{http://www.tec.hkr.se/~chen/research/codes/qc.htm}{here}."],"relations":{"parents":[{"code_id":"block"}],"cousins":[{"code_id":"convolutional","detail":"Quasi-cyclic codes can be \\textit{unwrapped} to obtain convolutional codes \\cite{manual:{G. D. Forney, Jr., “Why quasi cyclic codes are interesting,” unpublished note, 1970.},doi:10.1137/0137027,manual:{R. Michael Tanner, “Error-correcting coding system,” U.S. Patent 4295218, 1981.},manual:{R. Michael Tanner. Convolutional codes from quasi-cyclic codes: A link between the theories of block and convolutional codes. University of California, Santa Cruz, Computer Research Laboratory, 1987.},manual:{“Generalized tail-biting convolutional codes,” Ph.D. dissertation, Univ. of Massachusetts, Amherst, 1985.},manual:{Y. Levy and J. Costello, Jr., “An algebraic approach to constructing convolutional codes from quasi-cyclic codes,” DIMACS Ser. Discr. Math. and Theor. Comp. Sci., vol. 14, pp. 189–198, 1993.},doi:10.1109/18.651076}."},{"code_id":"sc_qldpc","detail":"Quasi-cyclic binary code parity-check matrices can be used as sub-matrices to define a 1D SC-QLDPC code \\cite{arxiv:1102.3181}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-14"},{"user_id":"MicahShaw","date":"2022-06-13"},{"user_id":"NolanCoble","date":"2021-11-27"}]},"_zoodb":{"id":"quasi_cyclic","source_file_path":"codes/classical/properties/block/cyclic/quasi_cyclic.yml","source_file_modification_token":1687727505566.8606}},"reversible":{"code_id":"reversible","name":"Reversible code","description":"A code of length \\(n\\) over an alphabet is reversible if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the reversed string \\(c_n \\cdots c_2 c_1\\) is also a codeword.\n","relations":{"parents":[{"code_id":"block"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-02"}]},"_zoodb":{"id":"reversible","source_file_path":"codes/classical/properties/block/cyclic/reversible.yml","source_file_modification_token":1678631058717.2969}},"skew_cyclic":{"code_id":"skew_cyclic","name":"Skew-cyclic code","introduced":"\\cite{arXiv:math/0604603}","description":"A classical code \\(C\\) of length \\(n\\) over an alphabet \\(R\\) is skew-cyclic if there exists an automorphism, \\(\\theta\\), of \\(R\\), such that for each string \\(c_1 c_2 \\cdots c_n\\in C\\), the skew-cyclically shifted string \\(\\theta(c_n) \\theta(c_1) \\cdots \\theta(c_{n-1})\\in C\\). We say that \\(C\\) is a \\(\\theta\\)-cyclic code over \\(R\\).","features":{"decoders":["Only given for skew-BCH codes, adapted froom standard BCH codes."]},"realizations":["Not directly implemented, but BCH codes form a subclass, and are used in DVD, solid state drive storage, etc."],"notes":["Computer algebra software is used to find most codes of this type. Ref. \\cite{arXiv:math/0604603} gives several examples of codes, which have slightly improved minimum distance for some \\((n,k)\\) codes."],"relations":{"parents":[{"code_id":"quasi_cyclic","detail":"Under certain conditions, there is an equivalent quasi-cyclic code for every skew-cyclic code \\cite{doi:10.1504/IJICOT.2011.044674}."}]},"_meta":{"changelog":[{"user_id":"NolanCoble","date":"2021-12-03"}]},"_zoodb":{"id":"skew_cyclic","source_file_path":"codes/classical/properties/block/cyclic/skew_cyclic.yml","source_file_modification_token":1677058672661.3755}},"delsarte_optimal":{"code_id":"delsarte_optimal","name":"Sharp configuration","introduced":"\\cite{doi:10.1007/BF00053379,preset:LevBounds,arxiv:math/0607446}","description":"Also called a \\textit{Delsarte code}.\nA code \\(C\\) that attains a universal bound expressed in terms of the minimal distance, the number of distances between codewords, and the strength of the design formed by the codewords.\nFor codes on the sphere or on the real, complex, quaternionic, or octonionic projective space,\n\\(C\\) is a design of strength \\(M\\) and admits \\(m\\) different distances between its points such that \\(M \\geq 2m - 1 - \\delta\\), where \\(\\delta\\) is one if there are two antipodal points in \\(C\\) and zero otherwise \\cite{arxiv:math/0607446}.\n\nSharp configurations attain the the Levenshtein bound \\cite{manual:{V. I. Levenshtein, \"On choosing polynomials to obtain bounds in packing problems.\" Proc. Seventh All-Union Conf. on Coding Theory and Information Transmission, Part II, Moscow, Vilnius. 1978.},manual:{V. I. Levenshtein, “On bounds for packings in n-dimensional Euclidean space”, Dokl. Akad. Nauk SSSR, 245:6 (1979), 1299–1303},doi:10.1007/BF00053379,preset:LevBounds}.\nHowever, not all codes that attain the Levenshtein bound are sharp configurations.\nSee \\cite[Table 9.2]{doi:10.1007/BF00053379} for Levenshtein-bound achieving codes on various projective spaces.\n","relations":{"parents":[{"code_id":"univ_opt","detail":"All sharp configurations are universally optimal \\cite{arxiv:math/0607446,arxiv:1212.1913}, but not all universally optimal codes are sharp configurations."}],"cousins":[{"code_id":"24cell","detail":"The 12 sets of antipodal pairs of the 24-cell code form a sharp configuration in the projective space \\(\\mathbb{R}P^3\\) \\cite{arxiv:math/0607446}."},{"code_id":"esix_shell","detail":"The 36 sets of antipodal pairs of the smallest \\(E_6\\) lattice shell form a sharp configuration in the projective space \\(\\mathbb{R}P^5\\) \\cite{arxiv:math/0607446}."},{"code_id":"eseven_shell","detail":"The 63 sets of antipodal pairs of the smallest \\(E_7\\) lattice shell form a sharp configuration in the projective space \\(\\mathbb{R}P^6\\) \\cite{arxiv:math/0607446}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"delsarte_optimal","source_file_path":"codes/classical/properties/block/universally_optimal/delsarte_optimal.yml","source_file_modification_token":1678631058717.3767}},"univ_opt":{"code_id":"univ_opt","name":"Universally optimal code","introduced":"\\cite{manual:{G. A. Kabatiansky, V. I. Levenshtein, “On Bounds for Packings on a Sphere and in Space”, Probl. Peredachi Inf., 14:1 (1978), 3–25; Problems Inform. Transmission, 14:1 (1978), 1–17}}","description":"A code that produces a minimum over all codes of its cardinality for a large family of potential functions.\nSuch codes exist for the conventional \\(q\\)-ary and real spaces (see children below), but can also be formulated for more exotic spaces such as Lie groups, projective spaces, and real Grassmanians \\cite{arxiv:1308.3188,arXiv:1904.11159}.\n","relations":{"parents":[{"code_id":"block"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-28"}]},"_zoodb":{"id":"univ_opt","source_file_path":"codes/classical/properties/block/universally_optimal/univ_opt.yml","source_file_modification_token":1683723710989.7961}},"concatenated":{"code_id":"concatenated","name":"Concatenated code","introduced":"\\cite{preset:Forney}","description":"Also called a \\textit{serially concatenated} code \\cite{doi:10.1109/TIT.2005.846392}. Stub.","protection":"","features":{"decoders":["Generalized minimum-distance decoder \\cite{doi:10.1109/TIT.1966.1053873}."]},"relations":{"parents":[{"code_id":"generalized_concatenated"}],"cousins":[{"code_id":"quantum_concatenated"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"concatenated","source_file_path":"codes/classical/properties/concatenated/concatenated.yml","source_file_modification_token":1678631058717.5352}},"generalized_concatenated":{"code_id":"generalized_concatenated","name":"Generalized concatenated code","description":"Stub.","protection":"","relations":{"parents":[{"code_id":"ecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-11-04"}]},"_zoodb":{"id":"generalized_concatenated","source_file_path":"codes/classical/properties/concatenated/generalized_concatenated.yml","source_file_modification_token":1678631058717.6167}},"parallel_concatenated":{"code_id":"parallel_concatenated","name":"Parallel concatenated code","description":"Stub.","protection":"","relations":{"parents":[{"code_id":"ecc"}],"cousins":[{"code_id":"concatenated"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"parallel_concatenated","source_file_path":"codes/classical/properties/concatenated/parallel_concatenated.yml","source_file_modification_token":1678631058717.691}},"ecc_finite":{"code_id":"ecc_finite","name":"Finite-dimensional error-correcting code (ECC)","short_name":"Finite ECC","introduced":"\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x}","description":"A \\textit{code} is a subset of a set or \\textit{alphabet}, with each element called a \\textit{codeword}. An \\textit{error-correcting code} consists of \\(K\\) codewords over an alphabet with \\(N\\) elements such that it is possible to recover the codewords from errors \\(E\\) from some error set \\(\\mathcal{E}\\).\n","protection":"A code corrects errors associated with a noise channel if it is possible to recover any codeword after its coordinates have been changed after going through the channel. More technically, an error-correcting code \\((u,\\mathcal{E})\\) is an \\textit{encoder} function \\(u:[1\\cdots K]\\to[1\\cdots N]\\) with a set of correctable errors \\(E:[1\\cdots N]\\to [1\\cdots M]\\) with the following property: there exists a \\textit{decoder} function \\(d:[1\\cdots M]\\to [1\\cdots K]\\) such that for all \\(E\\in\\cal{E}\\) and states \\(x\\in[1\\cdots K]\\), \\(d(E(e(x)))=x\\) \\cite{preset:GottesmanBook}.","features":{"decoders":["Capacity-achieving Guessing Random Additive Noise Decoding (GRAND) \\cite{arxiv:1802.07010} (see also \\cite{doi:10.1109/ISIT.2018.8437648})."]},"notes":["The modern theory of error-correcting codes is rooted in the foundational work of C. Shannon \\cite{doi:10.1002/j.1538-7305.1948.tb01338.x}, but error-correcting codes have been used prior to that work \\cite{doi:10.1007/bf03025254}.","Boolean networks, designed to model gene regulatory networks, generically develop error-correcting codes when they are evolved to perform computations \\cite{arxiv:2303.14448}."],"relations":{"parents":[{"code_id":"ecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"},{"user_id":"VictorVAlbert","date":"2021-11-24"}]},"_zoodb":{"id":"ecc_finite","source_file_path":"codes/classical/properties/ecc_finite.yml","source_file_modification_token":1680994436845.6406}},"group_orbit":{"code_id":"group_orbit","name":"Group-orbit code","description":"Code whose set of codewords forms an orbit of some reference codeword under a subgroup of the \\textit{automorphism group}, i.e., the group of distance-preserving transformations on the metric space defined with the code's alphabet.\n","relations":{"parents":[{"code_id":"ecc","detail":"Not all codes are group-orbit codes, and more generally one can classify codewords into orbits of the automorphism group \\cite{doi:10.1109/18.57203}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-18"}]},"_zoodb":{"id":"group_orbit","source_file_path":"codes/classical/properties/group_orbit.yml","source_file_modification_token":1684508734540.9326}},"ldc":{"code_id":"ldc","name":"Locally decodable code (LDC)","short_name":"LDC","introduced":"\\cite{doi:10.1145/335305.335315}","description":"BLock code for which one can efficiently correct a given string.\nEfficiency of the correction is quantified by the code's \\textit{query complexity} \\(u\\), and correction is performed by sampling subsets of \\(u\\) bits.\nLocal decodability may only be possible up to some tolerated corruption rate \\(\\delta\\).\n\nLDCs have applications in computational complexity theory and cryptography \\cite[Sec. 17.4]{doi:10.1017/CBO9780511804090}\\cite{doi:10.1561/0400000030,doi:10.1145/301250.301397,doi:10.1145/2993749.2993761}.\n\nModified versions of local decodability include \\textit{relaxed local decodability} \\cite{doi:10.1145/1007352.1007361}.\n","features":{"decoders":["LDCs admit \\textit{local decoders}, i.e., decoders whose runtime scales polylogarithmically with \\(n\\)."]},"relations":{"parents":[{"code_id":"block"}],"cousins":[{"code_id":"ltc","detail":"There are relations between LDCs and LTCs \\cite{doi:10.1007/978-3-642-15369-3_50}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-05"}]},"_zoodb":{"id":"ldc","source_file_path":"codes/classical/properties/ltc/ldc.yml","source_file_modification_token":1683723710989.8992}},"ltc":{"code_id":"ltc","name":"Locally testable code (LTC)","short_name":"LTC","introduced":"\\cite{doi:10.1145/103418.103428,manual:{Sanjeev Arora. \\emph{Probabilistic checking of proofs and hardness of approximation problems}. UC Berkeley, 1994.},doi:10.1137/S0097539793255151,arxiv:1307.3975}","description":"Code for which one can efficiently check whether a given string is a codeword or is far from a codeword. Efficiency of the verification is quantified by the code's \\textit{query complexity} \\(u\\), while effectiveness is quantified by the code's \\textit{soundness} \\(R\\).\n\nTypically, one looks at how \\(R\\) scales with increasing code size for infinite families of codes, defining LTC families as those for which the soundness is asymptotically constant. Such LTC families with asymptotically constant distance, rate, and query complexity are called \\(c^3\\)\\textit{-LTCs}. The first two such families are classical codes arising from the \\hyperref[code:expander_lifted_product]{expander lifted-product} quantum code construction and \\hyperref[code:lr-cayley-complex]{left-right Cayley complex} codes.\n\nA technical definition for codes over binary alphabets is provided as follows; for general alphabets, see Ref. \\cite{doi:10.1007/978-3-642-16367-8_6}.\nThe idea behind LTCs is to be able to reliably test whether a given bit-string \\(x\\) is in the code by only sampling subsets of \\(u\\) bits.\nTo have something to check against, we first have to define a collection of length-\\(u\\) subsets \\(S\\) of bit locations that are called \\textit{allowed local views}.\nA code is LTC if the following two conditions are satisfied \\cite[Thm. 1.1]{arxiv:2111.04808}.\n\nFirst, if \\(x\\) is a codeword, then all of its restrictions \\(x|_S\\) to the subsets \\(S\\) are allowed local views,\n\\begin{align}\n  x\\in C \\Rightarrow x|_S \\in \\{\\text{allowed local views}\\}~.\n\\end{align}\nThis guarantees that codewords can indeed be determined from this limited sampling procedure.\n\nSecond, the probability that a given restriction is not an allowed local view is lower-bounded by the relative distance to the code,\n\\begin{align}\n  \\text{Pr}_S (x|_S\\text{ not allowed local view}) \\geq \\frac{R}{n} D(x,C)~,\n\\end{align}\nwhere \\(D(x,C)\\) is the Hamming distance between \\(x\\) and the closest codeword to \\(x\\). This condition ensures that strings \\(x\\) can be deemed to be not in the codespace with high probability, i.e., with probability increasing as \\(x\\) gets farther from the code.\n","notes":["LTCs first appeared implicitly in works on probabilistically checkable proofs (PCPs) \\cite{doi:10.1016/0022-0000(93)90044-W,doi:10.1007/BF01200056,doi:10.1145/146585.146605,doi:10.1145/103418.103428,doi:10.1145/273865.273901,doi:10.1145/278298.278306}; see Ref. \\cite{doi:10.1007/978-3-642-16367-8_6} for a review."],"relations":{"parents":[{"code_id":"block"}],"cousins":[{"code_id":"qltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-27"}]},"_zoodb":{"id":"ltc","source_file_path":"codes/classical/properties/ltc/ltc.yml","source_file_modification_token":1683723710990.0244}},"random":{"code_id":"random","name":"Random code","introduced":"\\cite{doi:10.1002/j.1538-7305.1948.tb01338.x}","description":"Code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes, to codes whose multi-step construction is deterministic with the exception of a single step.\n\nTypically, random codes are selected with uniform distribution from some ensemble of codes. For example, a random binary code is a set of \\(2^{K}\\) codewords with length \\(N\\) chosen uniformly from the ensemble of all \\(2^N\\) bit-strings. Each bit in the codeword is randomly chosen between 0 and 1 with equal probability. For another example, a random binary linear code is generated from a random chosen \\(K\\) generators of length \\(N\\), where each bit of the generators is randomly chosen between 0 and 1 with equal probability. Equivalently, a random binary linear code is defined by a randomly generated \\(K\\) by \\(N\\) generator matrix, where each entry is randomly chosen between 0 and 1 with equal probability.\n\nIn both of the above random code constructions, the ensemble size scales exponentially with \\(N\\). A common convention is to think of the resulting code constructions as effectively explicit (as opposed to random) in cases where the ensemble size is independent of \\(N\\) or even when the size scales polynomially with \\(N\\).\n","features":{"rate":"Typical random codes (TRC) or typical random linear codes (TLC) refer to codes in the respective ensemble that satisfy a certain minimum distance. The relative fraction of typical codes in the ensemble approaches one as \\(N\\) goes to infinity \\cite{doi:10.1002/j.1538-7305.1948.tb01338.x} (see also Ref. \\cite{doi:10.1109/TIT.2002.800480}). Asymptotically, given distance \\(d\\), the maximum rate for a TRC is given by \\(R=\\frac{1}{2}R_{GV}(\\delta)\\) where \\(R_{GV}\\) is the Gilbert–Varshamov (GV) bound \\(R_{GV}=1-h(\\delta)\\), and \\(h(\\delta)=h(\\frac{d}{n})\\) is the binary entropy function. The maximum rate for a TLC is given by \\(R=R_{GV}(d)\\), meaning that TLCs achieve the asymoptic GV bound.","decoders":["Ball-collision decoding \\cite{doi:10.1007/978-3-642-22792-9_42}.","Information set decoding (ISD) \\cite{doi:10.1007/978-3-642-29011-4_31} and Finiasz and Sendrier (FS-ISD) decoding \\cite{doi:10.1007/978-3-642-10366-7_6}."]},"realizations":["Distributed storage systems \\cite{doi:10.1109/TPDS.2008.251}.","Classical and quantum cryptography based on the learning-with-errors problem, which is related to decoding a random linear code \\cite{doi:10.1145/1568318.1568324}."],"notes":["Shannon's pioneering work \\cite{doi:10.1002/j.1538-7305.1948.tb01338.x} analyzes the distance distribution of the code given a rate. Given \\(N\\) and the rate \\(R\\), the minimum distance of a TRC is given by the GV bound \\(d=N\\delta_{GV}(2R)\\), where \\(\\delta_{GV} = h^{-1}(1-R)\\), \\(0\\le R \\le 1\\), and \\(\\delta_{GV}(x)=0\\) for all other \\(R\\). For a TLC, the minimum distance is given by \\(d=N\\delta_{GV}(R)\\)."],"relations":{"parents":[{"code_id":"ecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-26"},{"user_id":"XiaoXiao","date":"2022-03-26"}]},"_zoodb":{"id":"random","source_file_path":"codes/classical/properties/random.yml","source_file_modification_token":1672500309958.8086}},"ag":{"code_id":"ag","physical":"q-ary_digits","logical":"q-ary_digits","name":"Algebraic-geometry (AG) code","short_name":"AG","introduced":"\\cite{manual:{V. D. Goppa, “Codes Associated with Divisors”, Probl. Peredachi Inf., 13:1 (1977), 33–39; Problems Inform. Transmission, 13:1 (1977), 22–27},manual:{V. D. Goppa, “Codes on algebraic curves”, Dokl. Akad. Nauk SSSR, 259:6 (1981), 1289–1290},manual:{V. D. Goppa, “Algebraico-geometric codes”, Izv. Akad. Nauk SSSR Ser. Mat., 46:4 (1982), 762–781; Izv. Math., 21:1 (1983), 75–91}}","description":"Binary or \\(q\\)-ary code constructed from an algebraic curve of some genus over a finite field via the evaluation construction, the residue construction, or more general constructions that yield nonlinear codes. Linear AG codes from the first two constructions are also called \\textit{geometric Goppa codes}.\n\nIn alternative conventions (not used here), AG codes are restricted to be linear and/or include \\hyperref[code:evaluation_varieties]{evaluation} codes defined using algebraic varieties more general than curves.\n","features":{"rate":"Several sequences of linear AG codes beat the Gilbert-Varshamov bound and/or are asymptotically good \\cite{doi:10.1007/BF01884295,doi:10.1006/jnth.1996.0147} (see Ref. \\cite{preset:HPAlgCodes} for details). The rate of any linear AG code satisfies \\begin{align} \\frac{k}{n} \\geq 1 - \\frac{d}{n} - \\frac{1}{\\sqrt{q}-1}~, \\end{align} which comes from the Drinfeld-Vladut bound \\cite{manual:{S. G. Vlăduţ, V. G. Drinfeld, “Number of points of an algebraic curve”, Funktsional. Anal. i Prilozhen., 17:1 (1983), 68–69; Funct. Anal. Appl., 17:1 (1983), 53–54}}. Nonlinear AG codes can outperform this bound."},"notes":["See book by Goppa \\cite{doi:10.1007/978-94-015-6870-8}."],"relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"}],"cousins":[{"code_id":"mds","detail":"Near MDS \\([n,k,d]_{GF(p^m)}\\) AG codes exist when \\(n,p,m\\) satisfy certain relations according to the Tsfasman-Vladut bound \\cite{doi:10.1007/978-94-011-3810-9,doi:10.1016/S0012-365X(99)00183-1}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"},{"user_id":"VictorVAlbert","date":"2022-03-21"}]},"_zoodb":{"id":"ag","source_file_path":"codes/classical/q-ary_digits/ag/ag.yml","source_file_modification_token":1678631058718.0037}},"evaluation":{"code_id":"evaluation","physical":"q-ary_digits","logical":"q-ary_digits","name":"Evaluation AG code","description":"Also called a \\textit{function code}. Evaluation code over \\(GF(q)\\) on a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) whose corresponding vector space \\(L\\) of functions \\(f\\) consists of certain polynomials or rational functions. Codewords are evaluations of all functions at the specified points,\n\\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align}\nThe code is denoted as \\(C_L({\\cal X},{\\cal P},D)\\), where the \\textit{divisor} \\(D\\) (of degree less than \\(n\\)) determines which rational functions to use by prescribing features associated with their zeroes and poles. The original motivation for evaluation codes, which are generalizations of RS codes that expand both the types of functions used as well as the available evaluation points, was to increase code length while maintaining good distance and size.\n\nThe algebraic curve \\(\\cal X\\) used for this construction is the set of zeroes of a nontrivial polynomial that is both smooth and irreducible over any field extension of \\(GF(q)\\). The curve can be defined over affine space or projective space, which contains the affine coordinates as a subset and which can yield an increase in length.\nIf evaluations are made over projective coordinates, then the codewords are evaluations of homogeneous polynomials, and there are relations between such polynomials with polynomials over affine space. See Refs. \\cite{preset:HPAlgCodes,doi:10.1007/978-3-319-51103-0} for more details.\n\nIn the case of polynomial functions \\(f\\), evaluation AG codes reduce to \\hyperref[code:evaluation_polynomial]{polynomial evaluation} codes on algebraic curves. In the general case of rational functions, which are ratios of two polynomials, one can select such features for both the numerator and denominator polynomials. Zeroes of the denominator polynomial are called poles of the rational function, and their multiplicities correspond to orders of the poles. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of functions defined using the curve \\(\\cal X\\) and the divisor is the \\textit{Riemann-Roch space} \\(L=L(D)\\) \\cite[pg. 313]{preset:HKSag}.\n","protection":"Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) \\cite[Thm. 15.3.12]{preset:HKSag}. The order or Feng-Rao bound, a generalization of the shift bound for cyclic codes, gives a lower bound on the distance of evaluation AG codes \\cite{doi:10.1109/18.179340,doi:10.1515/9783110811056.155,doi:10.1016/j.ffa.2006.09.006}. Connection to semigroups yields another bound \\cite{doi:10.1109/18.333893,preset:HPAlgCodes}.","features":{"decoders":["Generalization of plane-curve decoder \\cite{doi:10.1109/18.57204,manual:{V. Yu. Krachkovskii, \"Decoding of codes on algebraic curves,\" (in Russian), Conference Odessa, 1988.}}. Another decoder \\cite{doi:10.1109/18.165441} was later showed to be equivalent in Ref. \\cite{doi:10.1007/BFb0087989}. Application of several algorthims in parallel can be used to decode up to half the minimum distance \\cite{doi:10.1109/18.45279,doi:10.1109/18.59945}. Computational procedure implementing these decoders is based on an extension of the Berlekamp-Massey algorithm by Sakata \\cite{doi:10.1016/S0747-7171(88)80033-6,doi:10.1016/0890-5401(90)90039-K,doi:10.1109/18.86974}.","Decoder based on majority voting of unknown syndromes \\cite{doi:10.1109/18.179340} decodes up to half of the minimum distance \\cite{doi:10.1109/18.256485}.","List decoders generalizing Sudan's RS decoder by Shokrollahi-Wasserman \\cite{doi:10.1109/18.748993} and Guruswami-Sudan \\cite{doi:10.1109/SFCS.1998.743426}."]},"notes":["See Refs. \\cite{preset:HPAlgCodes,doi:10.1109/18.476214,doi:10.1142/9789812794017_0002,preset:HKSag,doi:10.1017/CBO9780511543401} for surveys and overviews of decoders."],"relations":{"parents":[{"code_id":"evaluation_varieties","detail":"Evaluation AG codes are evaluation codes of rational functions \\(f\\) for which \\(\\cal X\\) is an algebraic curve, i.e., an algebraic variety of dimension one \\cite{preset:HPAlgCodes}."},{"code_id":"ag"}],"cousins":[{"code_id":"q-ary_linear","detail":"The degree of the divisor for evaluation AG codes is restricted to be less than \\(n\\). When there is no restriction, any \\(q\\)-ary linear code can be formulated as an evaluation AG code \\cite{doi:10.1109/18.79915}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"},{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"evaluation","source_file_path":"codes/classical/q-ary_digits/ag/evaluation.yml","source_file_modification_token":1682250129447.8044}},"elliptic":{"code_id":"elliptic","physical":"q-ary_digits","logical":"q-ary_digits","name":"Elliptic code","description":"Evaluation AG code of rational functions evaluated on points lying on an elliptic curve, i.e., a curve of genus one.\n","relations":{"parents":[{"code_id":"evaluation","detail":"Elliptic codes are evaluation AG codes with \\(\\cal X\\) being an elliptic curve, i.e., curve of genus one (\\cite{doi:10.1007/978-94-011-3810-9}, Ch. 3.2; \\cite{preset:HPAlgCodes})."}],"cousins":[{"code_id":"mds","detail":"Elliptic codes can be MDS \\cite[Ex. 15.5.3]{preset:HKSag}\\cite[pg. 310]{doi:10.1007/978-94-011-3810-9}\\cite[Sec. 4.4.2]{preset:TVNAlgCodes}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-20"}]},"_zoodb":{"id":"elliptic","source_file_path":"codes/classical/q-ary_digits/ag/evaluationAG/elliptic.yml","source_file_modification_token":1682250129447.9968}},"hermitian":{"code_id":"hermitian","physical":"q-ary_digits","logical":"q-ary_digits","name":"Hermitian code","introduced":"\\cite{doi:10.1007/BF01228251,doi:10.1109/TIT.1987.1057327}","description":"Evaluation AG code of rational functions evaluated on points lying on a Hermitian curve \\(H(x,y) = x^{q+1}  + y^{q+1} - 1\\) over \\(\\mathbb{F}_q = GF(q)\\) in either affine or projective space. Hermitian codes directly improve over RS codes in the sense that RS codes have length at most \\(q\\) while Hermitian codes have length \\(q^3 + 1\\).\n\nHermitian codes of polynomials of total degree at most \\(D\\) can come in affine and epicyclic flavours, depending on whether the evaluations are over the affine plane or the bicyclic plane. The affine codes have length \\(q^3 - q\\) while epicyclic codes have length \\((q-2)(q+1)^2\\). More precisely, fix \\(r, D\\) and let\n\\begin{align}\n  M_D = \\left\\{f(x,y,z) = \\sum_{i+j \\leq D = D}a_{i,j}x^{i}y^{j}z^{D - (i+j)}\\right\\}\n\\end{align}\nbe the message space of degree-\\(D\\) polynomials and\n\\begin{align}\n  S = \\{(x:y:z) \\in PG(2,q) \\mid H(x:y:z) = 0 \\}~,\n\\end{align}\nwhere \\(H(x:y:z) = x^{q+1} + y^{q+1} - z^{q+1}\\) is the homogenized Hermitian curve over the projective plane. The Hermitian code \\( C \\) over is\n\\begin{align}\nC = \\{(f(\\alpha_i))_{\\alpha_i \\in S}, \\: f \\in M_D \\}~.\n\\end{align}\n\nThe form \\(H(u,v,w) = u^{q+1} + v^{q+1} - w^{q+1}\\) is the \\textit{Fermat} version of the Hermitian curve.\nSubstituting \\(u = x+z\\), \\(v = x+y\\), and \\(w = x+y+z \\) yields \\(H(x,y,z) = x^{q+1} - y^{q}z - yz^{q} \\), the \\textit{Stichtenoth} version of the curve.\nIn affine coordinates, the Stichtenoth form of the curve is \\begin{align}\n  f(x,y) = x^{q+1} - y^{q} - y = N(x) - \\text{tr}(y)~,\n\\end{align}\nwhere \\(N(x) := x^{(q^{n}-1)/(q-1)}\\) and \\(\\text{tr} := 1 + x^{q} + \\ldots + x^{q^n}\\) are the field norm and trace of \\(GF(F_{q^n}\\), respectively.\nThe Fermat\nversion can be written as \\(H(u,v,w) = u\\overline{u} + v\\overline{v} - w\\overline{w}\\), where the conjugation map\n\\(\\overline{u} = u^{q}\\) is an isomorphism of \\(\\mathbb{F}_q \\). In fact, when the field of evaluations \\(\\mathbb{F}_{q^2}\\) is viewed as a quadratic extension of\n\\(\\mathbb{F}_q\\) then the conjugation map is an \\(\\mathbb{F}_q\\)-isomorphism that permutes the roots of the quadratic irreducible polynomial\nused to generate \\(\\mathbb{F}_{q^2}\\) from \\( \\mathbb{F}_q[x]\\).\n","protection":"Distance determined by properties of the Hermitian curve, the underlying field, and the functions used \\cite{doi:10.1007/BFb0087995}; see Ref. \\cite{preset:HPAlgCodes}, Sec. 5.3, for an example. For evaluations of polynomials up to degree \\(D\\), the Hermitian code protects against at least \\(n - (q+1)D\\) errors whenever \\(D < q + 1 \\). If \\(D \\geq q+1 \\), the Hermitian code protects against at least \\(n-k - \\frac{q(q-1)}{2} + 1\\) errors.","features":{"rate":"For polynomial evaluations up to degree \\(D\\): if \\(D < q + 1 \\), \\(k = \\frac{(D+1)(D+2)}{2}\\), and if \\(D \\geq q + 1 \\), \\(k = (q+1)D - \\frac{q(q-1)}{2} + 1 \\).\n","decoders":["Unique decoding using syndromes and error locator ideals for polynomial evaluations. Note that Hermitian codes are linear codes so we can compute the syndrome of a received vector. Moreover, akin to the error-locator ideals found in decoding Reed-Solomon codes, for the multivariate case we must define an error locator ideal \\(\\Lambda \\) such that the variety of this ideal over \\(\\mathbb{F}^{2}_{q}\\) is exactly the set of errors. The Sakata algorithm uses these two ingredients to get a unique decoding procedure \\cite{doi:10.1016/S0747-7171(88)80033-6}."]},"relations":{"parents":[{"code_id":"generalized_reed_solomon","detail":"Hermitian codes are concatenated GRS codes \\cite{doi:10.1007/BF00124208}."},{"code_id":"evaluation","detail":"Hermitian codes are evaluation AG codes with \\(\\cal X\\) being a Hermitian curve (\\cite{preset:HPAlgCodes}, Ex. 2.74). This curve is maximal, meaning that Hermitian codes are evaluation AG codes with maximum possible length given a fixed genus."}],"cousins":[{"code_id":"group","detail":"Some Hermitian codes are group-algebra codes \\cite{manual:{Hansen, Johan P. Group codes on algebraic curves. Universität zu Göttingen. SFB Geometrie und Analysis, 1987.}}\\cite[Remark 16.4.14]{preset:HKSalgebra}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"},{"user_id":"ShashankSule","date":"2022-04-03"}]},"_zoodb":{"id":"hermitian","source_file_path":"codes/classical/q-ary_digits/ag/evaluationAG/hermitian.yml","source_file_modification_token":1682250129448.1353}},"klein_quartic":{"code_id":"klein_quartic","physical":"q-ary_digits","logical":"q-ary_digits","name":"Klein-quartic code","introduced":"\\cite{doi:10.1109/TIT.1987.1057365}","description":"Evaluation AG code over \\(GF(8)\\) of rational functions evaluated on points lying in the Klein quartic, which is defined by the equation \\(x^3 y + y^3 z + z^3 x = 0\\) (\\cite{preset:HPAlgCodes}, Ex. 2.75).\n","protection":"Dimension \\(k=8\\) and distance \\(d \\geq 13\\). Concatenation with the \\([4,3,2]\\) single parity check code, conversion to a binary code by expressing \\(GF(8)\\) elements as vectors over \\(GF(2)\\), and puncturing yields a \\([91,24,25]\\) binary code that held the world record for codes of length 91 \\cite{manual:{A. M. Barg, G. L. Katsman, M. A. Tsfasman, “Algebraic-Geometric Codes from Curves of Small Genus”, Probl. Peredachi Inf., 23:1 (1987), 42–46; Problems Inform. Transmission, 23:1 (1987), 34–38}}.","relations":{"parents":[{"code_id":"evaluation","detail":"Klein-quartic codes are evaluation AG codes with \\(\\cal X\\) being the Klein quartic (\\cite{preset:HPAlgCodes}, Ex. 2.75)."}],"cousins":[{"code_id":"group","detail":"Some Klein-quartic codes are group-algebra codes \\cite[Remark 16.4.14]{preset:HKSalgebra}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-03"}]},"_zoodb":{"id":"klein_quartic","source_file_path":"codes/classical/q-ary_digits/ag/evaluationAG/klein_quartic.yml","source_file_modification_token":1682250129448.235}},"plane_curve":{"code_id":"plane_curve","physical":"q-ary_digits","logical":"q-ary_digits","name":"Plane-curve code","introduced":"\\cite{doi:10.1109/18.32157}","description":"Evaluation AG code of bivariate polynomials of some finite maximum degree, evaluated at points lying on an affine plane curve.\n","protection":"Bezout's theorem yields parameters \\([n,k,d]\\), which depend on the polynomial used to define the plane curve as well as the maximum degree of the polynomials used for evaluation (\\cite{preset:HPAlgCodes}, pg. 883). Distance bounds can be derived from how the plane curve is embedded in the ambient projective space (\\cite{arXiv:0905.2345}, Thm. 4.1).","features":{"decoders":["Generalization of the Peterson algorithm for BCH codes \\cite{doi:10.1109/18.32157}."]},"relations":{"parents":[{"code_id":"evaluation","detail":"Plane-curve codes are evaluation AG codes of bivariate polynomials with \\(\\cal X\\) being an affine plane curve (\\cite{preset:HPAlgCodes}, Thm. 2.27)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-05"}]},"_zoodb":{"id":"plane_curve","source_file_path":"codes/classical/q-ary_digits/ag/evaluationAG/plane_curve.yml","source_file_modification_token":1678631058718.7368}},"suzuki":{"code_id":"suzuki","physical":"q-ary_digits","logical":"q-ary_digits","name":"Suzuki-curve code","introduced":"\\cite{doi:10.1007/BF01810849}","description":"Evaluation AG code of rational functions evaluated on points lying on a Suzuki curve.\n","relations":{"parents":[{"code_id":"evaluation","detail":"Suzuki-curve codes are evaluation AG codes with \\(\\cal X\\) being a Suzuki curve."}],"cousins":[{"code_id":"group","detail":"Some Suzuki-curve codes are group-algebra codes \\cite[Remark 16.4.14]{preset:HKSalgebra}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"},{"user_id":"ShashankSule","date":"2022-04-03"}]},"_zoodb":{"id":"suzuki","source_file_path":"codes/classical/q-ary_digits/ag/evaluationAG/suzuki.yml","source_file_modification_token":1682250129448.3257}},"evaluation_polynomial":{"code_id":"evaluation_polynomial","physical":"q-ary_digits","logical":"q-ary_digits","name":"Polynomial evaluation code","description":"Evaluation code of polynomials at points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) on an algebraic variety \\(\\cal X\\). Codewords\n\\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right)\n\\end{align}\nare evaluations of a linear space \\(L\\) of polynomials \\(f\\). If the space is taken to be all polynomials up to some degree, the code is called a \\textit{Reed-Muller-type code} or \\textit{RM-type code} of that degree.\n\nOne can specify the space \\(L\\) by the number of variables input into the polynomials as well as the polynomials' maximum degree. One can additionally select only polynomials that have zeroes at certain points with certain multiplicities. A bookkeeping device for this data is the divisor \\(D\\), and the corresponding vector space of polynomials defined using the variety \\(\\cal X\\) and the divisor is the \\textit{Riemann-Roch space} \\(L=L(D)\\) \\cite[pg. 313]{preset:HKSag}.\n","notes":["See Refs. \\cite{arxiv:0802.2349,arxiv:1907.13217} for reviews."],"relations":{"parents":[{"code_id":"evaluation_varieties","detail":"Polynomial evaluation codes are evaluation codes of polynomials \\(f\\) for which \\(\\cal X\\) is an algebraic variety."}],"cousins":[{"code_id":"evaluation","detail":"Evaluation AG codes are evaluation codes on algebraic curves. Polynomial evaluation codes are evaluation codes of polynomials. Evaluation AG codes of polynomials are equivalent to polynomial evaluation codes on algebraic curves."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"}]},"_zoodb":{"id":"evaluation_polynomial","source_file_path":"codes/classical/q-ary_digits/ag/evaluation_polynomial.yml","source_file_modification_token":1682250129448.4126}},"evaluation_varieties":{"code_id":"evaluation_varieties","physical":"q-ary_digits","logical":"q-ary_digits","name":"Evaluation code","introduced":"\\cite{doi:10.1007/BF02249124,doi:10.1007/978-94-011-3810-9}","description":"Code whose codewords are evaluations of functions at certain fixed points. Code properties can be inferred from the structure of the functions and the underlying geometric object containing the points, often using results from algebraic geometry.\n\nLet \\(\\cal{X}\\) be a geometric object that contains a subset \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right) \\) consisting of \\(n\\) points \\(P_j\\). Let \\(L\\) be a vector space over \\(GF(q)\\) of functions \\(f\\) that take values in \\(GF(q)\\). Each \\(f\\in L\\) yields a codeword of an evaluation code \\(C_L({\\cal X},{\\cal P})\\) of the form\n\\begin{align}\n  \\left( f(P_1), f(P_2), \\cdots, f(P_n) \\right) \\quad\\quad\\forall f\\in L~.\n\\end{align}\nThis is a linear binary or \\(q\\)-ary code since the functions \\(f\\) take values in \\(GF(q)\\) and form a vector space.\n\nExamples of geometric objects \\(\\cal X\\) include affine or projective spaces over \\(GF(q)\\) as well as subsets of those spaces determined by some constraints. Prominent subsets are \\textit{algebraic varieties}, i.e., sets of solutions of systems of polynomial equations in either affine or projective space. The functions \\(f\\) are typically polynomials or rational functions.\n","protection":"Properties of \\(\\cal X\\) can be used to bound the code dimension \\(k\\) and distance \\(d\\). The order or Feng-Rao bound gives a lower bound on the distance of evaluation codes \\cite{doi:10.1142/9789812794017_0004,doi:10.1109/18.335973,doi:10.1109/18.179340,doi:10.1023/A:1008274212057,preset:HPAlgCodes}; see Ref. \\cite{preset:HPAlgCodes}, Ch. 4 and Ref. \\cite{arxiv:0802.2349} for more discussion.","notes":["See books \\cite{preset:TVNAlgCodes,preset:HPAlgCodes,doi:10.1007/978-3-540-76878-4,doi:10.1007/978-94-015-6870-8,manual:{Lachaud, G. (1985). Les codes géométriques de Goppa. Sem. Bourbaki, 37, 1984-85.}} for more information."],"relations":{"parents":[{"code_id":"q-ary_linear","detail":"Evaluation codes are defined using polynomial or rational functions evaluated on a subset of affine or projective space. Given access to more general structures (i.e., morphisms of algebras), any \\(q\\)-ary linear code can be formulated as an evaluation code (\\cite{preset:HPAlgCodes}, Sec. 4.1; \\cite{preset:TVNAlgCodes}, Prop. 1.1.4)."}],"cousins":[{"code_id":"ag","detail":"Evaluation codes on varieties can also be considered AG codes since they use algebraic geometry in quantifying code bounds. However, early AG constructions all used only one-dimensional varieties, i.e., algebraic curves."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-12"}]},"_zoodb":{"id":"evaluation_varieties","source_file_path":"codes/classical/q-ary_digits/ag/evaluation_varieties.yml","source_file_modification_token":1678631058718.9456}},"generalized_reed_muller":{"code_id":"generalized_reed_muller","physical":"q-ary_digits","logical":"q-ary_digits","name":"Generalized RM (GRM) code","short_name":"GRM","introduced":"\\cite{doi:10.1109/TIT.1968.1054127,doi:10.1109/TIT.1968.1054128,doi:10.1016/S0019-9958(70)90214-7}","description":"Reed-Muller code GRM\\(_q(r,m)\\) of length \\(n=q^m\\) over \\(GF(q)\\) with \\(0\\leq r\\leq m(q-1)\\). Its codewords are evaluations of the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables at a set of distinct points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) in \\(GF(q)\\).\n\nSince \\(\\beta^q=\\beta\\) for any \\(\\beta\\in GF(q)\\), the above definition is not injective. Replacing each factor in each polynomial as \\(x^q\\to x\\), the above set reduces to the set of all degree-\\(\\leq r\\) polynomials in \\(m\\) variables such that no term has an exponent \\(q\\) or higher on any variable.\n","protection":"Code parameters for specific \\(m,r\\) are given in Ref. \\cite{doi:10.1007/978-94-011-3810-9}, pg. 46.","features":{"rate":"GRM codes achieve capacity on sufficiently symmetric non-binary channels \\cite{arxiv:2305.07779}."},"notes":["See books \\cite{doi:10.1017/CBO9781316529836,doi:10.1017/CBO9780511807077,manual:{E. F. Assmus, Jr. and J. D. Key, “Polynomial codes and finite geometries,” in Handbook of Coding Theory, eds. V. S. Pless and W. C. Huffman. Amsterdam: Elsevier, 1998, pp. 1269–1343.}} for details of GRM codes."],"relations":{"parents":[{"code_id":"evaluation_polynomial","detail":"GRM (PRM) codes are multivariate polynomial evaluation codes with \\(\\cal X\\) being the entire \\(m\\)-dimensional affine (projective) space over \\(GF(q)\\) (\\cite{doi:10.1007/978-94-011-3810-9}, pgs. 44-46; \\cite{doi:10.1007/BF02249124,preset:HPAlgCodes})."},{"code_id":"matrix_product","detail":"Applying a special case of the matrix-product procedure yields GRM codes \\cite{doi:10.1007/PL00004226}."},{"code_id":"ldc","detail":"GRM codes are locally decodable \\cite{doi:10.1561/0400000030}."}],"cousins":[{"code_id":"q-ary_cyclic","detail":"GRM codes with nonzero evaluation points are cyclic (\\cite{doi:10.1007/978-94-011-3810-9}, pg. 52)."},{"code_id":"q-ary_ltc","detail":"GRM codes for \\(r<q\\) can be LTCs in the low- \\cite{doi:10.1145/103418.103428,doi:10.1145/278298.278306} and high-error \\cite{doi:10.1145/258533.258641,doi:10.1145/258533.258642} regimes."},{"code_id":"group","detail":"GRM codes over prime-power fields are group-algebra codes \\cite{doi:10.1007/BF01072842,manual:{Charpin, Pascale. Codes idéaux de certaines algèbres modulaires. Diss. 1982.},doi:10.1007/BF00141972}\\cite[Ex. 16.4.11]{preset:HKSalgebra}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-20"}]},"_zoodb":{"id":"generalized_reed_muller","source_file_path":"codes/classical/q-ary_digits/ag/generalized_reed_muller.yml","source_file_modification_token":1687727505566.9766}},"nonlinear_ag":{"code_id":"nonlinear_ag","physical":"q-ary_digits","logical":"q-ary_digits","name":"Nonlinear AG code","introduced":"\\cite{arXiv:math/0104115,doi:10.1109/TIT.2003.813559,arXiv:math/0308046,doi:10.1007/978-3-0348-7865-4_18,doi:10.1109/TIT.2005.856977}","description":"Nonlinear \\(q\\)-ary code constructed by evaluating functions on an algebraic curve.\n","features":{"rate":"Certain nonlinear code sequences beat the Tsfasman-Vladut-Zink bound, outperforming linear AG codes."},"relations":{"parents":[{"code_id":"ag"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-04"}]},"_zoodb":{"id":"nonlinear_ag","source_file_path":"codes/classical/q-ary_digits/ag/nonlinear_ag.yml","source_file_modification_token":1678631058719.1602}},"projective_reed_muller":{"code_id":"projective_reed_muller","physical":"q-ary_digits","logical":"q-ary_digits","name":"Projective RM (PRM) code","short_name":"PRM","introduced":"\\cite{doi:10.1016/0012-365X(90)90155-B,doi:10.1109/18.104317}","description":"Reed-Muller code for nonzero points \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) whose leftmost nonzero coordinate is one, corresponding to an evaluation code of polynomials over projective coordinates. PRM codes  PRM\\(_q(r,m)\\) for \\(r<q\\) are injective evaluation codes with parameters \\cite{doi:10.1515/9783110811056.77}\n\\begin{align}\n  \\left[ q^m+q^{m-1}\\cdots +1, {m+r \\choose r},(q+1-r)q^{m-1} \\right]~.\n\\end{align}\n","relations":{"parents":[{"code_id":"generalized_reed_muller"}],"cousins":[{"code_id":"projective","detail":"Nonzero codewords of minimum weight of a \\(r\\)th-order \\(q\\)-ary projective RM code correspond to algebraic hypersurfaces of degree \\(r\\) having the largest number of points in the projective space \\(PG(n,q)\\) \\cite[Thm. 14.3.3]{preset:HKSprojective}."},{"code_id":"griesmer","detail":"PRM codes for \\(r=1\\) attain the Griesmer bound for all \\(m\\) \\cite{arxiv:0802.2349}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"projective_reed_muller","source_file_path":"codes/classical/q-ary_digits/ag/projective_reed_muller.yml","source_file_modification_token":1682250129448.6}},"cartier":{"code_id":"cartier","physical":"q-ary_digits","logical":"q-ary_digits","name":"Cartier code","introduced":"\\cite{arxiv:1206.4728}","description":"Subcode of a certain residue AG code that is constructed using the Cartier operator.","features":{"rate":"Cartier codes share similar asymptotic properties as subfield subcodes of residue AG codes, with both families admitting sequences of codes that achieve the Gilbert-Varshamov bound."},"relations":{"parents":[{"code_id":"residue"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-04"}]},"_zoodb":{"id":"cartier","source_file_path":"codes/classical/q-ary_digits/ag/residueAG/cartier.yml","source_file_modification_token":1678631058719.4636}},"goppa":{"code_id":"goppa","physical":"q-ary_digits","logical":"q-ary_digits","name":"Classical Goppa code","introduced":"\\cite{manual:{V. D. Goppa, \"A new class of linear error-correcting codes\", Probl. Peredach. Inform., vol. 6, no. 3, pp. 24-30, Sept. 1970.},manual:{V. D. Goppa, \"Rational representation of codes and (Lg) codes\", Probl. Peredach. Inform., vol. 7, no. 3, pp. 41-49, Sept. 1971.},doi:10.1109/TIT.1973.1055088}","description":"Let \\( G(x) \\)  be a polynomial describing a projective-plane curve with coefficients from \\( GF(q^m) \\) for some fixed integer \\(m\\). Let \\( L \\) be a finite subset of the extension field \\( GF(q^m) \\)  where \\(q\\) is prime, meaning \\( L  = \\{\\alpha_1, \\cdots, \\alpha_n\\} \\) is a subset of nonzero elements of \\( GF(q^m) \\). A Goppa code \\( \\Gamma(L,G) \\) is an \\([n,k,d]_q\\) linear code consisting of all vectors \\(a = a_1, \\cdots, a_n\\) such that \\( R_a(x) =0 \\) modulo \\(G(x)\\), where \\( R_a(x) = \\sum_{i=1}^n \\frac{a_i}{z - \\alpha_i} \\).\n\nGoppa codes are residue AG codes \\cite[Thm. 15.3.28]{preset:HKSag}. Their duals are evaluation codes that are sometimes called \\textit{geometric Reed Solomon codes} \\cite[Thm. 2.71]{preset:HPAlgCodes}.\n","protection":"The length \\( n = |L| \\) , dimension \\( k \\geq n-mr \\) where \\( r = \\text{deg} G(x) \\), and the minimum distance \\( d \\geq r +1 \\).","features":{"decoders":["Algebraic decoding algorithms \\cite{doi:10.1109/TIT.1975.1055350}. If \\( \\text{deg} G(x) = 2t \\) , then there exists a \\(t\\)-correcting algebraic decoding algorithm for \\( \\Gamma(L,G) \\).","Sugiyama et al. modification of the extended Euclidean algorithm \\cite{doi:10.1016/S0019-9958(75)90090-X,doi:10.1017/CBO9780511606267}.","Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426}.","Binary Goppa codes can be decoded using a RS-based decoder \\cite{manual:{Daniel J. Bernstein, \"Understanding binary-Goppa decoding.\" Cryptology ePrint Archive (2022).}}."]},"realizations":["Initial version of the McEliece public-key cryptosystem \\cite{manual:{R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).},doi:10.1007/BF00173300} and its variation by Niederreiter \\cite{manual:{H. Niederreiter (1986). \\emph{Knapsack-type cryptosystems and algebraic coding theory}. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159–166.}} where the generator matrix is replaced by the parity check matrix. Some of these were proven to be insecure since the public key exposes algebraic structure of code \\cite{doi:10.1515/dma.1992.2.4.439}."],"notes":["GAP function \\href{https://www.gap-system.org/Manuals/pkg/guava/doc/chap5.html#X7EE808BB7D1E487A}{GoppaCode(G,L)} takes in a polynomial \\(G\\) that satisfies the necessary conditions for a Goppa code and a list \\(L\\) that contains elements in \\(GF(q)\\) that are not roots of \\(G\\). It returns a Goppa code."],"relations":{"parents":[{"code_id":"generalized_reed_solomon","detail":"Goppa codes are \\(GF(q)\\)-subfield subcode of the dual of the GRS code over \\(GF(q^m)\\) with evaluation points \\(\\alpha_i\\) and factors \\(v_i=G(\\alpha_i)^{-1}\\) (\\cite{doi:10.1017/CBO9780511807077}, pg. 523; \\cite{preset:HPAlgCodes})."},{"code_id":"cartier","detail":"Goppa codes are Cartier codes from a curve of genus zero \\cite{arxiv:1206.4728}."}],"cousins":[{"code_id":"q-ary_ltc","detail":"Goppa codes are locally testable \\cite{doi:10.1109/SFCS.2005.16}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-21"},{"user_id":"VictorVAlbert","date":"2021-12-15"},{"user_id":"ManasiShingane","date":"2021-12-14"}]},"_zoodb":{"id":"goppa","source_file_path":"codes/classical/q-ary_digits/ag/residueAG/goppa.yml","source_file_modification_token":1682250129448.7026}},"residue":{"code_id":"residue","physical":"q-ary_digits","logical":"q-ary_digits","name":"Residue AG code","description":"Also called a \\textit{differential code}. Linear \\(q\\)-ary code defined using a set of points \\({\\cal P} = \\left( P_1,P_2,\\cdots,P_n \\right)\\) in \\(GF(q)\\) lying on an algebraic curve \\(\\cal X\\) and a linear space \\(\\Omega\\) of certain rational differential forms \\(\\omega\\). Codewords are evaluations of residues of the differential forms in the specified points,\n\\begin{align}\n  \\left(\\text{Res}_{P_{1}}(\\omega),\\text{Res}_{P_{2}}(\\omega),\\cdots,\\text{Res}_{P_{n}}(\\omega)\\right)\\quad\\quad\\forall\\omega\\in\\Omega~.\n\\end{align}\nThe code is denoted as \\(C_{\\Omega}({\\cal X},{\\cal P},D)\\), where the \\textit{divisor} \\(D\\) determines which rational rational differential forms to use.\n","protection":"Riemann-Roch theorem yields code length \\(n\\), dimension \\(k\\), and a lower bound on distance in terms of features of \\(L\\) and genus of the curve \\(\\cal X\\) \\cite[Corr. 15.3.13]{preset:HKSag}. Distance bounds can also be derived from how an algebraic curve \\(\\cal X\\) is embedded in the ambient projective space \\cite{arXiv:0905.2345}.","realizations":["Improvements over the McEliece public-key cryptosystem to linear AG codes on curves of arbitrary genus \\cite{doi:10.1023/A:1027351723034}. Only the subfield subcode proposal remains resilient to attacks \\cite[Sec. 15.7.5.3]{preset:HKSag}.","Algebraic secret-sharing schemes \\cite{doi:10.1007/11818175_31}."],"relations":{"parents":[{"code_id":"evaluation","detail":"Any residue AG code of differential forms can be equivalently stated as an evaluation AG code of functions \\cite[Lemma 15.3.10]{preset:HKSag}\\cite[Thm. 2.72]{preset:HPAlgCodes}. In addition, evaluation and residue AG codes are dual to each other \\cite[pg. 313]{preset:HKSag}\\cite{preset:HPAlgCodes})."},{"code_id":"ag"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"},{"user_id":"VictorVAlbert","date":"2022-03-21"}]},"_zoodb":{"id":"residue","source_file_path":"codes/classical/q-ary_digits/ag/residueAG/residue.yml","source_file_modification_token":1682250129448.792}},"shimura":{"code_id":"shimura","physical":"q-ary_digits","logical":"q-ary_digits","name":"Tsfasman-Vladut-Zink (TVZ) code","short_name":"TVZ","introduced":"\\cite{doi:10.1002/mana.19821090103}","description":"Member of a family of residue AG codes where \\(\\cal X\\) is either a reduction of a Shimura curve or an elliptic curve of varying genus.","features":{"rate":"TVZ codes exceed the asymptotic Gilbert-Varshamov (GV) bound \\cite{doi:10.1002/mana.19821090103} (see also Ref. \\cite{manual:{Y. Ihara. \"Some remarks on the number of rational points of algebraic curves over finite fields.\" J. Fac. Sci. Univ. Tokyo Sect. IA Math., 28:721-724 (1982),1981.}}). Roughly speaking, this breakthrough result implies that AG codes can outperform random codes. Such families of codes are optimal."},"relations":{"parents":[{"code_id":"residue"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-05"}]},"_zoodb":{"id":"shimura","source_file_path":"codes/classical/q-ary_digits/ag/residueAG/shimura.yml","source_file_modification_token":1678631058719.753}},"alternant":{"code_id":"alternant","physical":"q-ary_digits","logical":"q-ary_digits","name":"Alternant code","introduced":"\\cite{doi:10.1016/S0019-9958(74)80005-7}","description":"Given a length-\\(n\\) GRS code \\(C\\) over \\(GF(q^m)\\), an alternant code is the \\(GF(q)\\)-subfield subcode of the dual of \\(C\\).","features":{"decoders":["Variation of the Berlekamp-Welch algorithm \\cite{doi:10.1109/TIT.1977.1055730}.","Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426}."]},"notes":["See \\cite[Ch. 12]{preset:MacSlo} for more details."],"relations":{"parents":[{"code_id":"generalized_reed_solomon","detail":"Alternant codes are subfield subcodes of GRS codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-02"},{"user_id":"khalilguy","date":"2022-01-02"},{"user_id":"VictorVAlbert","date":"2022-03-24"},{"user_id":"ManasiShingane","date":"2021-12-05"}]},"_zoodb":{"id":"alternant","source_file_path":"codes/classical/q-ary_digits/ag/rs/alternant.yml","source_file_modification_token":1678631058719.8562}},"extended_reed_solomon":{"code_id":"extended_reed_solomon","physical":"q-ary_digits","logical":"q-ary_digits","name":"Extended GRS code","description":"A GRS code with an additional parity-check coordinate with corresponding evaluation point of zero. In other words, an \\([n+1,k,n-k+2]_q\\) GRS code whose polynomials are evaluated at the points \\((\\alpha_1,\\cdots,\\alpha_n,0)\\). The case when \\(n=q-1\\), multipliers \\(v_i=1\\), and \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is an \\textit{extended narrow-sense RS code}.\n\nAn \\([q-1,k,q-k]_q\\) narrow-sense RS code can be extended twice by adding two evaluation points (of which one can be zero) to yield a \\([q+1,k,q-k+2]_q\\) \\textit{doubly extended narrow-sense RS code}.\n","notes":["See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Extended Reed–Solomon Code.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html}}."],"relations":{"parents":[{"code_id":"generalized_reed_solomon","detail":"Extended GRS codes can be thought of as GRS codes that include an evaluation point of zero."},{"code_id":"generalized_reed_muller","detail":"GRM codes for univariate polynomials (\\(m=1\\)) reduce to extended RS codes \\cite{arxiv:0802.2349}."}],"cousins":[{"code_id":"hyperoval","detail":"Columns of parity-check matrices of triply extended RS codes consist of points of a hyperoval \\cite[Prop. 17.5]{doi:10.1201/9781315371993}."},{"code_id":"mds","detail":"A GRS code can be extended to an MDS code (\\cite{doi:10.1017/CBO9780511807077}, Thm. 5.3.4). Extended and doubly extended narrow-sense RS codes are MDS (\\cite{doi:10.1017/CBO9780511807077}, Thms. 5.3.2 and 5.3.4), and there is an equivalence between the two for odd prime \\(q\\) \\cite{doi:10.4171/JEMS/316}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"}]},"_zoodb":{"id":"extended_reed_solomon","source_file_path":"codes/classical/q-ary_digits/ag/rs/extended_reed_solomon.yml","source_file_modification_token":1683723710990.337}},"folded_reed_solomon":{"code_id":"folded_reed_solomon","physical":"q-ary_digits","logical":"q-ary_digits","name":"Folded RS (FRS) code","short_name":"FRS","introduced":"\\cite{doi:10.1109/TIT.2003.819333}","description":"A linear \\([n/m,k]_{q^m}\\) code that is a modification of an \\([n,k]_q\\) RS code such that evaluations are grouped to yield a code with smaller length. In this case, the evaluation points are all powers of a generating field element \\(\\gamma\\), \\(\\alpha_i=\\gamma^i\\). Each codeword \\(\\mu\\) of an \\(m\\)-folded RS code is a string of \\(n/m\\) symbols, with each symbol being a string of values of a polynomial \\(f_\\mu\\) at consecutive powers of \\(\\gamma\\),\n\\begin{align}\n\\begin{split}\n  \\mu\\to&\\Big(\\left(f_{\\mu}(\\alpha^{0}),\\cdots,f_{\\mu}(\\alpha^{m-1})\\right),\\left(f_{\\mu}(\\alpha^{m}),\\cdots,f_{\\mu}(\\alpha^{2m-1})\\right)\\cdots\\\\&\\cdots,\\left(f_{\\mu}(\\alpha^{n-m}),\\cdots,f_{\\mu}(\\alpha^{n-1})\\right)\\Big)~.\n\\end{split}\n\\end{align}\n","features":{"decoders":["Guruswami and Rudra \\cite{arXiv:cs/0511072,manual:{Atri Rudra. List Decoding and Property Testing of Error Correcting Codes. PhD thesis, University of Washington, 8 2007.}} achieved list-decoding up to \\(1-\\frac{k}{n}-\\epsilon\\) fraction of errors using the Parvaresh-Vardy algorithm \\cite{doi:10.1109/SFCS.2005.29}; see Ref. \\cite{arXiv:1106.0436} for a randomized construction.","Folded RS codes, concatenated with suitable inner codes, can be efficiently list-decoded up to the Blokh-Zyablov bound \\cite{arXiv:cs/0511072,doi:10.1109/TIT.2008.2008124}."]},"notes":["See the book \\cite{preset:GRS} for an introduction to FRS codes.","A class of FRS codes can be used in the Yamakawa-Zhandry quantum algorithm \\cite{arxiv:2204.02063}."],"relations":{"parents":[{"code_id":"q-ary_linear","detail":"Folding an RS code yields a code that is no longer linear over \\(GF(q)\\) but is linear over \\(GF(q^m)\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-16"},{"user_id":"VictorVAlbert","date":"2022-03-21"}]},"_zoodb":{"id":"folded_reed_solomon","source_file_path":"codes/classical/q-ary_digits/ag/rs/folded_reed_solomon.yml","source_file_modification_token":1678631058719.9834}},"generalized_reed_solomon":{"code_id":"generalized_reed_solomon","physical":"q-ary_digits","logical":"q-ary_digits","name":"Generalized RS (GRS) code","short_name":"GRS","description":"An \\([n,k,n-k+1]_q\\) linear code that is a modification of the RS code where codeword polynomials are multiplied by additional prefactors. Each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\), multiplied by a corresponding nonzero factor \\(v_i \\in GF(q)\\),\n\\begin{align}\n  \\mu\\to\\left( v_{1}f_{\\mu}\\left(\\alpha_{1}\\right),v_{2}f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,v_{n}f_{\\mu}\\left(\\alpha_{n}\\right)\\right)~.\n\\end{align}\n","protection":"The code can detect \\(n-k\\) errors, and can correct  errors \\( \\left\\lfloor (n-k)/2\\right\\rfloor  \\) errors.","features":{"decoders":["The decoding process of GRS codes reduces to the solution of a polynomial congruence equation, usually referred to as the key equation. Decoding schemes are based on applications of the Euclid algorithm to solve the key equation.","Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1968.1054109,doi:10.1109/TIT.1969.1054260,preset:Berlekamp}.","Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426} and modification by Koetter-Vardy for soft-decision decoding \\cite{doi:10.1109/TIT.2003.819332}."]},"realizations":["Commonly used in mass storage systems such as CDs, DVDs, QR codes etc.","Various cloud storage systems \\cite{arxiv:1612.01361}.","Public-key cryptosystems generalizing those that used Goppa codes \\cite{manual:{R. J. McEliece, A public-key cryptosystem based on algebraic coding theory, Technical report, Jet Propulsion Lab. DSN Progress Report (1978).},doi:10.1007/BF00173300,manual:{H. Niederreiter (1986). \\emph{Knapsack-type cryptosystems and algebraic coding theory}. Problems of Control and Information Theory. Problemy Upravlenija I Teorii Informacii. 15: 159–166.}}, some of which were proven to be insecure \\cite{doi:10.1515/dma.1992.2.4.439}. More recent works focus on methods to mask the algebraic structure using subcodes of GRS codes \\cite{doi:10.1007/s10623-003-6151-2}. For example, a key-recovery attack was developed in Ref. \\cite{arXiv:1307.6458} for a variant of masking method proposed in Ref. \\cite{arXiv:1108.2462}."],"relations":{"parents":[{"code_id":"evaluation","detail":"GRS (RS) codes are in one-to-one correspondence with evaluation AG codes of univariate polynomials \\(f\\) with \\(\\cal X\\) being the projective (affine) line  \\cite[Thm. 15.3.24]{preset:HKSag}\\cite[Ch. 3.2]{doi:10.1007/978-94-011-3810-9}\\cite{preset:HPAlgCodes}."},{"code_id":"evaluation_polynomial","detail":"GRS (RS) codes are in one-to-one correspondence with univariate polynomial evaluation codes with \\(\\cal X\\) being the projective (affine) line \\cite[Thm. 15.3.24]{preset:HKSag}\\cite[Ch. 3.2]{doi:10.1007/978-94-011-3810-9}\\cite{preset:HPAlgCodes})."}],"cousins":[{"code_id":"mds","detail":"GRS codes have distance \\(n-k+1\\), saturating the Singleton bound."},{"code_id":"distributed_storage","detail":"GRS codes are used in various cloud storage systems \\cite{arxiv:1612.01361}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-16"},{"user_id":"VictorVAlbert","date":"2022-05-17"},{"user_id":"MuhammadJunaidAftab","date":"2022-04-21"},{"user_id":"QingfengKeeWang","date":"2021-12-20"}]},"_zoodb":{"id":"generalized_reed_solomon","source_file_path":"codes/classical/q-ary_digits/ag/rs/generalized_reed_solomon.yml","source_file_modification_token":1682250129448.8972}},"interleaved_reed_solomon":{"code_id":"interleaved_reed_solomon","physical":"q-ary_digits","logical":"q-ary_digits","name":"Interleaved RS (IRS) code","short_name":"IRS","description":"A modification of RS codes where multiple polynomials are used to define each codeword. Each codeword \\(\\mu\\) of a \\(t\\)-interleaved RS code is a string of values of the corresponding set \\(\\{f_\\mu^{(1)},f_\\mu^{(2)},\\cdots,f_\\mu^{(t)}\\}\\) of \\(t\\) polynomials at the points \\(\\alpha_i\\). The vector codewords can be arranged in an array whose rows are ordinary RS codes for each polynomial \\(f^{j}\\), yielding the encoding\n\\begin{align}\n\\mu\\to\\left(\n\\begin{array}{cccc}\n  f_{\\mu}^{(1)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(1)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(1)}\\left(\\alpha_{n}\\right)\\\\\n  f_{\\mu}^{(2)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(2)}\\left(\\alpha_{2}\\right) &  & f_{\\mu}^{(2)}\\left(\\alpha_{n}\\right)\\\\\n  \\vdots &  & \\ddots & \\vdots\\\\\n  f_{\\mu}^{(t)}\\left(\\alpha_{1}\\right) & f_{\\mu}^{(t)}\\left(\\alpha_{2}\\right) & \\cdots & f_{\\mu}^{(t)}\\left(\\alpha_{n}\\right)\n\\end{array}\\right)~.\n\\end{align}\n","features":{"decoders":["Decoder that corrects up to \\(1-\\frac{2k+n}{3n}\\) fraction of random errors \\cite{doi:10.1016/j.tcs.2007.02.043}.","Decoder that corrects up to \\(1-(\\frac{k}{n})^{2/3}\\) fraction of random errors \\cite{doi:10.1145/780542.780563}."]},"realizations":["The cross-interleaved RS (CIRC), an IRS code using two shortened RS codes and two forms of interleaving, was used for compact discs (CDs) \\cite{manual:{Odaka K., Sako Y., Iwamoto I., Doi T.; Vries L.B.; SONY: Error correctable data transmission method (Patent US4413340) filing date May 21, 1980.}} (see Ref. \\cite{doi:10.1017/CBO9780511807077}, Sec. 5.6 and Ref. \\cite{doi:10.1109/9780470546345}, Ch. 4)."],"relations":{"parents":[{"code_id":"q-ary_linear","detail":"IRS codes are linear over \\(GF(q)\\) but not necessarily over \\(GF(q^t)\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-14"}]},"_zoodb":{"id":"interleaved_reed_solomon","source_file_path":"codes/classical/q-ary_digits/ag/rs/interleaved_reed_solomon.yml","source_file_modification_token":1678631058720.5366}},"parvaresh_vardy":{"code_id":"parvaresh_vardy","physical":"q-ary_digits","logical":"q-ary_digits","name":"Parvaresh-Vardy (PV) code","short_name":"PV","introduced":"\\cite{doi:10.1109/SFCS.2005.29}","description":"Also called a \\textit{correlated RS code}. An IRS code with additional algebraic relations (a.k.a. correlations) between the codeword polynomials \\(\\{f^{(j)}\\}_{j=1}^{t}\\). These relations yielded a list decoder that achieves list-decoding capacity.\n","features":{"decoders":["PV codes can be list-decoded up to \\(1-(t k/n)^{1/(t+1)}\\) fraction of errors. This result improves over the Guruswami-Sudan algorithm for ordinary \\hyperref[code:reed_solomon]{RS} codes, which list-decodes up to \\(1-\\sqrt{k/n}\\) fraction of errors."]},"relations":{"parents":[{"code_id":"interleaved_reed_solomon","detail":"PV codes are IRS codes with specific algebraic relations between the codeword polynomials that allow for efficient list decoding."}],"cousins":[{"code_id":"folded_reed_solomon","detail":"The specific relations imposed on the polynomials of PV codes allow for them to be expressed in a similar way as FRS codes, but with more redundancy. Folded RS codes can be list-decoded up to a higher fraction of errors."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-14"}]},"_zoodb":{"id":"parvaresh_vardy","source_file_path":"codes/classical/q-ary_digits/ag/rs/parvaresh_vardy.yml","source_file_modification_token":1678631058720.6953}},"reed_solomon":{"code_id":"reed_solomon","physical":"q-ary_digits","logical":"q-ary_digits","name":"Reed-Solomon (RS) code","short_name":"RS","introduced":"\\cite{doi:10.1214/aoms/1177729387,doi:10.1137/0108018}","description":"An \\([n,k,n-k+1]_q\\) linear code based on polynomials over \\(GF(q)\\). Let \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct points in \\(GF(q)\\). An RS code encodes a message \\(\\mu=\\{\\mu_0,\\cdots,\\mu_{k-1}\\}\\) into \\(\\{f_\\mu(\\alpha_1),\\cdots,f_\\mu(\\alpha_n)\\}\\) using a message-dependent polynomial\n\\begin{align}\nf_\\mu(x)=\\mu_0+\\mu_1 x + \\cdots + \\mu_{k-1}x^{k-1}.\n\\end{align}\nIn other words, each message \\(\\mu\\) is encoded into a string of values of the corresponding polynomial \\(f_\\mu\\) at the points \\(\\alpha_i\\),\n\\begin{align}\n  \\mu\\to\\left( f_{\\mu}\\left(\\alpha_{1}\\right),f_{\\mu}\\left(\\alpha_{2}\\right),\\cdots,f_{\\mu}\\left(\\alpha_{n}\\right)\\right) \\,.\n\\end{align}\n\nAn RS code with length \\(n=q-1\\) whose points \\(\\alpha_i\\) are \\(i-1\\)st powers of a primitive \\(n\\)th root of unity is a \\textit{narrow-sense RS code}.\nIn an alternative convention (not used here), the primitive-root case is called an RS code, and the general-root case is a generalized RS code.\n","protection":"Since each polynomial \\(f_{\\mu}\\) is of degree less than \\(k\\), it can be determined from its values at \\(k\\) points. This means that RS codes can correct erasures on up to \\(n-k\\) registers. The resulting distance, \\(d=n-k+1\\), saturates the Singleton bound.","features":{"encoders":["Bit-serial encoder \\cite{doi:10.1109/TIT.1982.1056591}.","\\([n,k,n-k+1]\\) RS code requires an order \\(O(n^2)\\) operations while encoding if a straightforward matrix multiplication is employed and \\(k=O(n)\\). Using the FFT algorithm, complexity of evaluating a polynomial at \\(n\\) roots of unity becomes \\(O(n\\log n)\\). The FFT can be generalized to finite fields and rings, which is referred as Number-theoretic Transform (NTT). However, for some values of \\(n\\), which can not be factorized into small primes or do not have \\(n\\) roots of unity, the FFT algorithm fails. Independently developed by \\cite{doi:10.1109/49.1926,doi:10.1016/0097-3165(89)90020-4} and generalized in Ref. \\cite{doi:10.1017/CBO9781139856065}, the additive FFT solves this problem by evaluating the polynomial at \\(n-1\\) roots of unity when \\(n\\) is power of 2."],"rate":"Generic Reed-Solomon codes achieve list-decoding capacity \\cite{arxiv:2206.05256}.","decoders":["Although using iFFT has its counterpart iNNT for finite fields, the decoding is usually standard polynomial interpolation in \\(k=O(n\\log^2 n)\\). However, in erasure decoding, encoded values are only erased in \\(r\\) points, which is a specific case of polynomial interpolation and can be done in \\(O(n\\log n)\\) by computing product of the received polynomial and an erasure locator polynomial and using long division to find an original polynomial. The long division step can be omitted to increase speed further by only dividing the derivative of the product polynomial, and derivative of erasure locator polynomial evaluated at erasure locations.","Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1969.1054260,preset:Berlekamp}.","Gorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) \\cite{doi:10.1109/TIT.1960.1057586,doi:10.1137/0109020} (see exposition in Ref. \\cite{preset:Blahut}).","Berlekamp-Welch decoder with runtime of order \\(O(n^3)\\) \\cite{manual:{E. R. Berlekamp and L. Welch, Error Correction of Algebraic Block Codes. U.S. Patent, Number 4,633,470 1986.}} (see exposition in Ref. \\cite{doi:10.1016/0020-0190(92)90195-2}), assuming that \\(t \\geq (n+k)/2\\).","Gao decoder using extended Euclidean algorithm \\cite{doi:10.1007/978-1-4757-3789-9_5}.","Fast-Fourier-transform decoder with runtime of order \\(O(n \\text{polylog}n)\\) \\cite{doi:10.1109/TIT.1978.1055816}.","List decoders try to find a low-degree bivariate polynomial \\(Q(x,y)\\) such that evaluation of \\(Q\\) at \\((\\alpha_i,y_i)\\) is zero. By choosing proper degrees, it can be shown such polynomial exists by drawing an analogy between evaluation of \\(Q(\\alpha_i,y_i)\\) and solving a homogenous linear equation (interpolation). Once this is done, one lists roots of \\(y\\) that agree at \\(\\geq t\\) points. The breakthrough Sudan list-decoding algorithm corrects up to \\(1-\\sqrt{2R}\\) fraction of errors \\cite{doi:10.1006/JCOM.1997.0439}. Roth and Ruckenstein proposed a modified key equation that allows for correction of more than \\(\\left\\lfloor (n-k)/2 \\right\\rfloor\\) errors \\cite{doi:10.1109/18.817522}. The Guruswami-Sudan algorithm improved the Sudan algorithm to \\(1-\\sqrt{R}\\) \\cite{doi:10.1109/SFCS.1998.743426}; see Ref. \\cite{doi:10.1109/TIT.2006.878164} for bounds. A further modification by Koetter and Vardy is used for soft-decision decoding \\cite{doi:10.1109/TIT.2003.819332} (see also Ref. \\cite{doi:10.1109/26.79287})."]},"realizations":["RS Product Code (RSPC) was used in DVDs (see Ref. \\cite{doi:10.1109/9780470546345}, Ch. 4).","DSL technologies and their variants against impluse noise \\cite{doi:10.1109/ICC.2012.6364040}.","Cryptographic primitives based on the hardness of decoding RS codes for more than \\(1-\\sqrt{k/n}+\\epsilon\\) errors. This is equivalent to the polynomial reconstruction problem \\cite{doi:10.1007/3-540-45465-9_21}.","RS codes as outer codes concatenated with convolutional codes are used indirectly in space exploration programs such as Voyager and Galileo. RS codes were part of a temetry channel coding standard issued by the Consultative Committee for Space Data Systems (see Ref. \\cite{doi:10.1109/9780470546345}, Ch. 3).","The ubiquity of RS codes has yielded off-the-shelf VLSI intergrated-circuit decoding hardware \\cite{doi:10.1109/92.953498} (see also Ref. \\cite{doi:10.1109/9780470546345}, Ch. 5 and 10).","Automatic repeat request (ARQ) data transmission protocols (see Ref. \\cite{doi:10.1109/9780470546345}, Ch. 7).","Slow-frequency-hop spread-spectrum transmission (see Ref. \\cite{doi:10.1109/9780470546345}, Chs. 8-9).","Coded sharding designs in blockchains to increase efficiency \\cite{arXiv:1809.10361}.","Private Information Retrieval \\cite{doi:10.1109/ISIT45174.2021.9517900}.","Used in QR-Codes to retrieve damaged barcodes \\cite{manual:{International Organization for Standardization, Information Technology: Automatic Identification and Data Capture Techniques-QR Code 2005 Bar Code Symbology Specification, 2nd ed., IEC18004 (ISO, 2006).}}.","Wireless communication systems such as 3G, DVB, and WiMAX \\cite{doi:10.1109/PIMRC.2010.5672091}.","Correcting pooled testing results for SARS-CoV-2 \\cite{doi:10.1126/sciadv.abc5961}."],"notes":["See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes.","See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Reed–Solomon Code.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon.html}}.","Popular summary in \\href{https://www.quantamagazine.org/how-mathematical-curves-power-cryptography-20220919/}{Quanta Magazine}."],"relations":{"parents":[{"code_id":"generalized_reed_solomon","detail":"A GRS code for which all multipliers \\(v_i\\) are unity reduces to an RS code."},{"code_id":"interleaved_reed_solomon","detail":"An IRS code utilizing one polynomial \\(f\\) reduces to an RS code."},{"code_id":"folded_reed_solomon","detail":"An FRS code with no extra grouping (\\(m=1\\)) reduces to an RS code."}],"cousins":[{"code_id":"mds","detail":"RS codes have distance \\(n-k+1\\), saturating the Singleton bound. If \\(k \\leq p\\), then all linear MDS codes \\( [n,k,n-k+1]_{p^m} \\) are RS codes \\cite{doi:10.4171/JEMS/316}."},{"code_id":"q-ary_bch","detail":"Narrow-sense RS codes are BCH codes \\cite[Remark 15.3.21]{preset:HKSag}\\cite[Thms. 5.2.1 and 5.2.3]{doi:10.1017/CBO9780511807077}. Their minimal distance is equal to their designed distance \\cite[pg. 81]{doi:doi:10.1007/978-1-4757-6568-7}. Moreover, an RS code can be represented as a union of cosets, with each coset being an interleaver of several binary BCH codes \\cite{doi:10.1109/26.79287}."},{"code_id":"q-ary_cyclic","detail":"If the length divides \\(q-1\\), then it is possible to construct a cyclic RS code."},{"code_id":"tensor","detail":"Tensor codes constructed from RS codes are robustly testable \\cite{doi:10.1145/195058.195132}."},{"code_id":"q-ary_ltc","detail":"RS codes can be used to construct LTCs encoding \\(k\\) bits with length \\(k \\text{polylog}(k)\\) and query complexity \\(\\text{polylog}(k)\\) \\cite{doi:10.1137/050646445}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-12"},{"user_id":"VictorVAlbert","date":"2022-04-28"},{"user_id":"MustafaDoger","date":"2022-04-03"},{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"reed_solomon","source_file_path":"codes/classical/q-ary_digits/ag/rs/reed_solomon.yml","source_file_modification_token":1682250129449.0027}},"complete_intersections":{"code_id":"complete_intersections","physical":"q-ary_digits","logical":"q-ary_digits","name":"Complete-intersection RM-type code","introduced":"\\cite{doi:10.1007/s002000000047}","description":"Evaluation code of polynomials evaluated on points lying on a complete intersection.\n","protection":"Distance bounds formulated in Ref. \\cite{doi:10.1016/j.jpaa.2004.08.015}.","relations":{"parents":[{"code_id":"evaluation_polynomial","detail":"Complete-intersection RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a complete intersection."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"}]},"_zoodb":{"id":"complete_intersections","source_file_path":"codes/classical/q-ary_digits/ag/varieties/complete_intersections.yml","source_file_modification_token":1678631058720.9717}},"deligne_lusztig":{"code_id":"deligne_lusztig","physical":"q-ary_digits","logical":"q-ary_digits","name":"Deligne-Lusztig code","introduced":"\\cite{doi:10.1006/ffta.2001.0313,manual:{S.H. Hansen, The geometry of Deligne-Lusztig varieties: Higher dimensional AG codes, Ph.D. Thesis, University of Aarhus, 1999.},doi:10.1007/s002290050146,doi:10.1007/BFb0087993}","description":"Evaluation code of polynomials evaluated on points lying on a Deligne-Lusztig variety.\n","relations":{"parents":[{"code_id":"evaluation_polynomial","detail":"Deligne-Lusztig codes are polynomial evaluation codes with \\(\\cal X\\) a Deligne-Lusztig variety."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"deligne_lusztig","source_file_path":"codes/classical/q-ary_digits/ag/varieties/deligne_lusztig.yml","source_file_modification_token":1678631058721.138}},"flag_variety":{"code_id":"flag_variety","physical":"q-ary_digits","logical":"q-ary_digits","name":"Flag-variety code","introduced":"\\cite{doi:10.1016/S0022-4049(02)00188-3}","description":"Evaluation code of polynomials evaluated on points lying on a flag variety.\n","relations":{"parents":[{"code_id":"evaluation_polynomial","detail":"Flag-variety codes are polynomial evaluation codes with \\(\\cal X\\) being a flag variety."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"flag_variety","source_file_path":"codes/classical/q-ary_digits/ag/varieties/flag_variety.yml","source_file_modification_token":1678631058721.2766}},"grassmannian":{"code_id":"grassmannian","physical":"q-ary_digits","logical":"q-ary_digits","name":"Grassmannian code","introduced":"\\cite{manual:{C. T. Ryan, An application of Grassmannian varieties to coding theory. Congr. Numer. 57 (1987) 257–271.},manual:{C.T. Ryan, Projective codes based on Grassmann varieties, Congr. Numer. 57, 273–279 (1987).},doi:10.1016/0166-218X(90)90112-P}","description":"Evaluation code of polynomials evaluated on points lying on a Grassmannian \\({\\mathbb{G}}(\\ell,m)\\).\n","relations":{"parents":[{"code_id":"flag_variety","detail":"Grassmannian codes are flag-variety evaluation codes with the flag variety being a Grassmannian."}],"cousins":[{"code_id":"griesmer","detail":"The binary Grassmannian \\([35,6,16]\\) code, whose points lie on the Grassmannian \\({\\mathbb{G}(2,4)}\\), attains the Griesmer bound \\cite{arxiv:0802.2349}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"grassmannian","source_file_path":"codes/classical/q-ary_digits/ag/varieties/grassmannian.yml","source_file_modification_token":1678631058721.416}},"hermitian_hypersurface":{"code_id":"hermitian_hypersurface","physical":"q-ary_digits","logical":"q-ary_digits","name":"Hermitian-hypersurface code","introduced":"\\cite{doi:10.1007/978-1-4613-8994-1_4}","description":"Evaluation code of polynomials evaluated on points lying on a Hermitian hypersurface.\n","relations":{"parents":[{"code_id":"flag_variety","detail":"Hermitian-hypersurface codes are flag-variety evaluation codes with the flag variety being a Hermitian hypersurface."}],"cousins":[{"code_id":"hermitian","detail":"Hermitian-hypersurface codes reduce to Hermitian codes of polynomials when the hypersurface is a curve."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"hermitian_hypersurface","source_file_path":"codes/classical/q-ary_digits/ag/varieties/hermitian_hypersurface.yml","source_file_modification_token":1678631058721.5798}},"quadric":{"code_id":"quadric","physical":"q-ary_digits","logical":"q-ary_digits","name":"Quadric code","introduced":"\\cite{doi:10.1016/0012-365X(75)90017-5,doi:10.1007/BFb0087988}","description":"Evaluation code of polynomials evaluated on points lying on a quadric hypersurface.\n","relations":{"parents":[{"code_id":"flag_variety","detail":"Quadric codes are flag-variety evaluation codes with the flag variety being a quadric hypersurface."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"quadric","source_file_path":"codes/classical/q-ary_digits/ag/varieties/quadric.yml","source_file_modification_token":1678631058721.8745}},"ruled_surface":{"code_id":"ruled_surface","physical":"q-ary_digits","logical":"q-ary_digits","name":"Ruled-surface code","introduced":"\\cite{doi:10.1006/ffta.2001.0313,arXiv:math/0309123}","description":"Evaluation code of polynomials evaluated on points lying on a ruled surface.\n","relations":{"parents":[{"code_id":"evaluation_polynomial","detail":"Ruled-surface codes are polynomial evaluation codes with \\(\\cal X\\) being a ruled surface."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"ruled_surface","source_file_path":"codes/classical/q-ary_digits/ag/varieties/ruled_surface.yml","source_file_modification_token":1678631058722.0105}},"schubert":{"code_id":"schubert","physical":"q-ary_digits","logical":"q-ary_digits","name":"Schubert code","introduced":"\\cite{doi:10.1007/978-3-642-57189-3_11,doi:10.1109/18.850689}","description":"Evaluation code of polynomials evaluated on points lying on a Schubert variety.\n","protection":"Minimum distance bounds computed in Refs. \\cite{doi:10.1109/18.850689,doi:10.1023/B:DESI.0000035470.05639.2b,doi:10.1016/j.ffa.2004.09.002}.","relations":{"parents":[{"code_id":"flag_variety","detail":"Schubert codes are flag-variety evaluation codes with the flag variety being a Schubert variety."}],"cousins":[{"code_id":"grassmannian","detail":"Schubert varieties are subvarieties of Grassmannians, and Schubert codes were initially constructed as a generalization of Grassmannian codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"schubert","source_file_path":"codes/classical/q-ary_digits/ag/varieties/schubert.yml","source_file_modification_token":1678631058722.1414}},"serge":{"code_id":"serge","physical":"q-ary_digits","logical":"q-ary_digits","name":"Serge-variety RM-type code","introduced":"\\cite{doi:10.1006/ffta.2002.0360}","description":"Evaluation code of polynomials evaluated on points lying on a Serge variety.\n","relations":{"parents":[{"code_id":"evaluation_polynomial","detail":"Serge-variety RM-type codes are polynomial evaluation codes with \\(\\cal X\\) being a Serge variety."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"}]},"_zoodb":{"id":"serge","source_file_path":"codes/classical/q-ary_digits/ag/varieties/serge.yml","source_file_modification_token":1678631058722.264}},"toric_classical":{"code_id":"toric_classical","physical":"q-ary_digits","logical":"q-ary_digits","name":"Hansen toric code","introduced":"\\cite{doi:10.1007/978-3-642-57189-3_12,arxiv:math/0208155}","description":"Evaluation code of a linear space of polynomials evaluated on points lying on an affine or projective toric variety. If the space is taken to be all polynomials up to some degree, the code is called a \\textit{toric RM-type code} of that degree.\n","protection":"Parameters of toric RM-type codes and various generalizations have been determined in Refs. \\cite{arXiv:math/0512285,arxiv:math/0507598,arxiv:1009.4966,arxiv:1202.0085,arxiv:1706.02114,arxiv:1907.13217}.","notes":["See Ref. \\cite{arxiv:1907.13217} for various examples and implementations in Magma."],"relations":{"parents":[{"code_id":"evaluation_polynomial","detail":"Hansen toric codes are polynomial evaluation codes with \\(\\cal X\\) being a toric variety."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"}]},"_zoodb":{"id":"toric_classical","source_file_path":"codes/classical/q-ary_digits/ag/varieties/toric_classical.yml","source_file_modification_token":1678631058722.4001}},"convolutional":{"code_id":"convolutional","physical":"q-ary_digits","logical":"q-ary_digits","name":"Convolutional code","introduced":"\\cite{manual:{Peter Elias. Coding for noisy channels. IRE Convention Records, 3(4):37–46, 1955.}}","description":"Infinite-block code that is formed using generator polynomials over the finite field with two elements. The encoder slides across contiguous subsets of the input bit-string (like a convolutional neural network) evaluating the polynomials on that window to obtain a number of parity bits. These parity bits are the encoded information.","features":{"rate":"Depends on the polynomials used. Using puncturing removal \\cite{doi:10.12928/telkomnika.v10i4.171} the rate for the code can be increased from \\(\\frac{1}{t}\\) to \\(\\frac{s}{t}\\), where \\(t\\) is the number of output bits, and \\(s\\) depends on the puncturing done. This is done by deleting some pieces of the encoder output such that the most-likely decoders remain effective","encoders":["Evaluation on the generator polynomials. Can be implemented with a small number of XOR gates"],"decoders":["Decoders based on the Viterbi algorithm (trellis decoding) were developed first, which result in the most-likely codeword for the encoded bits \\cite{doi:10.1109/TIT.1967.1054010}. Following, other trellis decoders such as the BCJR decoding algorithm \\cite{doi:10.1109/TIT.1974.1055186} were developed later."]},"realizations":["A type of convolutional code used in Real-time Application networks \\cite{doi:10.5815/ijcnis.2014.07.03}.","Mobile and radio communications (3G networks) use convolutional codes concatenated with Reed-Solomon codes to obtain suitable performance \\cite{doi:10.1002/0470866969}.","A convolutional code with rate 1/2 was used for deep-space and satellite communication \\cite{manual:{Butman, Deutsch, and Miller. Performance of concatenated codes for deep space missions. 1981.}}"],"relations":{"parents":[{"code_id":"block","detail":"Convolutional codes for infinite block size are block codes consisting of infinite blocks."}],"cousins":[{"code_id":"q-ary_digits_into_q-ary_digits","detail":"Convolutional codes for finite block size are \\(q\\)-ary codes."},{"code_id":"quantum_convolutional"},{"code_id":"reed_solomon","detail":"Convolutional codes are often used in concatenation with Reed-Solomon codes for communication \\cite{doi:10.1002/0470866969}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"BenjaminQuiring","date":"2021-12-16"}]},"_zoodb":{"id":"convolutional","source_file_path":"codes/classical/q-ary_digits/convolutional/convolutional.yml","source_file_modification_token":1683723710990.4548}},"ld_convolutional":{"code_id":"ld_convolutional","physical":"q-ary_digits","logical":"q-ary_digits","name":"LDPC convolutional code (LDPC-CC)","short_name":"LDPC-CC","introduced":"\\cite{doi:10.1109/18.782171,manual:{K. Engdahl, K. Sh. Zigangirov, “To the Theory of Low-Density Convolutional Codes. I”, Probl. Peredachi Inf., 35:4 (1999), 12–28; Problems Inform. Transmission, 35:4 (1999), 295–310},doi:10.1023/A:1013815115684}","alternative_names":["Low-density convolutional (LDC) code"],"description":"Convolutional code defined by an infinite low-density parity-check matrix.\n","relations":{"parents":[{"code_id":"convolutional"}],"cousins":[{"code_id":"ldpc","detail":"LDPC-CCs are convolutional analogues of LDPC codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"ld_convolutional","source_file_path":"codes/classical/q-ary_digits/convolutional/ld_convolutional.yml","source_file_modification_token":1683723710990.526}},"turbo":{"code_id":"turbo","physical":"q-ary_digits","logical":"q-ary_digits","name":"Turbo code","introduced":"\\cite{doi:10.1109/ICC.1993.397441}","description":"Code obtained from a parallel concatenation of two or more convolutional codes with permutations \\textit{interleaving} the individual encodings.\n","relations":{"parents":[{"code_id":"convolutional"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"turbo","source_file_path":"codes/classical/q-ary_digits/convolutional/turbo.yml","source_file_modification_token":1683723710990.6182}},"covering":{"code_id":"covering","physical":"q-ary_digits","logical":"q-ary_digits","name":"Covering code","description":"A \\(q\\)-ary code \\(C\\) is \\(\\rho\\)-covering if \\(\\forall v \\in GF(q)^{n}\\), there is a codeword \\(c \\in C\\) such that the Hamming distance \\(D(c,v)\\leq \\rho\\). More generally, a covering code in a metric space is covering if the union of balls of some radius centered at the codewords covers the entire space.\n\nThe \\textit{covering radius} \\(\\rho(C)\\) is the smallest non-negative integer \\(\\rho\\) such that \\(C\\) is \\(\\rho\\)-covering, i.e.\n\\begin{align}\n  \\rho(C)=\\max_{{v\\in GF(q)^{n}}}\\min_{{c\\in C}}d(v,c)~.\n\\end{align}\nFor a linear code \\([n,k]_q\\), the covering radius is the minimum number of columns of the code's parity check matrix which cover \\(GF(q)^{n-k}\\).\n\nThe covering radius satisfies various inequalities. A code \\(C\\) with distance \\(d\\) satisfies the relation\n\\begin{align}\n  \\rho(C)\\geq \\frac{|d-1|}{2}~. \\label{eq:perfect-ref}\n\\end{align}\nLinear \\([n,k]_q\\) codes also satisfy the \\textit{redundancy bound}\n\\begin{align}\n  \\rho(C)\\leq n-k\n\\end{align}\nand the \\textit{sphere covering bound}\n\\begin{align}\n  \\rho(C)\\leq \\min{\\left(p~\\bigg\\rvert \\sum_{i=0}^{p} {n \\choose i}(q-1)^{i}|C| \\geq q^{n}\\right)}~. \\label{eq:spherepacking-perfect-label}\n\\end{align}\nA code is perfect iff it satisfies Eqs. \\eqref{eq:perfect-ref} and \\eqref{eq:spherepacking-perfect-label} with equality.\n\nIn general, finding the covering radius of code is NP-Hard \\cite{doi:10.1109/TIT.1984.1056978}. Complexity analysis as well as an extensive study on bounds can be found in Ref. \\cite{manual:{G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, \\emph{Covering Codes}, Elsevier (1997).}}.\n","realizations":["Data compression both with or without compression \\cite{manual:{G. Cohen, I. Honkala, S. Litsyn, A. Lobstein, \\emph{Covering Codes}, Elsevier (1997).}}.","Football-pool problem: finding the smallest number of bets on a set of matches needed to guarantee at least one bet has at most \\(\\rho\\) errors \\cite{doi:10.2307/2974552,doi:10.1007/BF03025254}."],"notes":["See book \\cite{preset:CoveringBook} for an expositions on covering codes."],"relations":{"parents":[{"code_id":"weighed_covering","detail":"An \\(m\\)-weighed covering code for \\(m_j=1\\) is a covering code of covering radius at most \\(r\\) (\\cite{preset:CoveringBook}, Ch. 13)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"},{"user_id":"MustafaDoger","date":"2022-03-31"}]},"_zoodb":{"id":"covering","source_file_path":"codes/classical/q-ary_digits/covering/covering.yml","source_file_modification_token":1678631058722.5586}},"perfect":{"code_id":"perfect","physical":"q-ary_digits","logical":"q-ary_digits","name":"Perfect code","description":"An \\((n,K,2t+1)_q\\) code is perfect if parameters \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the Hamming (a.k.a. sphere-packing) bound\n\\begin{align}\n\\sum_{j=0}^{t}(q-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality.\nIn other words, the code's packing radius matches its covering radius.\n\nFor example, for a binary \\(q=2\\) code with one logical bit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(n+1 \\leq 2^{n-1}\\).\nPerfect codes are those for which balls of Hamming radius \\(t\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings.\n\nAny perfect linear code is either a repetition code, a Hamming code, or a binary or ternary Golay code \\cite{doi:10.1016/S0019-9958(77)90519-8}. If \\(q\\) is a prime power, any distance-three code is either a Hamming code or a nonlinear code with the same parameters; see \\cite[pg. 100]{preset:HKSdesigns} for more details.\n","relations":{"parents":[{"code_id":"covering","detail":"Perfect codes are covering codes with minimum number of codewords"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"},{"user_id":"MustafaDoger","date":"2022-04-01"},{"user_id":"VictorVAlbert","date":"2022-03-21"},{"user_id":"VictorVAlbert","date":"2021-12-01"}]},"_zoodb":{"id":"perfect","source_file_path":"codes/classical/q-ary_digits/covering/perfect.yml","source_file_modification_token":1682250129449.0923}},"quasi_perfect":{"code_id":"quasi_perfect","physical":"q-ary_digits","logical":"q-ary_digits","name":"Quasi-perfect code","description":"Perfect codes \\((n,K,d)_q\\) are those for which balls of Hamming radius \\(t=\\left\\lfloor (d-1)/2\\right\\rfloor\\) exactly fill the space of all \\(n\\) \\(q\\)-ary strings. \\textit{Quasi-perfect codes} are those for which balls of Hamming radius \\(t\\) are disjoint, while balls of radius \\(t+1\\) cover the space with possible overlaps. In other words, any \\(q\\)-ary string is at most \\(t+1\\) bit flips away from a codeword of a quasi-perfect code.\n","protection":"Correct errors of weight \\(t\\) as well as some errors of weight \\(t+1\\).","relations":{"parents":[{"code_id":"weighed_covering","detail":"A quasi-perfect code is an \\(m\\)-weighed covering code for \\(r=t+1\\), \\(m_0=m_1=\\cdots=m_{t+1}=1\\), and \\(m_t=m_{t+1}=1/\\left\\lfloor (n+1)(t+1) \\right\\rfloor\\) (\\cite{preset:CoveringBook}, Ch. 13)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"}]},"_zoodb":{"id":"quasi_perfect","source_file_path":"codes/classical/q-ary_digits/covering/quasi_perfect.yml","source_file_modification_token":1678631058722.6775}},"weighed_covering":{"code_id":"weighed_covering","physical":"q-ary_digits","logical":"q-ary_digits","name":"Weighed-covering code","description":"A \\(q\\)-ary code for which balls of some radius centered at its codewords provide a weighted covering of the Hamming space.\n\nLet the \\textit{outer} or \\textit{weight distribution} of a \\(q\\)-ary string \\(x\\) with respect to a \\(q\\)-ary code \\(C\\) be \\(A(x) = \\left( A_0(x),A_1(x),\\cdots,A_n(x) \\right)\\), where\n\\begin{align}\n  A_j(x) = \\left|\\{ c \\in C~\\text{such that}~ D(c,x)=j \\}\\right|~,\n\\end{align}\nand \\(D\\) is the Hamming distance. Given a tuple \\(m=(m_1,m_2,\\cdots,m_n)\\) of rational numbers, the \\textit{\\(m\\)-density} of the code at \\(x\\) is\n\\begin{align}\n  \\theta(x) = \\sum_{j=0}^n m_j A_j(x)~.\n\\end{align}\n\nA code is an \\textit{\\(m\\)-weighed covering} if \\(\\theta(x)\\geq1\\) for all strings \\(x\\in GF(q)^n\\).\nThe \\textit{\\(m\\)-covering radius} \\(r\\) is the largest \\(j\\) for which \\(m_j\\) is nonzero.\n","notes":["See book \\cite{preset:CoveringBook} for an expositions on weighed covering codes and generalized sphere-packing bounds.","See book \\cite{doi:10.1007/978-3-662-00174-5}, Table 7.5.18 for tables of codes with particular weighed coverings."],"relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"}]},"_zoodb":{"id":"weighed_covering","source_file_path":"codes/classical/q-ary_digits/covering/weighed_covering.yml","source_file_modification_token":1678631058722.7349}},"group":{"code_id":"group","physical":"q-ary_digits","logical":"q-ary_digits","name":"Group-algebra code","description":"Also known as a \\textit{group code}.\nAn \\( [n,k]_q \\) code based on a finite group \\( G \\) of size \\(n \\).\nA group-algebra code for an abelian group is called an \\textit{abelian group-algebra code}.\n\nThe code is a \\( k \\)-dimensional linear subspace of the group algebra of \\( G\\) with coefficients in the field \\(GF(q) = \\mathbb{F}_q\\) with \\(q\\) elements. To be precise, the code must be closed under permutations corresponding to the elements of the group \\( G \\); therefore, \\( G \\) must be a subgroup of the permutation automorphism group of the code, which is defined as the group of permutations of the physical bits that preserve the code space. This leads us to the formal definition of a group-algebra code: a group-algebra code is an ideal in the group algebra \\( \\mathbb{F}_q G \\).\n","notes":["See \\cite{preset:HKSalgebra}\\cite[pg. 58]{doi:10.1007/978-94-011-3810-9} for introductions to group-algebra codes.","Not all abelian group-algebra codes are for cyclic groups (cyclic codes) or for elementary abelian \\( p \\) groups (e.g. Reed Muller codes \\cite{doi:10.1007/BF01119999}). For example, there is a binary code with parameters \\( [45,13,16] \\) which is an abelian group-algebra code for the group \\( G = \\mathbb{Z}_3 \\times \\mathbb{Z}_{15} \\). "],"relations":{"parents":[{"code_id":"q-ary_linear","detail":"A linear code is a group-algebra code for a group \\(G\\) if and only if \\(G\\) is isomorphic to a regular subgroup of the code's permutation automorphism group \\cite{doi:10.1007/s10623-008-9261-z}\\cite[Thm. 16.4.7]{preset:HKSalgebra}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-03"},{"user_id":"VictorVAlbert","date":"2022-11-18"},{"user_id":"IanTeixeira","date":"2021-12-19"}]},"_zoodb":{"id":"group","source_file_path":"codes/classical/q-ary_digits/cyclic/group.yml","source_file_modification_token":1682250129449.2285}},"q-ary_bch":{"code_id":"q-ary_bch","physical":"q-ary_digits","logical":"q-ary_digits","name":"Bose–Chaudhuri–Hocquenghem (BCH) code","short_name":"BCH","introduced":"\\cite{doi:10.1137/0109020}","description":"Cyclic \\(q\\)-ary code, with \\(n\\) and \\(q\\) relatively coprime, whose zeroes are consecutive powers of a primitive \\(n\\)th root of unity \\(\\alpha\\). More precisely, the generator polynomial of a BCH code of \\textit{designed distance} \\(\\delta\\geq 1\\) is the lowest-degree monic polynomial with zeroes \\(\\{\\alpha^b,\\alpha^{b+1},\\cdots,\\alpha^{b+\\delta-2}\\}\\) for some \\(b\\geq 0\\). BCH codes are called \\textit{narrow-sense} when \\(b=1\\), and are called \\textit{primitive} when \\(n=q^r-1\\) for some \\(r\\geq 2\\).\n\nThe code dimension is related to the \\textit{multiplicative order} of \\(q\\) modulo \\(n\\), i.e., the smallest integer \\(m\\) such that \\(n\\) divides \\(q^m-1\\). The dimension of a BCH code is at least \\(n-m(\\delta-1)\\). The field \\(GF(q^m)\\) is the smallest field containing the above root of unity \\(\\alpha\\), and is the splitting field of the polynomial \\(x^n-1\\) (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\n","protection":"By the BCH bound, BCH code with designed distance \\(\\delta\\) has true minimum distance \\(d\\geq\\delta\\). BCH codes with different designed distances may coincide, and the largest possible designed distance for a given code is the \\textit{Bose distance}; the true distance may still be larger than that.\n","features":{"rate":"Primitive BCH codes are asymptotically bad \\cite[pg.~269]{preset:MacSlo}.","decoders":["Berlekamp-Massey decoder with runtime of order \\(O(n^2)\\) \\cite{doi:10.1109/TIT.1968.1054109,doi:10.1109/TIT.1969.1054260,preset:Berlekamp} and modification by Burton \\cite{doi:10.1109/TIT.1971.1054655}; see also \\cite{preset:PetersonWeldon,doi:10.1007/978-3-7091-2945-6}.","Gorenstein-Peterson-Zierler decoder with runtime of order \\(O(n^3)\\) \\cite{doi:10.1109/TIT.1960.1057586,doi:10.1137/0109020} (see exposition in Ref. \\cite{preset:Blahut}).","Sugiyama et al. modification of the extended Euclidean algorithm \\cite{doi:10.1016/S0019-9958(75)90090-X,doi:10.1017/CBO9780511606267}.","Guruswami-Sudan list decoder \\cite{doi:10.1109/SFCS.1998.743426} and modification by Koetter-Vardy for soft-decision decoding \\cite{doi:10.1109/TIT.2003.819332}."]},"notes":["See books \\cite{preset:MacSlo,preset:LinCostello,doi:10.1017/CBO9780511807077} for expositions on BCH codes and code tables.","See Kaiserslautern database \\cite{preset:KLdatabase} for explicit codes.","See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Cyclic Codes (BCH-Bound).” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CCyclic-BCHBound.html}}."],"realizations":["DVDs, disk drives, and two-dimensional bar codes \\cite{doi:10.1109/TIT.2019.2913389}."],"relations":{"parents":[{"code_id":"q-ary_cyclic"},{"code_id":"generalized_reed_solomon","detail":"BCH codes are subfield subcodes of GRS codes."}],"cousins":[{"code_id":"goppa","detail":"Narrow-sense BCH codes are Goppa codes with \\(L=\\{1,\\alpha^{-1},\\cdots,\\alpha^{1-n}\\}\\) and \\(G(x)=x^{\\delta-1}\\) (\\cite{doi:10.1017/CBO9780511807077}, pg. 522)."},{"code_id":"q-ary_ltc","detail":"Duals of BCH codes are locally testable \\cite{doi:10.1109/SFCS.2005.16}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-13"},{"user_id":"MuhammadJunaidAftab","date":"2022-04-21"}]},"_zoodb":{"id":"q-ary_bch","source_file_path":"codes/classical/q-ary_digits/cyclic/q-ary_bch.yml","source_file_modification_token":1678631058722.9236}},"q-ary_cyclic":{"code_id":"q-ary_cyclic","physical":"q-ary_digits","logical":"q-ary_digits","name":"Cyclic linear \\(q\\)-ary code","description":"A \\(q\\)-ary code of length \\(n\\) is cyclic if, for each codeword \\(c_1 c_2 \\cdots c_n\\), the cyclically shifted string \\(c_n c_1 \\cdots c_{n-1}\\) is also a codeword. A cyclic code is called \\textit{primitive} when \\(n=q^r-1\\) for some \\(r\\geq 2\\). A \\textit{shortened cyclic code} is obtained from a cyclic code by taking only codewords with the first \\(j\\) zero entries, and deleting those zeroes.\n\n\\subsection{Cyclic-to-polynomial correspondence}\n\n\\begin{defterm}{Cyclic-to-polynomial correspondence}\n\\label{topic:Cyclic-to-polynomial-correspondence}\nCyclic linear \\(q\\)-ary codes and their properties can be naturally formulated using the theory of polynomials.\nCodewords \\(c_1 c_2 \\cdots c_n\\) of a cyclic \\(q\\)-ary code can be thought of as coefficients in a polynomial \\(c_1+c_2 x+\\cdots+c_n x^{n-1}\\) in the set of polynomials with \\(q\\)-ary coefficients, \\(\\mathbb{F}_q[x]\\) with \\(\\mathbb{F}_q=GF(q)\\).\nPolynomials corresponding to codewords of a linear cyclic code form an ideal (i.e., are closed under multiplication and addition) in the ring \\(\\mathbb{F}_q[x]/(x^n-1)\\) (i.e., the set of equivalence classes of polynomials congruent modulo \\(x^n-1\\)).\nMultiplication of a codeword polynomial \\(c(x)\\) by \\(x\\) in such a ring corresponds to a cyclic shift of the corresponding codeword string.\n\\end{defterm}\n\nCodeword polynomials of a cyclic code can be generated, via multiplication, by a \\textit{generator polynomial} \\(g(x)\\).\nA particular generator polynomial \\(e(x)\\) has the additional property of being \\textit{idempotent}, i.e., \\(e(x)^2=e(x)\\). Given a generator polynomial, the corresponding \\textit{check polynomial} \\(h(x)=(x^n-1)/g(x)\\) yields zero when multiplying a codeword polynomial. Its coefficients correspond to the code's parity check matrix.\n\nSince the generator polynomial \\(g(x)\\) is a polynomial over \\(GF(q)\\), it can be factorized over some potentially larger \\textit{splitting field} (just like \\(x^2+1\\) can be factorized over the complex numbers but not the reals).\nWhenever \\(q\\) and \\(n\\) are relatively prime, cyclic codes can also be defined in terms of roots of \\(g(x)\\).\nSuch roots are called \\textit{zeroes} of the code, and they are all powers of a primitive \\(n\\)th root of unity because \\(g(x)\\) is a divisor of \\(x^n-1\\).\nSince the generator polynomial generates all codeword polynomials \\(c(x)\\) by multiplication by \\(x\\), its zeroes are also zeroes of those polynomials.\n","protection":"Shift bound \\cite{doi:10.1109/TIT.1986.1057134} gives a lower bound on the distance of cyclic \\(q\\)-ary codes.","features":{"decoders":["Meggitt decoder \\cite{doi:10.1109/TIT.1961.1057659}.","Information set decoding (ISD) \\cite{doi:10.1109/TIT.1962.1057777}, a probabilistic decoding strategy that essentially tries to guess \\(k\\) correct positions in the received word, where \\(k\\) is the size of the code. Then, an error vector is constructed to map the received word onto the nearest codeword, assuming the \\(k\\) positions are error free. When the Hamming weight of the error vector is low enough, that codeword is assumed to be the intended transmission.","Permutation decoding \\cite{doi:10.1002/j.1538-7305.1964.tb04075.x}."]},"notes":["See Ch. 7 of Ref. \\cite{preset:MacSlo} for an exposition."],"relations":{"parents":[{"code_id":"q-ary_linear"},{"code_id":"cyclic"},{"code_id":"group","detail":"A length-\\(n\\) cyclic \\(q\\)-ary linear code is an abelian group-algebra code for the cyclic group with \\(n\\) elements \\( \\mathbb{Z}_n \\)."}],"cousins":[{"code_id":"q-ary_ltc","detail":"Cyclic linear codes cannot be \\(c^3\\)-LTCs \\cite{doi:10.1109/TIT.2005.851735}. Codeword symmetries are in general an obstruction to achieving such LTCs \\cite{doi:10.1007/978-3-642-16367-8_12}."},{"code_id":"self_dual","detail":"See Refs. \\cite{doi:10.1109/TIT.2010.2092415,doi:10.1109/TIT.2012.2236383} for tables of cyclic self-dual codes."}]},"_meta":{"changelog":[{"user_id":"MazinKarjikar","date":"2022-12-30"},{"user_id":"VictorVAlbert","date":"2022-07-13"}]},"_zoodb":{"id":"q-ary_cyclic","source_file_path":"codes/classical/q-ary_digits/cyclic/q-ary_cyclic.yml","source_file_modification_token":1682250129449.3184}},"q-ary_duadic":{"code_id":"q-ary_duadic","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary duadic code","introduced":"\\cite{doi:10.1016/0097-3165(86)90066-X,doi:10.1007/978-3-7091-2786-5_1,doi:10.7907/CZA5-PX53,doi:10.1109/TIT.1987.1057300}","description":"Member of a pair of cyclic linear binary codes that satisfy certain relations, depending on whether the pair is \\textit{even-like} or \\textit{odd-like} duadic. Duadic codes exist only when \\(q\\) is a square modulo \\(n\\) \\cite{doi:10.1007/978-3-7091-2786-5_1}.\n\nDuadic codes come in two pairs, an even-like duadic pair and an odd-like duadic pair. All codewords in the respective pairs are \\textit{even-like}, i.e., \\(\\sum_i c_i = 0\\), or \\textit{odd-like}, i.e., \\(\\sum_i c_i \\neq 0\\). A code with all even-like (odd-like) codewords is called even-like (odd-like).\n\nDuadic code pairs can be defined in terms of their idempotent generators (see \\ref{topic:Cyclic-to-polynomial-correspondence}).\nA pair of even-like codes \\(C_1\\) and \\(C_2\\) with respective idempotents \\(e_1\\) and \\(e_2\\) is an \\textit{even-like duadic pair} if (1) \\(e_1(x)+e_2(x)=1-\\frac{1}{n}(1+x+x^2+\\cdots+x^{n-1})\\) and (2) there exists a multiplier \\(\\mu\\) such that \\(C_1 \\mu=C_2\\) and \\(C_2 \\mu=C_1\\).\n\nThere is an odd-like duadic pair \\(\\{D_1,D_2\\}\\) associated with the even-like pair \\(\\{C_1, C_2\\}\\), where \\(1-e_2(x)\\) generates \\(D_1\\) and \\(1-e_1(x)\\) generates \\(D_2\\). The even-pair codes are \\([n,\\frac{n-1}{2}]_q\\) codes while the odd-pair codes are \\([n,\\frac{n+1}{2}]_q\\) codes.\n","notes":["Reviews of duadic codes \\cite{doi:10.1007/978-3-7091-2786-5_1,doi:10.1017/CBO9780511807077}."],"relations":{"parents":[{"code_id":"q-ary_cyclic"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-07"}]},"_zoodb":{"id":"q-ary_duadic","source_file_path":"codes/classical/q-ary_digits/cyclic/q-ary_duadic.yml","source_file_modification_token":1664458795521.3354}},"q-ary_quad_residue":{"code_id":"q-ary_quad_residue","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary quadratic-residue (QR) code","short_name":"\\(q\\)-ary QR","description":"Member of a quadruple of cyclic \\(q\\)-ary codes of prime length \\(n\\) where \\(q\\) is prime and a quadratic residue modulo \\(n\\). The codes are constructed using quadratic residues and nonresidues of \\(n\\).\n\nThe roots of the generator polynomial \\(r(x)\\) of the first code (see \\ref{topic:Cyclic-to-polynomial-correspondence}) are all of the inequivalent quadratic residues of \\(n\\), and the second code's generator polynomial is \\((x-1)r(x)\\). The roots of the generator polynomial \\(a(x)\\) of the third code are all inequivalent nonresidues of \\(n\\), and the fourth code's generator polynomial is \\((x-1)a(x)\\). The codes corresponding to polynomials \\(r,a\\) are often called \\textit{augmented} quadratic-residue codes, while the remaining codes are called \\textit{expurgated}.\n","notes":["Introduction of quadratic-residue codes in Refs. \\cite{preset:MacSlo,doi:10.1017/CBO9780511807077}."],"relations":{"parents":[{"code_id":"q-ary_duadic","detail":"QR codes are duadic codes of prime length satisfying certain relations \\cite{doi:10.1007/978-3-7091-2786-5_1}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-15"}]},"_zoodb":{"id":"q-ary_quad_residue","source_file_path":"codes/classical/q-ary_digits/cyclic/q-ary_quad_residue.yml","source_file_modification_token":1664458795516.6028}},"codes_with_availability":{"code_id":"codes_with_availability","physical":"q-ary_digits","logical":"q-ary_digits","name":"Availability code","description":"Stub.","relations":{"parents":[{"code_id":"parallel_recovery","detail":""}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"},{"user_id":"VictorVAlbert","date":"2021-11-22"}]},"_zoodb":{"id":"codes_with_availability","source_file_path":"codes/classical/q-ary_digits/distributed_storage/codes_with_availability.yml","source_file_modification_token":1678631058723.1086}},"distributed_storage":{"code_id":"distributed_storage","physical":"q-ary_digits","logical":"q-ary_digits","name":"Distributed-storage code","description":"Designed to encode information into spatial nodes such that it is possible to recover said information after failure of some nodes by accessing the remaining nodes with minimal bandwidth. Stub.","protection":"","relations":{"parents":[{"code_id":"ecc_finite"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"distributed_storage","source_file_path":"codes/classical/q-ary_digits/distributed_storage/distributed_storage.yml","source_file_modification_token":1678631058723.165}},"locally_recoverable":{"code_id":"locally_recoverable","physical":"q-ary_digits","logical":"q-ary_digits","name":"Locally recoverable code (LRC)","short_name":"LRC","description":"Any code for which, given a codeword \\(x\\) and coordinate \\(i\\), \\(x_i\\) can be recovered from (at most \\(r\\)) other coordinates of \\(x\\). An \\(r\\)-locally recoverable code of length \\(n\\) and dimension \\(k\\) is denoted as an \\((n,k,r)\\) LRC code.\n\nMore technically, a \\(q\\)-ary code \\(C\\) with length \\(n\\) is \\(r\\)-locally recoverable, or \\textit{has locality} \\(r\\), if \\(\\forall i \\in [n]\\), there exists \\(I_i \\subset [n]\\setminus i\\) such that \\(|I_i|\\leq r\\), and the projection of the set \\(\\mathcal{C}(i,a)=\\{x\\in C : x_i=a\\}\\) on to the coordinates in \\(I_i\\), i.e., \\(\\mathcal{C}_{I_i}(i,a)\\) is disjoint from \\(\\mathcal{C}_{I_i}(i,a^\\prime)\\) where \\(a\\neq a^\\prime\\).\n\nThe definition can be generalized to \\(t\\)-LRC code, if every coordinate is recoverable from \\(t\\) disjoint subsets of coordinates. A study on the parameters of \\(t\\)-LRC codes, together with known bounds, can be found in Ref. \\cite{doi:10.1109/TIT.2016.2518663}.\n","protection":"The distance, \\(d\\), of an \\((n,k,r)\\) LRC code satisfies \\begin{align} d\\leq n-k-\\left \\lceil\\frac{k}{r}\\right \\rceil+2~,\\label{eq:gen-singleton} \\end{align} where \\(r\\leq k\\). When \\(k=r\\), the bound on the distance gives the Singleton bound. The generalized Singleton bound \\eqref{eq:gen-singleton} does not account for \\(q\\)-ary alphabet size. A more generalized bound (including the non-linear case) is given in Ref. \\cite{doi:10.1109/TIT.2015.2477406}.","features":{"rate":"The rate \\(r\\) of an \\((n,k,r)\\) LRC code satisfies \\begin{align} \\frac{k}{n}\\leq\\frac{r}{r+1}~. \\end{align}"},"realizations":["An \\((18,14,7)\\) LRC code has beed used in the Windows Azure cloud storage system \\cite{manual:{C. Huang, H. Simitci, Y. Xu, A. Ogus, B. Calder, P. Gopalan, J. Li, and S. Yekhanin. \\emph{Erasure coding in Windows Azure Storage}. In Proc. USENIX Annual Technical Conference (ATC), pgs. 15-26, Boston, Massachusetts, June 2012.}}; see also \\cite[31.3.1.2]{preset:HKSdist}."],"relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits","detail":"Locally recoverable codes protect against coordinate erasure."},{"code_id":"distributed_storage"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-28"},{"user_id":"MustafaDoger","date":"2022-04-03"}]},"_zoodb":{"id":"locally_recoverable","source_file_path":"codes/classical/q-ary_digits/distributed_storage/locally_recoverable.yml","source_file_modification_token":1682250129449.4155}},"mds":{"code_id":"mds","physical":"q-ary_digits","logical":"q-ary_digits","name":"Maximum distance separable (MDS) code","short_name":"MDS","introduced":"\\cite{doi:10.1109/TIT.1964.1053661}","description":"A \\([n,k,d]_q\\) binary or \\(q\\)-ary linear code is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Singleton bound\n\\begin{align}\nd \\leq n-k+1\n\\end{align}\nbecomes an equality. A code is called \\textit{almost MDS} (AMDS) when \\(d=n-k\\). A bound for general \\(q\\)-ary codes can also be formulated; see \\cite[Thm. 1.9.10]{preset:HKSbasics}. A code is \\textit{near MDS} (NMDS) if the code and its dual are mode AMDS.\n\nThe codes \\( [n,1,n]_q, [n,n-1,2]_q, [n,n,1]_q \\) for any \\(q\\) are MDS codes. These are called the \\textit{trivial} MDS codes. The only binary MDS codes are the trivial ones.\n","protection":"Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error-correction properties.","realizations":["The McEliece Public Key Cryptosystem \\cite{manual:{McEliece, R.J.: A public-key cryptosystem based on algebraic coding theory. DSN Progress Report pp. 114–116 (1978).}} uses algebraic coding theory to secure communications against eavesdropping attack, in which private keys are generator matrices of linear codes, i.e., \\(G\\). Public Keys shared to outside world are scrambled and permutated versions of \\(G\\), i.e., \\(G^\\prime=SGP\\). Data to be encrypted, \\(u\\), is multiplied by public key and added intentional errors \\(e\\), i.e., \\(x=uG^\\prime+e\\). Upon receiving encrypted data, private key owner can apply inverse permutation \\(P^{-1}\\) to \\(x\\), decode the scrambled message given the presence of \\(e\\) errors, and finally unscramble to obtain \\(u\\). Security parameters of the system are \\(n\\) and \\(e\\), hence MDS codes, such as GRS codes may provide the same security level for shorter key sizes, and the private key owner can decode arguably fast enough using known decoding algorithms.","Automatic repeat request (ARQ) data transmission protocols (\\cite{doi:10.1109/9780470546345}, Ch. 7)."],"relations":{"parents":[{"code_id":"q-ary_linear"},{"code_id":"locally_recoverable","detail":"MDS codes are most efficient in terms of minimizing storage overhead for handling erasures. They are locally recoverable with locality \\(k\\)."},{"code_id":"univ_opt_q-ary","detail":"MDS codes are LP universally optimal codes \\cite{arxiv:1212.1913}."}],"cousins":[{"code_id":"dual","detail":"A linear binary or \\(q\\)-ary \\([n,k,n-k+1]\\) code is MDS if and only if its dual \\([n,n-k,k+1]\\) is MDS \\cite[Thm. 1.9.13]{preset:HKSbasics}."},{"code_id":"projective","detail":"A linear code is MDS (almost MDS) if and only if columns of its parity-check matrix form an \\(n\\)-arc (\\(n\\)-track) in projective space \\cite{doi:10.1109/ISIT.1994.395042,doi:10.1007/978-1-4613-0283-4_13}. The dual of a MDS code is an MDS code, so MDS codes are projective."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"},{"user_id":"VictorVAlbert","date":"2022-04-28"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"EricKubischta","date":"2021-12-15"}]},"_zoodb":{"id":"mds","source_file_path":"codes/classical/q-ary_digits/distributed_storage/mds.yml","source_file_modification_token":1682250129449.5051}},"parallel_recovery":{"code_id":"parallel_recovery","physical":"q-ary_digits","logical":"q-ary_digits","name":"Parallel-recovery code","description":"Stub.","relations":{"parents":[{"code_id":"sequential_recovery","detail":""}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"parallel_recovery","source_file_path":"codes/classical/q-ary_digits/distributed_storage/parallel_recovery.yml","source_file_modification_token":1678631058723.3567}},"sequential_recovery":{"code_id":"sequential_recovery","physical":"q-ary_digits","logical":"q-ary_digits","name":"Sequential-recovery code","description":"Stub.","relations":{"parents":[{"code_id":"locally_recoverable","detail":""}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-22"}]},"_zoodb":{"id":"sequential_recovery","source_file_path":"codes/classical/q-ary_digits/distributed_storage/sequential_recovery.yml","source_file_modification_token":1678631058723.4524}},"dual":{"code_id":"dual","physical":"q-ary_digits","logical":"q-ary_digits","name":"Dual linear code","description":"For any \\([n,k]_q\\) linear code \\(C\\), the dual (or orthogonal) code,\n\\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x\\cdot y=0 \\forall x\\in C\\},\n\\end{align}\nwhere the \\textit{ordinary}, \\textit{standard}, or \\textit{Euclidean} inner product is \\(x\\cdot y = \\sum_{i=1}^n x_i y_i\\) for coordinates \\(x_i,y_i\\).\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called \\textit{self-orthogonal} or \\textit{weakly self-dual}. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called \\textit{dual-containing}. A code that is equal to its dual, \\(C^\\perp = C\\), is called \\textit{self-dual}. The dual of a dual code is the original code. A code is dual-containing iff its dual is self-orthogonal.\n\nThe dual code \\(C^\\perp\\) is the row space of the parity check matrix of \\(C\\). The dual code is the kernel of the encoding map for \\(C\\), and \\(\\dim C^\\perp = n-k\\).\n\nAn alternative definition of dual substitutes the Euclidean inner product for the \\textit{Hermitian inner product},\n\\begin{align}\n  x\\cdot y \\to x\\cdot \\bar{y} = \\sum_{i=1}^n x_i y^{p}_i~.\n\\end{align}\nSelf-dual codes with respect to the above product are called \\textit{Hermitian self-dual}; similar definitions hold for self-orthogonal and dual-containing.\n\nMore general inner products can also be considered \\cite{doi:10.1007/s10623-016-0282-8}.\n","protection":"The dual of an \\([n,k,d] \\) code is an \\([n,n-k,d'']\\) code, where \\(d''\\) is not always related to \\(d\\). The generator matrix of \\(C^\\perp\\) is the parity check matrix of \\(C\\), and visa versa.\n\nThe generator matrix of the Hermitian dual of a code with generator matrix \\(G = [I_k~~A]\\) is \\([-\\bar{A}^T~~I_{n-k}]\\), where \\(\\bar{A}\\) contains matrix elements of \\(A\\) raised to the \\(p\\)th power.\nA code is Hermitian self-dual if and only if \\(A \\bar{A}^{T} = -I_{n/2}\\).\n","relations":{"parents":[{"code_id":"q-ary_linear"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"},{"user_id":"MicahShaw","date":"2022-06-28"},{"user_id":"VictorVAlbert","date":"2021-12-18"},{"user_id":"DhruvDevulapalli","date":"2021-12-17"}]},"_zoodb":{"id":"dual","source_file_path":"codes/classical/q-ary_digits/dual/dual.yml","source_file_modification_token":1682420107451.6255}},"dual_additive":{"code_id":"dual_additive","physical":"q-ary_digits","logical":"q-ary_digits","name":"Dual additive code","description":"For any \\(q\\)-ary additive code \\(C\\), the dual additive (or orthogonal additive) code is\n\\begin{align}\nC^\\perp = \\{ y\\in GF(q)^{n} ~|~ x \\star y=0 \\forall x\\in C\\},\n\\end{align}\nwhere the \\textit{trace inner product} is \\(x\\star y = \\sum_{i=1}^n \\text{tr}(x_i y_i)\\) for coordinates \\(x_i,y_i\\), and the trace maps elements of the field \\(GF(q)\\) with \\(q=p^m\\) to elements of \\(GF(p)\\) as\n\\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align}\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called \\textit{self-orthogonal additive} or \\textit{weakly self-dual additive}. A code that contains its dual, \\(C^\\perp \\subseteq C\\), is called \\textit{dual-containing additive}. A code that is equal to its dual, \\(C^\\perp = C\\), is called \\textit{self-dual additive}. A code is dual-containing additive iff its dual is self-orthogonal additive.\n\nAn alternative definition of dual substitutes the trace inner product for the \\textit{trace-Hermitian inner product}, \\(x\\star y \\to \\sum_{i=1}^n \\text{tr}(x_i y^{p}_i)\\).\nAnother extension for when \\(q=p^2\\), relevant to \\hyperref[code:stabilizer_over_gfqsq]{certain stabilizer codes} and reducing to the trace-Hermitian case for \\(q=4\\), is the \\textit{trace-alternating inner product},\n\\begin{align}\n  x\\star y \\to \\sum_{i=1}^{n}\\text{tr}\\left(\\frac{x_{i}y_{i}^{\\sqrt{q}}-x_{i}^{\\sqrt{q}}y_{i}}{\\alpha-\\alpha^{q}}\\right)~,\n\\end{align}\nwhere \\(\\{1,\\alpha\\}\\) is a basis of \\(GF(q)\\) over \\(GF(\\sqrt{q})\\).\nSelf-dual additive codes with respect to the trace-Hermitian (trace-alternating) inner product are called \\textit{trace Hermitian (trace-alternating) self-dual additive}; similar definitions hold for self-orthogonal additive and dual-containing additive.\n","relations":{"parents":[{"code_id":"q-ary_additive"}],"cousins":[{"code_id":"dual","detail":"Different inner products are typically used to define duals of linear and additive codes."},{"code_id":"dual_over_rings"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"}]},"_zoodb":{"id":"dual_additive","source_file_path":"codes/classical/q-ary_digits/dual/dual_additive.yml","source_file_modification_token":1682420107451.7278}},"pless_symmetry":{"code_id":"pless_symmetry","physical":"q-ary_digits","logical":"q-ary_digits","name":"Pless symmetry code","introduced":"\\cite{manual:{V. Pless, On a new family of symmetry codes and related new five-designs, BAMS 75 (1969), 1339-1342},doi:10.1016/0097-3165(72)90088-X}","description":"Also called a \\textit{Pless double circulant code}.\nA member of a family of self-dual ternary \\([2p+2,p+1]_3\\) codes for any prime \\(p \\equiv -1\\) modulo 6.\nSee \\cite[Sec. 10.5]{doi:10.1017/CBO9780511807077}\\cite[pg. 87]{doi:10.1007/978-1-4757-6568-7} for explicit constructions.\n","relations":{"parents":[{"code_id":"self_dual"}],"cousins":[{"code_id":"ternary_golay","detail":"The Pless symmetry code for \\(p=5\\) is the extended ternary Golay code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-14"}]},"_zoodb":{"id":"pless_symmetry","source_file_path":"codes/classical/q-ary_digits/dual/pless_symmetry.yml","source_file_modification_token":1682420107451.8154}},"self_dual":{"code_id":"self_dual","physical":"q-ary_digits","logical":"q-ary_digits","name":"Self-dual linear code","description":"An \\([n,n/2]_q\\) code that is equal to its dual, \\(C^\\perp = C\\), where the dual is defined with respect to an inner product, most commonly either Euclidean or Hermitian.\nSelf-dual codes exist only for even lengths and have dimension \\(k=n/2\\).\n\nAn even (doubly-even) self-dual code is called Type I (Type II) \\cite{arxiv:2112.11763,doi:10.1007/978-1-4757-6568-7}.\nTernary (quaternary) self-dual codes are called \\textit{Type III} (\\textit{Type IV}), and each of their codewords has weight three (two).\n","protection":"The generator matrix of the Hermitian dual of a code with generator matrix \\(G = [I_k~~A]\\) is \\([-\\bar{A}^T~~I_{n-k}]\\), where \\(\\bar{A}\\) contains matrix elements of \\(A\\) raised to the \\(p\\)th power.\nA code is Hermitian self-dual if and only if \\(A \\bar{A}^{T} = -I_{n/2}\\).\n\nThe minimum distance of a Hermitian self-dual \\([n,n/2]\\) code satisfies\n\\begin{align}\n  d\\leq\\begin{cases}\n    2\\left\\lfloor \\frac{n}{8}\\right\\rfloor +2 & q=2\\text{ and code is singly-even}\\\\\n    4\\left\\lfloor \\frac{n}{24}\\right\\rfloor +4 & q=2\\text{ and code is doubly-even}\\\\\n    3\\left\\lfloor \\frac{n}{12}\\right\\rfloor +3 & q=3\\\\\n    2\\left\\lfloor \\frac{n}{6}\\right\\rfloor +2 & q=4\\text{ and code is even}\n  \\end{cases}~,\n\\end{align}\nexcept for \\(n = 22\\) modulo four for the second case, where the bound is increased by four \\cite{doi:10.1109/18.651000}.\nA self-dual code saturating the above inequality is called \\textit{extremal}.\n","notes":["See books \\cite{doi:10.1007/3-540-30731-1,doi:10.1017/CBO9780511807077} for more on self-dual codes.","See Refs. \\cite{doi:10.1016/j.disc.2004.06.010,arXiv:1706.01694} for constructions of binary self-dual codes.","See \\href{http://www.unilim.fr/pages_perso/philippe.gaborit/SD/index.html}{Tables of Self-Dual Codes} for a database of self-dual codes over \\(GF(2)\\), \\(GF(3)\\), \\(GF(4)\\) (Euclidean or Hermitian), \\(GF(5)\\), and \\(GF(7)\\). See also Ref. \\cite{doi:10.1016/S1071-5797(03)00011-X}."],"relations":{"parents":[{"code_id":"dual"},{"code_id":"self_dual_additive","detail":"Self-dual linear codes with respect to some inner product are automatically self-dual additive under the same inner product since linear codes are additive. In addition, quaternary linear codes are Hermitian self-orthogonal (self-dual) iff they are trace-Hermitian self-orthogonal (self-dual) additive \\cite[Thm. 27.4.1]{preset:HKSquantum} (\\cite[Thm. 9.10.3]{doi:10.1017/CBO9780511807077})."}],"cousins":[{"code_id":"divisible","detail":"Binary self-dual codes are singly-even and binary self-orthogonal codes that are not doubly-even are singly-even \\cite[Def. 4.1.6]{preset:HKSselfdual}. The minimum distance of doubly-even binary self-dual codes asymptotically satisfies \\(d\\leq0.1664n+o(n)\\) \\cite{doi:10.1109/18.605587}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-21"}]},"_zoodb":{"id":"self_dual","source_file_path":"codes/classical/q-ary_digits/dual/self_dual.yml","source_file_modification_token":1682420107451.9058}},"self_dual_additive":{"code_id":"self_dual_additive","physical":"q-ary_digits","logical":"q-ary_digits","name":"Self-dual additive code","description":"An additive \\((n,2^n)_q\\) code that is equal to its dual, \\(C^\\perp = C\\), where the dual is defined with respect to some inner product, usually the trace-Hermitian inner product.\n\nSelf-dual additive codes that contain at least one codeword of odd weight are called \\textit{Type I additive}.\nEven self-dual additive codes are called \\textit{Type II additive}, existing only for even \\(n\\) \\cite[Sec. 9.10]{doi:10.1017/CBO9780511807077}.\nType I (type II) additive codes with length up to seven (eight) have been classified \\cite{arxiv:math/0005266}.\nMuch is known about codes up to length 16 \\cite{manual:{P. Gaborit, W. C. Huffman, J.-L. Kim, and V. Pless, “On additive GF(4) codes,” in Codes and Association Schemes (DIMACS Workshop, November 9–12, 1999), eds. A. Barg and S. Litsyn. Providence, RI: American Mathematical Society, 2001, pp. 135–149.}}.\n","protection":"The minimum distance of a trace-Hermitian self-dual additive \\((n,n/2\\) code satisfies \\cite[Thm. 33]{preset:HPRainsSloane}\n\\begin{align}\n  d\\leq\\begin{cases}\n  2\\left\\lfloor \\frac{n}{6}\\right\\rfloor +1 & n\\equiv0\\text{ mod 6 and code is Type I additive}\\\\\n  4\\left\\lfloor \\frac{n}{6}\\right\\rfloor +3 & n\\equiv5\\text{ mod 6 and code is Type I additive}\\\\\n  2\\left\\lfloor \\frac{n}{6}\\right\\rfloor +2 & \\text{otherwise for Type I  additive codes}\\\\\n  2\\left\\lfloor \\frac{n}{6}\\right\\rfloor +2 & \\text{code is Type II additive}\n  \\end{cases}~.\n\\end{align}\nA self-dual additive code saturating the above inequality is called \\textit{extremal additive}.\n","relations":{"parents":[{"code_id":"dual_additive"}],"cousins":[{"code_id":"dual","detail":"The difference between the definitions of dual linear and dual additive codes is in the trace used in the inner product."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"}]},"_zoodb":{"id":"self_dual_additive","source_file_path":"codes/classical/q-ary_digits/dual/self_dual_additive.yml","source_file_modification_token":1682517021286.4016}},"dodecacode":{"code_id":"dodecacode","physical":"q-ary_digits","logical":"q-ary_digits","name":"Dodecacode","introduced":"\\cite{arxiv:quant-ph/9608006,arXiv:math/0005266}","description":"The unique trace-Hermitian self-dual additive \\((12,4^6,6)_4\\) code.\nIts codewords are cyclic permutations of \\((\\omega 10100100101)\\), where \\(GF(4)=\\{0,1,\\omega,\\bar{\\omega}\\}\\) \\cite[Sec. 2.4.8]{doi:10.1007/3-540-30731-1}.\nAnother generator matrix can be found in \\cite[Ex. 9.10.8]{doi:10.1017/CBO9780511807077}.\n\nThe dodecacode is a self-dual additive code, and there is no self-dual linear code with the same parameters \\cite{doi:10.1109/18.57217}.'\n","relations":{"parents":[{"code_id":"self_dual_additive","detail":"The dodecacode is trace-Hermitian self-dual additive."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"}]},"_zoodb":{"id":"dodecacode","source_file_path":"codes/classical/q-ary_digits/easy/dodecacode.yml","source_file_modification_token":1682420107452.1223}},"hexacode":{"code_id":"hexacode","physical":"q-ary_digits","logical":"q-ary_digits","name":"Hexacode","introduced":"\\cite{doi:10.1214/aoms/1177729387,doi:10.1007/978-1-4757-6568-7}","description":"The \\([6,3,4]_4\\) self-dual MDS code with generator matrix\n\\begin{align}\n  \\begin{pmatrix}\n  1 & 0 & 0 & 1 & 1 & \\omega\\\\\n  0 & 1 & 0 & 1 & \\omega & 1\\\\\n  0 & 0 & 1 & \\omega & 1 & 1\n  \\end{pmatrix}~,\n\\end{align}\nwhere \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\).\nHas connections to projective geometry, lattices \\cite{doi:10.1007/978-1-4757-6568-7}, and conformal field theory \\cite{arxiv:2003.13700}.\n\nPuncturing the code yields the perfect \\([5,3,3]_4\\) ternary Hamming code known as the \\textit{shortened hexacode} or \\textit{shorter hexacode} \\cite{arxiv:math/0005266}.\nBoth codes are sometimes refereed to as \\textit{Golay codes over \\(GF(4)\\)}.\n","features":{"decoders":["Bounded-distance decoder requiring at most 34 real operations \\cite{doi:10.1109/18.412695}."]},"notes":["See \\cite[Sec. 10.3]{doi:10.1017/CBO9780511807077} for an exposition.","See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Hexacode.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CHexa.html}}."],"relations":{"parents":[{"code_id":"hyperoval","detail":"Columns of hexacode's generator matrix represent the six homogeneous coordinates of a hyperoval in the projective plane \\(PG(2,4)\\) \\cite[pg. 289]{doi:10.1201/9781315371993}\\cite[Exam. 19.2.1]{preset:HKStwoweight}."},{"code_id":"evaluation","detail":"The hexacode is an evaluation AG code over \\(GF(4) = \\{0,1,\\omega, \\bar{\\omega}\\}\\) with \\(\\cal X\\) defined by \\(x^2 y + \\omega y^2 z + \\bar{\\omega} z^2 x = 0\\) \\cite[Ex. 2.77]{preset:HPAlgCodes}."},{"code_id":"q-ary_quad_residue","detail":"The hexacode is the smallest example of an extended quadratic residue code of Type \\(4^H\\) \\cite[Sec. 2.4.6]{doi:10.1007/3-540-30731-1}\\cite[Exer. 363]{doi:10.1017/CBO9780511807077}. The shortened hexacode is an odd-like quadratic residue code \\cite[Ex. 6.6.8]{doi:10.1017/CBO9780511807077}."},{"code_id":"self_dual","detail":"The hexacode is Hermitian self-dual and, as a result, is also trace-Hermitian self-dual additive \\cite[Sec. 9.10]{doi:10.1017/CBO9780511807077}. The hexacode and the shortened hexacode are extremal \\cite[Tab. 9.14]{doi:10.1017/CBO9780511807077}\\cite[Tm. 12]{arxiv:math/0005266}."},{"code_id":"denniston","detail":"A version of the hexacode is recovered for Dennison code parameters \\(i=1\\) and \\(a=2\\) \\cite{doi:10.1201/9781315371993}."},{"code_id":"mds","detail":"The hexacode is an MDS code \\cite[Exer. 578]{doi:10.1017/CBO9780511807077}."},{"code_id":"extended_reed_solomon","detail":"The hexacode is an extended RS code \\cite[pg. 82]{doi:10.1007/978-1-4757-6568-7}."}],"cousins":[{"code_id":"q-ary_hamming","detail":"The hexacode is an extended ternary Hamming code \\cite[Exer. 578]{doi:10.1017/CBO9780511807077}."},{"code_id":"stab_5_1_3","detail":"Applying the \\hyperref[code:stabilizer_over_gf4]{stabilizer-over-\\(GF(4)\\)} construction to the hexacode yields a \\([[6,0,4]]\\) quantum code \\cite{arxiv:quant-ph/0310137} corresponding to the six-qubit perfect state. The five-qubit code can be obtained either by applying the \\hyperref[code:stabilizer_over_gf4]{stabilizer-over-\\(GF(4)\\)} construction to the shortened hexacode or by tracing out a qubit of the \\([[6,0,4]]\\) code \\cite{arxiv:1503.06237}."},{"code_id":"golay","detail":"Extended Golay codewords can be obtained from hexacodewords \\cite{doi:10.1007/978-1-4757-6568-7}. The hexacode can be used to decode the extended Golay code \\cite{doi:10.1109/TIT.1986.1057197}. There is also a connection between automoprhisms of the even Golay code and the holomorph of the hexacode \\cite{arxiv:2003.13700}."},{"code_id":"perfect","detail":"The shortened hexacode is perfect \\cite[Exer. 578]{doi:10.1017/CBO9780511807077}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"}]},"_zoodb":{"id":"hexacode","source_file_path":"codes/classical/q-ary_digits/easy/hexacode.yml","source_file_modification_token":1682517021286.932}},"q-ary_hamming":{"code_id":"q-ary_hamming","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary Hamming code","introduced":"\\cite{manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}","description":"Member of an infinite family of perfect linear \\(q\\)-ary codes with parameters \\([(q^r-1)/(q-1),(q^r-1)/(q-1)-r, 3]_q\\) for \\(r \\geq 2\\).","protection":"Can detect 1-bit and 2-bit errors, and can correct 1-dit errors.","relations":{"parents":[{"code_id":"q-ary_linear"},{"code_id":"perfect"},{"code_id":"univ_opt_q-ary","detail":"Hamming codes and their punctured and shortened versions are LP universally optimal codes \\cite{arxiv:1212.1913}."}],"cousins":[{"code_id":"incidence_matrix","detail":"Columns of a Hamming parity-check matrix correspond to one-dimensional subspaces of \\(GF(q)^n\\)."},{"code_id":"q-ary_cyclic","detail":"Hamming codes are equivalent to cyclic codes when \\(q\\) and \\(r\\) are relatively prime (\\cite{preset:MacSlo}, pg. 194)."},{"code_id":"bch","detail":"Some narrow sense BCH codes of length \\(n=(q^r-1)/(q-1)\\) such that \\(\\text{gcd}(r,q-1)=1\\) are \\(q\\)-ary Hamming codes (\\cite{doi:10.1017/CBO9780511807077}, Thm. 5.1.4)."},{"code_id":"generalized_reed_muller","detail":"Hamming codes are dual to first-order GRM codes (\\cite{doi:10.1007/978-94-011-3810-9}, pg. 45)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-12"}]},"_zoodb":{"id":"q-ary_hamming","source_file_path":"codes/classical/q-ary_digits/easy/q-ary_hamming.yml","source_file_modification_token":1683723710990.7964}},"q-ary_parity_check":{"code_id":"q-ary_parity_check","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary parity-check code","description":"Also known as a \\textit{sum-zero} or \\textit{zero-sum} code. An \\([n,n-1,2]_q\\) linear \\(q\\)-ary code whose codewords consist of the message string appended with a \\textit{parity-check} or \\textit{zero-sum check digit} such that the sum over all coordinates of each codeword is zero.","relations":{"parents":[{"code_id":"reed_solomon","detail":"RS codes for \\(k=n-1\\) are parity-check codes \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Extended Reed–Solomon Code.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CReedSolomon-extended.html}}."},{"code_id":"q-ary_cyclic","detail":"Since permutations coordinate sums, the cyclic permutation of an SPC codeword is another codeword. The generator polynomial of the code is \\(x-1\\)."},{"code_id":"mds"}],"cousins":[{"code_id":"q-ary_ldgm","detail":"Concatenated \\(q\\)-ary parity-check codes are LDGM \\cite{doi:10.1109/20.917609}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-19"}]},"_zoodb":{"id":"q-ary_parity_check","source_file_path":"codes/classical/q-ary_digits/easy/q-ary_parity_check.yml","source_file_modification_token":1683723710990.9624}},"q-ary_repetition":{"code_id":"q-ary_repetition","physical":"bits","logical":"bits","name":"\\(q\\)-ary repetition code","description":"\\([n,1,n]_q\\) binary linear code encoding consisting of codewords \\((j,j,\\cdots,j)\\) for \\(j \\in GF(q)\\). The length \\(n\\) needs to be an odd number, since the receiver will pick the majority to recover the information.","protection":"Detects errors on up to \\(\\frac{n-1}{2}\\) coordinates, corrects erasure errors on up to \\(\\frac{n-1}{2}\\) coordinates.","relations":{"parents":[{"code_id":"q-ary_cyclic","detail":"The \\(q\\)-ary repetition code is cyclic with generator polynomial \\(1+x+\\cdots+x^{n-1}\\)."},{"code_id":"delsarte_optimal_q-ary","detail":"The \\(q\\)-ary repetition code is a \\(q\\)-ary sharp configuration \\cite[Table 12.1]{preset:HKSbounds}."}],"cousins":[{"code_id":"repetition"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-12"}]},"_zoodb":{"id":"q-ary_repetition","source_file_path":"codes/classical/q-ary_digits/easy/q-ary_repetition.yml","source_file_modification_token":1682250129449.8633}},"ternary_golay":{"code_id":"ternary_golay","physical":"q-ary_digits","logical":"q-ary_digits","name":"Ternary Golay code","introduced":"\\cite{manual:{M. J. E. Golay, \\emph{Notes on digital coding}, Proc. IEEE, 37 (1949) 657.}}","description":"A \\([11,6,5]_3\\) perfect ternary linear code with connections to various areas of mathematics, e.g., lattices \\cite{doi:10.1007/978-1-4757-6568-7} and sporadic simple groups \\cite{preset:MacSlo}. Adding a parity bit to the code results in the \\([12, 6, 6]\\) \\textit{extended ternary Golay code}. Up to equivalence, both codes are unique for their respective parameters.\n\nA generator matrix for the ternary Golay code is\n\\begin{align}\n\\left(\\begin{array}{cccccccccccc}\n  1 & 0 & 0 & 0 & 0 & | & 1 & 1 & 1 & 2 & 2 & 0 \\\\\n  0 & 1 & 0 & 0 & 0 & | & 1 & 1 & 2 & 1 & 0 & 2 \\\\\n  0 & 0 & 1 & 0 & 0 & | & 1 & 2 & 1 & 0 & 1 & 2 \\\\\n  0 & 0 & 0 & 1 & 0 & | & 1 & 2 & 0 & 1 & 2 & 1 \\\\\n  0 & 0 & 0 & 0 & 1 & | & 1 & 0 & 2 & 2 & 1 & 1 \\\\\n\\end{array}\\right)~.\n\\end{align}\n","features":{"decoders":["Decoder for the extended ternary Golay code using the tetracode \\cite{doi:10.1109/TIT.1986.1057197}."]},"realizations":["Code used in football pools with at least one good bet \\cite{doi:10.1016/0097-3165(91)90024-B,doi:10.1007/BF03025254}. In fact, the code was originally constructed by Juhani Virtakallio and published in the Finnish football pool magazine Veikkaaja \\cite{doi:10.1007/BF03025254,manual:{T. M. Thompson, \\emph{From Error-Correcting Codes Through Sphere Packings To Simple Groups}, Mathematical Association of America, 1983.}}.","Proofs of the quantum mechanical Kochen-Specker theorem \\cite{arxiv:2206.04209}."],"notes":["The automorphism group of the ternary Golay code is the Mathieu group \\(\\mathcal{M}_{11}\\), and the automorphism group of the extended ternary Golay code is the Mathieu group \\(\\mathcal{M}_{12}\\), two of the sporadic simple groups."],"relations":{"parents":[{"code_id":"q-ary_quad_residue","detail":"The ternary Golay code is a quadratic residue code over \\(GF(3)\\) with residue set \\(Q = \\{1, 3, 4, 5, 9\\} \\) and generator polynomial \\(x^5 + x^4 - x^3 + x^2 - 1\\) (\\cite{preset:MacSlo}, Ch. 16)."},{"code_id":"perfect","detail":"The ternary Golay code is perfect."},{"code_id":"delsarte_optimal_q-ary","detail":"The ternary Golay code and one of its shortened versions are \\(q\\)-ary sharp configurations \\cite[Table 12.1]{preset:HKSbounds}."}],"cousins":[{"code_id":"golay"},{"code_id":"self_dual","detail":"The extended ternary Golay code is self-dual."},{"code_id":"projective","detail":"The extended ternary Golay code admits a projective geometric construction (\\cite{doi:10.1201/9781315371993}, pg. 296)."},{"code_id":"divisible","detail":"Extended ternary Golay code is 3-divisible (\\cite{doi:10.1201/9781315371993}, pg. 296)."},{"code_id":"univ_opt_q-ary","detail":"The ternary Golay code and several of its extended, shortened, and punctured versions are LP universally optimal codes \\cite{arxiv:1212.1913}."},{"code_id":"projective_two_weight","detail":"The dual of the ternary Golay code is a projective two-weight code \\cite[Ex. 19.3.2]{preset:HKStwoweight}."}]},"_meta":{"changelog":[{"user_id":"VikramAmin","date":"2023-01-21"},{"user_id":"VictorVAlbert","date":"2022-01-21"},{"user_id":"VictorVAlbert","date":"2022-08-12"},{"user_id":"ShashankSule","date":"2022-03-02"}]},"_zoodb":{"id":"ternary_golay","source_file_path":"codes/classical/q-ary_digits/easy/ternary_golay.yml","source_file_modification_token":1682420107452.3955}},"tetracode":{"code_id":"tetracode","physical":"q-ary_digits","logical":"q-ary_digits","name":"Tetracode","introduced":"\\cite{doi:10.1007/978-1-4757-6568-7}","description":"The \\([4,2,3]_3\\) self-dual MDS code with generator matrix\n\\begin{align}\n  \\begin{pmatrix}1 & 0 & 1 & 1\\\\\n  0 & 1 & 1 & 2\n  \\end{pmatrix}~,\n\\end{align}\nwhere \\(GF(3) = \\{0,1,2\\}\\). Has connections to lattices \\cite{doi:10.1007/978-1-4757-6568-7}.\n","notes":["See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Tetracode.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CTetra.html}}."],"relations":{"parents":[{"code_id":"simplex","detail":"The tetracode is equivalent to \\(S(3,2)\\)."},{"code_id":"q-ary_hamming","detail":"The tetracode is equivalent to the \\(r=2\\) \\(3\\)-ary Hamming code."},{"code_id":"self_dual","detail":"The tetracode is Euclidean self-dual."},{"code_id":"mds"},{"code_id":"extended_reed_solomon","detail":"The tetracode is an extended RS code \\cite[pg. 81]{doi:10.1007/978-1-4757-6568-7}"}],"cousins":[{"code_id":"ternary_golay","detail":"Extended ternary Golay codewords can be obtained from tetracodewords \\cite{doi:10.1007/978-1-4757-6568-7}. The tetracode can be used to decode the extended ternary Golay code \\cite{doi:10.1109/TIT.1986.1057197}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"}]},"_zoodb":{"id":"tetracode","source_file_path":"codes/classical/q-ary_digits/easy/tetracode.yml","source_file_modification_token":1682420107452.53}},"ipp":{"code_id":"ipp","physical":"q-ary_digits","logical":"q-ary_digits","name":"Identifiable parent property (IPP) code","short_name":"IPP","introduced":"\\cite{doi:10.1006/jcta.1997.2851}","description":"Stub.","relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-01"}]},"_zoodb":{"id":"ipp","source_file_path":"codes/classical/q-ary_digits/ipp.yml","source_file_modification_token":1678631058724.194}},"bs-ltc":{"code_id":"bs-ltc","physical":"q-ary_digits","logical":"q-ary_digits","name":"Ben-Sasson-Sudan code","introduced":"\\cite{doi:10.1145/1060590.1060631}","description":"Locally testable \\([[n,k/2,d]]_{2^m}\\) code with \\(k\\) a power of two, \\(n = k \\log^{c} k\\), and query complexity \\(\\log^{c}k\\) for some universal constant \\(c\\).\n","relations":{"parents":[{"code_id":"q-ary_ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"bs-ltc","source_file_path":"codes/classical/q-ary_digits/ltc/bs-ltc.yml","source_file_modification_token":1664741378386.4697}},"meir":{"code_id":"meir","physical":"q-ary_digits","logical":"q-ary_digits","name":"Meir code","introduced":"\\cite{doi:10.1145/1374376.1374419}","description":"Locally testable \\([n,k,d]_q\\) code with query complexity \\(\\text{poly}(\\log k)\\) and rejection ratio \\(R/n = 1/\\text{poly}(\\log k)\\). Code construction is probabilistic and combinatorial.\n","relations":{"parents":[{"code_id":"q-ary_ltc","detail":"Meir codes stand out in that they are based on a combinatorial construction, while other LTCs often use algebraic tools."}],"cousins":[{"code_id":"random"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"meir","source_file_path":"codes/classical/q-ary_digits/ltc/meir.yml","source_file_modification_token":1678631058724.4678}},"q-ary_ltc":{"code_id":"q-ary_ltc","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary linear LTC","description":"A \\(q\\)-ary linear code \\(C\\) of length \\(n\\) that is a \\((u,R)\\)-LTC with query complexity \\(u\\) and soundness \\(R>0\\).\nMore technically, the code is a \\((u,R)\\)-LTC if the rows of its parity-check matrix \\(H\\in GF(q)^{r\\times n}\\) have weight at most \\(u\\) and if\n\\begin{align}\n  \\frac{1}{r}|H x| \\geq \\frac{R}{n} D(x,C)\n\\end{align}\nholds for any \\(q\\)-ary string \\(x\\), where \\(D(x,C)\\) is the \\(q\\)-ary Hamming distance between \\(x\\) and the closest codeword to \\(x\\) \\cite[Def. 11]{arxiv:1911.03069}.\n","relations":{"parents":[{"code_id":"q-ary_linear"},{"code_id":"ltc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-30"}]},"_zoodb":{"id":"q-ary_ltc","source_file_path":"codes/classical/q-ary_digits/ltc/q-ary_ltc.yml","source_file_modification_token":1664741378386.5857}},"matrix_product":{"code_id":"matrix_product","physical":"q-ary_digits","logical":"q-ary_digits","name":"Matrix-product code","introduced":"\\cite{doi:10.1007/PL00004226}","description":"Code constructed using a concatenation procedure that yields a code consisting of all products of codewords in \\(M\\) length-\\(n\\) \\(q\\)-ary codes and an \\(M\\times N\\) \\(q\\)-ary matrix with \\(N\\geq M\\). A prominent subclass is the case with \\(A\\) is non-singular by columns (NSC).\n","features":{"decoders":["Decoder up to half of the minimum distance for NSC codes \\cite{doi:10.1007/s00200-009-0113-5}."]},"relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-21"}]},"_zoodb":{"id":"matrix_product","source_file_path":"codes/classical/q-ary_digits/matrix_product.yml","source_file_modification_token":1664458795616.5552}},"bose_qvist":{"code_id":"bose_qvist","physical":"q-ary_digits","logical":"q-ary_digits","name":"Ovoid code","introduced":"\\cite{manual:{R. C. Bose (1947). Mathematical theory of the symmetrical factorial design. Sankhyā: The Indian Journal of Statistics, 107-166.},manual:{B. Qvist. Some remarks concerning curves of the second degree in a finite plane. Suomalainen tiedeakatemia, 1952.}}","description":"Member of a \\([q^2+1,4,q^2-q]_q\\) projective code family that is universally optimal and that is constructed using ovoids in projective space.\nSee \\cite[pg. 107]{doi:10.1112/blms/18.2.97}\\cite[pg. 192]{doi:10.1201/9781315371993} for further details.\n","relations":{"parents":[{"code_id":"projective"},{"code_id":"delsarte_optimal_q-ary","detail":"The ovoid code is a \\(q\\)-ary sharp configuration \\cite[Table 12.1]{preset:HKSbounds}."}],"cousins":[{"code_id":"univ_opt_q-ary","detail":"Several shortened and punctured versions of the ovoid code are LP universally optimal codes \\cite{arxiv:1212.1913}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"bose_qvist","source_file_path":"codes/classical/q-ary_digits/projective/bose_qvist.yml","source_file_modification_token":1682250129450.138}},"denniston":{"code_id":"denniston","physical":"q-ary_digits","logical":"q-ary_digits","name":"Denniston code","introduced":"\\cite{doi:10.1016/S0021-9800(69)80095-5}","description":"Projective code that is part of a family of \\([2^{a+i}+2^i-2^a,3,2^{a+i}-2^a]_{GF(2^a)}\\) codes for \\(i < a\\) constructed using Denniston arcs.\n","notes":["See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Denniston Codes.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CDenniston.html}}."],"relations":{"parents":[{"code_id":"projective_two_weight","detail":"Denniston codes are projective two-weight codes on maximal arcs \\cite[Sec. 19.7.3]{preset:HKStwoweight}\\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Denniston Codes.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CDenniston.html}}."},{"code_id":"griesmer"},{"code_id":"delsarte_optimal_q-ary","detail":"The Denniston code is a \\(q\\)-ary sharp configuration \\cite[Table 12.1]{preset:HKSbounds}."}],"cousins":[{"code_id":"hyperoval","detail":"Denniston codes for \\(i=1\\) are based on hyperovals in \\(PG(2,2^a)\\) \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Denniston Codes.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CDenniston.html}}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"}]},"_zoodb":{"id":"denniston","source_file_path":"codes/classical/q-ary_digits/projective/denniston.yml","source_file_modification_token":1682250129450.2207}},"griesmer":{"code_id":"griesmer","physical":"q-ary_digits","logical":"q-ary_digits","name":"Griesmer code","introduced":"\\cite{doi:10.1147/rd.45.0532,doi:10.1016/S0019-9958(65)90080-X,manual:{R. R. Varshamov, \\emph{On the general theory of linear coding}, Ph.D. Thesis, Moscow State University, 1959.}}","description":"A \\([n,k,d]_q\\) code is a Griesmer code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the Griesmer bound\n\\begin{align}\n  n\\geq\\sum_{j=0}^{k-1}\\left\\lceil \\frac{d}{q^{j}}\\right\\rceil ~,\n\\end{align}\nwhere \\(\\left\\lceil x\\right\\rceil \\) is the ceiling function, becomes an equality.\n\nAn \\([n,2,d]_q\\) code exists if and only if it is not excluded by the Griesmer bound. Every Griesmer code is generated by its minimum-weight codewords \\cite{manual:{S. Dodunekov, Optimal linear codes, Ph.D. Thesis, Sofia, 1985.}}.\n","relations":{"parents":[{"code_id":"mds","detail":"Singleton bound implies the Griesmer bound."}],"cousins":[{"code_id":"divisible","detail":"If a \\(p\\)-ary Griesmer code with \\(p\\) prime is such that a power of \\(p\\) divides the distance, then the code is divisible by that power \\cite{doi:10.1006/jcta.1997.2864}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-08"}]},"_zoodb":{"id":"griesmer","source_file_path":"codes/classical/q-ary_digits/projective/griesmer.yml","source_file_modification_token":1681805027417.285}},"hill_cap":{"code_id":"hill_cap","physical":"q-ary_digits","logical":"q-ary_digits","name":"Hill projective-cap code","introduced":"\\cite{manual:{Hill, R. (1973). Caps and groups. Colloquio Internazionale sulle Teorie Combinatorie (Rome, 1973), 2, 389-394.}}","description":"Member of a projective code family that contains of \\(q\\)-ary sharp configurations and that is constructed using projective caps.\n","relations":{"parents":[{"code_id":"projective_two_weight","detail":"Hill projective-cap codes are projective two-weight codes on projective caps \\cite[Table 19.1]{preset:HKStwoweight}."}],"cousins":[{"code_id":"delsarte_optimal_q-ary","detail":"Hill projective-cap codes for \\(n=56\\) and \\(78\\) are \\(q\\)-ary sharp configurations \\cite[Table 12.1]{preset:HKSbounds}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"hill_cap","source_file_path":"codes/classical/q-ary_digits/projective/hill_cap.yml","source_file_modification_token":1682250129450.31}},"hyperoval":{"code_id":"hyperoval","physical":"q-ary_digits","logical":"q-ary_digits","name":"Hyperoval code","introduced":"\\cite{manual:{R. C. Bose (1947). Mathematical theory of the symmetrical factorial design. Sankhyā: The Indian Journal of Statistics, 107-166.}}","description":"A projective code constructed using hyperovals in projective space.\n","relations":{"parents":[{"code_id":"projective"}],"cousins":[{"code_id":"delsarte_optimal_q-ary","detail":"Codes based on hyperovals in \\(PG_{2}(q)\\) are \\(q\\)-ary sharp configurations \\cite[Table 12.1]{preset:HKSbounds}."},{"code_id":"projective_two_weight","detail":"Codes based on hyperovals in \\(PG_{2}(q)\\) with even \\(q\\) are projective two-weight codes \\cite[Exam. 19.2.1]{preset:HKStwoweight}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"hyperoval","source_file_path":"codes/classical/q-ary_digits/projective/hyperoval.yml","source_file_modification_token":1682250129450.3872}},"incidence_matrix":{"code_id":"incidence_matrix","physical":"q-ary_digits","logical":"q-ary_digits","name":"Incidence-matrix projective code","introduced":"\\cite{manual:{E. Prange, \\emph{The use of coset equivalene in the analysis and decoding of group codes}. AIR FORCE CAMBRIDGE RESEARCH LABS HANSCOM AFB MA, 1959.},doi:10.1109/TIT.1967.1053994,manual:{E. Prange, \"Some cyclic error-correcting codes with simple decoding algorithms.\" AFCRC-TN-58-156 (1985).}}","description":"Code whose generator matrix is the incidence matrix of points and hyperplanes of a projective spaces.\nHas been generalized to incidence matrices of other structures \\cite{doi:10.1006/jcta.2002.3265,manual:{M. Lavrauw, L. Storme, and G. Van de Voorde (2010). \\emph{Linear codes from projective spaces}. In A. Bruen & D. Wehlau (Eds.), Contemporary Mathematics (Vol. 523, pp. 185–202). Providence, RI, USA: American Mathematical Society (AMS).}}\\cite[Sec. 14.4]{preset:HKSprojective}.\nColumns of a code's parity-check matrix can similarly correspond to an incidence matrix.\n","relations":{"parents":[{"code_id":"projective"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"}]},"_zoodb":{"id":"incidence_matrix","source_file_path":"codes/classical/q-ary_digits/projective/incidence_matrix.yml","source_file_modification_token":1683723710991.2002}},"projective":{"code_id":"projective","physical":"q-ary_digits","logical":"q-ary_digits","name":"Projective geometry code","description":"Linear \\(q\\)-ary \\([n,k,d]\\) code such that columns of its generator matrix \\(G\\) does not contain any repeated columns or the zero column.\nThat way, each column corresponds to a distinct point in the projective space \\(PG(k-1,q)\\) arising from a \\(k\\)-dimensional vector space over \\(GF(q)\\). If the columns are linearly independent, then the codewords are collectively called an \\textit{information set}.\nColumns of a code's parity-check matrix can similarly correspond to points in projective space. This formulation yields connections to projective geometry, which can be applied to determine code properties.\n\nRecall that a linear code encodes a message \\(h\\) into a codeword \\(c = hG\\). The \\(i\\)th coordinate of a codeword is given the dot product \\(h \\cdot G_{i}\\) with \\(G_{i}\\) being the \\(i\\)th column of the generator matrix. The zero-coordinate condition \\(h \\cdot x = 0\\) defines a hyperplane of points \\(x\\) with normal vector \\(h\\). Therefore, the Hamming weight of the corresponding codeword is the number of points \\(G_i\\) \\textit{not} contained in said hyperplane.\n\nIn general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space (\\cite{doi:10.1007/978-1-4613-0283-4_14}, Thm. 1.1; \\cite{doi:10.1016/S0012-365X(99)00183-1}). Multisets can also be used to construct parity-check matrices of linear codes.\n","protection":"Distance \\(d\\) is \\(n\\) minus the maximum number of points that are contained in a hyperplane. For \\(n \\geq 3\\), a code is projective if and only if the distance of its dual code is at least three.","notes":["See corresponding definition in \\href{http://mint.sbg.ac.at/glossary.php#GProjectiveCode}{MinT}."],"relations":{"parents":[{"code_id":"q-ary_linear","detail":"Columns of the generator matrix of a projective linear \\([n,k]_q\\) code correspond to distinct nonzero points in projective space. In general, linear codes admit repeating columns or columns proportional to each other. In that case, the columns correspond to a multiset of non-distinct nonzero points, and multisets are in one-to-one correspondence to arcs in projective space (\\cite{doi:10.1007/978-1-4613-0283-4_14}, Thm. 1.1)."}],"cousins":[{"code_id":"evaluation_varieties","detail":"Codewords of an evaluation code of multivariate polynomials up to degree one evaluated at points in projective space yields a projective code."},{"code_id":"extended_reed_solomon","detail":"Columns of parity-check matrices of doubly extended narrow-sense RS codes consist of points of a normal rational curve \\cite[Def. 14.2.6]{preset:HKSprojective}."},{"code_id":"griesmer","detail":"Acrs corresponding to Griesmer codes are called Griesmer arcs \\cite[pg. 248]{doi:10.1007/978-1-4613-0283-4_14}. There is a one-to-one correspondence between Griesmer codes and minihypers \\cite{doi:10.1016/0378-3758(89)90098-0,manual:{N. Hamada, Characterization of minihypers in a finite projective geometry and its applications to error-correcting codes, Bull. Osaka Women's Univ. 24 (1987), 1-24.}}; see \\cite[Sec. 14.2.4]{preset:HKSprojective}\\cite{doi:10.1007/978-1-4613-0283-4_13} for more details."},{"code_id":"anticode","detail":"There is a relation between anticodes and minihypers (\\cite{doi:10.1201/9781315371993}, pg. 295)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"}]},"_zoodb":{"id":"projective","source_file_path":"codes/classical/q-ary_digits/projective/projective.yml","source_file_modification_token":1683723710991.311}},"projective_two_weight":{"code_id":"projective_two_weight","physical":"q-ary_digits","logical":"q-ary_digits","name":"Projective two-weight code","description":"A projective code whose codewords all have one of two possible nonzero Hamming weights.\n\nThere is a correspondence between projective two-weight codes, projective two-character sets, and certain strongly regular graphs \\cite{doi:10.1016/0012-365X(72)90024-6}.\nAs such, projective two-weight codes have been classified and can be constructed out of quadrics \\cite{doi:10.1109/18.748994,doi:10.1016/S0012-365X(02)00390-4}, maximal arcs and hyperovals, Baer spaces, or Hermitian quadrics \\cite{preset:HKStwoweight}.\nThere are also several sporadic examples \\cite[Table 19.1]{preset:HKStwoweight}.\n","relations":{"parents":[{"code_id":"projective"},{"code_id":"two_weight"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-15"}]},"_zoodb":{"id":"projective_two_weight","source_file_path":"codes/classical/q-ary_digits/projective/projective_two_weight.yml","source_file_modification_token":1682250129450.6401}},"simplex":{"code_id":"simplex","physical":"q-ary_digits","logical":"q-ary_digits","name":"Simplex code","description":"Also known as a \\textit{maximum length feedback shift register code}. An \\([n,k,q^{k-1}]_q\\) projective code with \\(n=\\frac{q^k-1}{q-1}\\), denoted as \\(S(q,k)\\). The columns of the generator matrix are in one-to-one correspondence with the elements of the projective space \\(PG(k-1,q)\\), with each column being a chosen representative of the corresponding element. Its dual code is the \\([n,n-k,3]_q\\) \\(q\\)-ary Hamming code. The name of the code comes from the property that, for \\(q=2\\), the codewords form a \\((2^k-1)\\)-simplex of constant edge length if the codewords are interpreted as points in \\(\\mathbb{R}^n\\).\n","features":{"decoders":["Due to the small size, it can be decoded according to maximum likelihood.","Some faster decoders for the \\(q=2\\) case: \\cite{manual:{R. R. Green, \"A serial orthogonal decoder,\" JPL Space Programs Summary, vol. 37–39-IV, pp. 247–253, 1966.},doi:10.1109/ITW.2003.1216684}","A quantum decoder for the \\(q=2\\) case: \\cite{manual:{A. Barg and S. Zhou, “A quantum decoding algorithm for the simplex code”, in Proceedings of the 36th Annual Allerton Conference on Communication, Control and Computing, Monticello, IL, 23–25 September 1998 (UIUC 1998) 359–365}}."]},"notes":["See corresponding MinT database entry \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Simplex Code.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html}}."],"relations":{"parents":[{"code_id":"incidence_matrix","detail":"Columns of a simplex code's generator matrix correspond to one-dimensional subspaces of \\(GF(q)^n\\)."},{"code_id":"griesmer","detail":"Simplex codes saturate the Griesmer bound (\\cite{doi:10.1201/9781315371993}, Exer. 5.1.11)."},{"code_id":"constant_weight","detail":"All non-zero simplex codewords have a constant weight of \\(q^{k-1}\\)."},{"code_id":"univ_opt_q-ary","detail":"Simplex codes and their punctured versions are LP universally optimal codes \\cite{arxiv:1212.1913}."}],"cousins":[{"code_id":"extended_reed_solomon","detail":"\\(S(2,k)\\) is an extended RS code \\cite{manual:{Rudolf Schürer and Wolfgang Ch. Schmid. “Simplex Code.” From MinT—the database of optimal net, code, OA, and OOA parameters. Version: 2015-09-03. http://mint.sbg.ac.at/desc_CSimplex.html}}."},{"code_id":"repetition","detail":"\\(S(2,1)\\) reduces to the repetition code."},{"code_id":"q-ary_hamming","detail":"Hamming and simplex codes are dual to each other."},{"code_id":"hadamard","detail":"Binary simplex codes are \\([2^m-1,m,2^{m-1}]\\) shortened Hadamard codes."},{"code_id":"simplex_spherical","detail":"Binary simplex codes map to simplex spherical codes under the antipodal mapping \\cite[Sec. 6.5.2]{manual:{Forney, G. D. (2003). 6.451 Principles of Digital Communication II, Spring 2003.}}\\cite[pg. 18]{preset:EricZin}. In other words, simplex (simplex spherical) codes form simplices in Hamming (Euclidean) space."},{"code_id":"reed_muller","detail":"Binary simplex codes can be constructed from the generator matrix of RM\\((1,k)\\) by removing first the all-ones row, and then the all-zero column. Punctured RM codes and simplex codes are interconvertible via expurgation and augmentation (\\cite{preset:MacSlo}, pg. 31)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-09"},{"user_id":"YiTingRickTu","date":"2022-03-28"}]},"_zoodb":{"id":"simplex","source_file_path":"codes/classical/q-ary_digits/projective/simplex.yml","source_file_modification_token":1683723710991.4375}},"q-ary_additive":{"code_id":"q-ary_additive","physical":"q-ary_digits","logical":"q-ary_digits","name":"Additive \\(q\\)-ary code","description":"A \\(q\\)-ary code whose codewords are closed under addition, i.e., for any codewords \\(x,y\\), \\(x+y\\) is also a codeword.","relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"},{"code_id":"group_linear","detail":"Additive \\(q\\)-ary codes are linear over \\(G=GF(q)\\) since Galois fields are abelian groups under addition."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-19"},{"user_id":"ShuubhamOjha","date":"2022-05-18"}]},"_zoodb":{"id":"q-ary_additive","source_file_path":"codes/classical/q-ary_digits/q-ary_additive.yml","source_file_modification_token":1678631058725.1047}},"q-ary_digits_into_q-ary_digits":{"code_id":"q-ary_digits_into_q-ary_digits","physical":"q-ary_digits","logical":"q-ary_digits","name":"Galois-field \\(q\\)-ary code","short_name":"\\(q\\)-ary","description":"Encodes \\(K\\) states (codewords) in \\(n\\) \\(q\\)-ary coordinates over the field \\(GF(q)=\\mathbb{F}_q\\) and has distance \\(d\\). Usually denoted as \\((n,K,d)_q\\). The distance is the minimum number of coordinates where two strings in the code differ.","protection":"The standard metric for Galois-field \\(q\\)-ary codes is the Hamming metric, but other metrics also exist \\cite{arxiv:2212.00431}. Detects errors on up to \\(d-1\\) coordinates, corrects erasure errors on up to \\(d-1\\) coordinates, and corrects general errors on up to \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) coordinates.","features":{"rate":"The rate of a \\(q\\)-ary code is usually defined as \\(R=\\frac{1}{n}\\log_{q}K\\) dits per symbol.","decoders":["For small \\(n\\), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}.","Given a received string \\(x\\) and an error bound \\(e\\), a \\textit{list decoder} returns a list of all codewords that are at most \\(e\\) from \\(x\\). The number of codewords in a neighborhood of \\(x\\) has to be polynomial in \\(n\\) in order for this decoder to run in time polynomial in \\(n\\)."]},"notes":["Tables of bounds and examples of linear codes for various \\(n\\) and \\(k\\), extending code tables by Brouwer \\cite{manual:{Andries E. Brouwer, Bounds on linear codes, in: Vera S. Pless and W. Cary Huffman (Eds.), Handbook of Coding Theory, pp. 295-461, Elsevier, 1998.}}, are maintained by M. Grassl at this \\href{http://codetables.markus-grassl.de/}{website}."],"relations":{"parents":[{"code_id":"rings_into_rings","detail":"Galois fields are rings under addition."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-16"},{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"q-ary_digits_into_q-ary_digits","source_file_path":"codes/classical/q-ary_digits/q-ary_digits_into_q-ary_digits.yml","source_file_modification_token":1678631058725.2065}},"q-ary_linear":{"code_id":"q-ary_linear","physical":"q-ary_digits","logical":"q-ary_digits","name":"Linear \\(q\\)-ary code","description":"An \\((n,K,d)_q\\) linear code is denoted as \\([n,k,d]_q\\), where \\(k=\\log_{q}K\\) need not be an integer. Its codewords form a linear subspace, i.e., for any codewords \\(x,y\\), \\(\\alpha x+ \\beta y\\) is also a codeword for any \\(q\\)-ary digits \\(\\alpha,\\beta\\).\nThis extra structure yields much information about their properties, making them a large and well-studied subset of codes.\n\nLinear codes can be defined in terms of a \\textit{generator matrix} \\(G\\), whose rows form a basis for the \\(k\\)-dimensional codespace. Given a message \\(x\\), the corresponding encoded codeword is \\(G^T x\\). The generator matrix can be reduced via coordinate permutations to its \\textit{standard} or \\textit{systematic form} \\(G = [I_k~~A]\\), where \\(I_k\\) is a \\(k\\times k\\) identity matrix and \\(A\\) is a \\(k \\times (n-k)\\) \\(q\\)-ary matrix.\n\nThe two extreme cases are the \\([n,0,n]\\) \\textit{zero code} and its dual the \\([n,n,1]\\) \\textit{universe code}.\n","protection":"Distance \\(d\\) of a linear code is the number of nonzero entries in the (nonzero) codeword with the smallest such number. Corrects any error set such that the difference of any pair of distinct elements of the set is a codeword.","features":{"decoders":["Maximum likelihood (ML) decoding. This algorithm decodes a received word to the most likely sent codeword based on the received word. ML decoding of reduced complexity is possible for virtually all \\(q\\)-ary linear codes \\cite{doi:10.1109/ISIT.1997.613333}.","Optimal symbol-by-symbol decoding rule \\cite{doi:10.1109/TIT.1976.1055617}.","Information set decoding (ISD) \\cite{doi:10.1007/978-3-642-12929-2_7}, a probabilistic decoding strategy that essentially tries to guess \\(k\\) correct positions in the received word, where \\(k\\) is the size of the code. Then, an error vector is constructed to map the received word onto the nearest codeword, assuming the \\(k\\) positions are error free. When the Hamming weight of the error vector is low enough, that codeword is assumed to be the intended transmission.","Generalized minimum-distance decoder \\cite{doi:10.1109/TIT.1966.1053873}.","Soft-decision maximum-likelihood trellis-based decoder \\cite{doi:10.1109/TIT.1978.1055821}.","Random linear codes over large fields are list-recoverable and list-decodable up to near-optimal rates \\cite{arXiv:1704.02420}.","Extensions of algebraic-geometry decoders to linear codes \\cite{manual:{R. Kotter. A unified description of an error locating procedure for linear codes. In D. Yorgov, editor, Proc. 3rd International Workshop on Algebraic and Combinatorial Coding Theory, pages 113–117, Voneshta Voda, Bulgaria, June 1992. Hermes.},doi:10.1016/0012-365X(92)90567-Y}."]},"notes":["Admits a parity check matrix \\(H\\), whose columns make up a maximal linearly independent set of vectors that are in the kernel of \\(G\\).","University of Salzburg's \\href{http://mint.sbg.ac.at/table.php?i=c}{MinT application} generates an optimal parameter table for a linear code \\([n,k,d]_q\\), contingent on an optional fluctuation of maximal Hamming code distance, rank, and length, along with other specifications."],"relations":{"parents":[{"code_id":"q-ary_additive","detail":"For \\(q>2\\), additive codes need not be linear since linearity also requires closure under multiplication."},{"code_id":"rings_linear","detail":"Linear \\(q\\)-ary codes are \\(GF(q)\\)-linear."}],"cousins":[{"code_id":"q-ary_ltc","detail":"Linear \\(q\\)-ary codes with distances \\(\\frac{1}{2}n-\\sqrt{t n}\\) for some \\(t\\) are called almost-orthogonal and are locally testable with query complexity of order \\(O(t)\\) \\cite{doi:10.1109/SFCS.2005.16}. This was later improved to codes with distance \\(\\frac{1}{2}n-O(n^{1-\\gamma})\\) for any positive \\(\\gamma\\) \\cite{doi:10.1109/FOCS.2007.8}, provided that the number of codewords is polynomial in \\(n\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-04"},{"user_id":"MicahShaw","date":"2022-06-08"},{"user_id":"VictorVAlbert","date":"2022-03-21"},{"user_id":"VictorVAlbert","date":"2021-10-30"}]},"_zoodb":{"id":"q-ary_linear","source_file_path":"codes/classical/q-ary_digits/q-ary_linear.yml","source_file_modification_token":1683723710991.5483}},"cycle_ldpc":{"code_id":"cycle_ldpc","physical":"q-ary_digits","logical":"q-ary_digits","name":"Cycle LDPC code","introduced":"\\cite{doi:10.1109/TIT.1968.1054190}","alternative_names":["Non-binary LDPC (NBDPC) code"],"description":"A \\(q\\)-ary LDPC code whose parity-check matrix has weight-two columns.\nNon-binary cycle LDPC codes for \\(q\\geq 32\\) exihibit good performance \\cite{doi:10.1109/ICC.2004.1312545,doi:10.1109/ITW.2007.4313042,doi:10.1109/TCOMM.2008.060527}.\n","protection":"The minimum distance of a binary cycle LDPC code is \\(d\\geq g/2\\), where \\(g\\) is the girth of the code's Tanner graph \\cite{preset:HKSgraphs}.\n","features":{"rate":"Binary cycle LDPC codes are not asymptotically good \\cite{doi:10.1109/ISIT.1994.394711}.","encoders":["Linear-time encoder \\cite{doi:10.1109/LCOMM.2006.1633326}."]},"realizations":["Cycle LDPC codes have been proposed to be used for MIMO channels \\cite{doi:10.1109/TWC.2008.070057}."],"relations":{"parents":[{"code_id":"q-ary_ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"cycle_ldpc","source_file_path":"codes/classical/q-ary_digits/tanner/cycle_ldpc.yml","source_file_modification_token":1683723710991.705}},"q-ary_ldgm":{"code_id":"q-ary_ldgm","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary LDGM code","description":"\\(q\\)-ary linear code with a sparse generator matrix.\nAlternatively, a member of an infinite family of \\([n,k,d]_q\\) codes for which the number of nonzero entries in each row and column of the generator matrix are both bounded by a constant as \\(n\\to\\infty\\).\n","relations":{"parents":[{"code_id":"q-ary_linear"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"q-ary_ldgm","source_file_path":"codes/classical/q-ary_digits/tanner/q-ary_ldgm.yml","source_file_modification_token":1683723710991.767}},"q-ary_ldpc":{"code_id":"q-ary_ldpc","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary LDPC code","introduced":"\\cite{doi:10.1109/ITW.1998.706440}","alternative_names":["Non-binary LDPC (NBDPC) code"],"description":"A \\(q\\)-ary linear code with a sparse parity-check matrix.\nAlternatively, a member of an infinite family of \\([n,k,d]_q\\) codes for which the number of nonzero entries in each row and column of the parity-check matrix are both bounded above by a constant as \\(n\\to\\infty\\).\n\nA \\textit{parity check} is performed by taking the inner product of a row of the parity-check matrix with a codeword that has been affected by a noise channel.\nA parity check yields either zero (no error) or a nonzero field element (error).\nDespite the fact that there is more than one nonzero outcome, \\(q>2g\\)-ary linear codes with sparse parity-check matrices are also called LDPC codes.\n","relations":{"parents":[{"code_id":"tanner","detail":"\\(q\\)-ary LDPC codes are \\(q\\)-ary Tanner codes on sparse bipartite graphs whose constraint nodes represent \\(q\\)-ary parity-check codes."}],"cousins":[{"code_id":"q-ary_ldgm","detail":"The dual of a \\(q\\)-ary LDPC code has a sparse generator matrix and is called a \\(q\\)-ary LDGM code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"q-ary_ldpc","source_file_path":"codes/classical/q-ary_digits/tanner/q-ary_ldpc.yml","source_file_modification_token":1683723710991.8186}},"q-ary_protograph_ldpc":{"code_id":"q-ary_protograph_ldpc","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary protograph LDPC code","introduced":"\\cite{doi:10.1109/ISTC.2010.5613806,doi:10.1109/ISIT.2011.6034271,doi:10.1109/ISIT.2014.6874958,doi:10.1109/TIT.2014.2316215}","description":"\\(q\\)-ary LDPC code whose parity-check matrix is constructed using the \\hyperref[topic:lifting]{lifting} procedure as well as using \\textit{edge scaling}, i.e., the ability to assign non-binary edge weights.\n","protection":"Minimum distance bounds \\cite{doi:10.1109/ITA.2012.6181802}.\n","relations":{"parents":[{"code_id":"q-ary_ldpc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"q-ary_protograph_ldpc","source_file_path":"codes/classical/q-ary_digits/tanner/q-ary_protograph_ldpc.yml","source_file_modification_token":1683723710991.8772}},"tanner":{"code_id":"tanner","physical":"q-ary_digits","logical":"q-ary_digits","name":"Tanner code","introduced":"\\cite{doi:10.1109/TIT.1981.1056404}","alternative_names":["Generalized LDPC (GLDPC) code"],"description":"A linear \\(q\\)-ary code defined on a bipartite graph similar to a Tanner graph.\nThis \\textit{generalized Tanner graph} consists of variable nodes and constraint nodes, with the generalization being that the constraint nodes of degree \\(r\\) now represent a linear codes of length \\(r\\).\n\nA string is in the Tanner code if all substrings satisfy their corresponding constraints, i.e., all substrings are members of the linear codes represented on the constraint nodes.\n\nA code is called \\textit{regular} if the corresponding bipartite graph is regular.\nExpansion properties of the underlying graph can yield efficient decoding algorithms.\n","features":{"decoders":["Min-sum and sum-product iterative decoders for binary Tanner codes \\cite{doi:10.1002/ett.4460060507,manual:{Niclas Wiberg, \\emph{Codes and decoding on general graphs}. 1996. PhD thesis, Linköping University, Linköping, Sweden}}; see also \\cite{manual:{Brendan J. Frey. Graphical models for machine learning and digital communication. MIT press, 1998.},doi:10.1017/CBO9780511606267}. These decoders can be improved using a probabilistic message-passing schedule \\cite{doi:10.1109/PACRIM.2001.953537}.","Any code can be put into normal form without significantly altering the underlying graph or the decoding complexity \\cite{doi:10.1109/ISIT.2000.866299}. For an algebraic viewpoint on decoding, see \\cite{doi:10.1016/S1571-0653(04)00166-0}.","Iterative decoding is optimal for Tanner graphs that are free of cycles \\cite{manual:{Niclas Wiberg, \\emph{Codes and decoding on general graphs}. 1996. PhD thesis, Linköping University, Linköping, Sweden}}. However, codes that admit cycle-free representations have bounds on their distances \\cite{doi:10.1109/18.782170,doi:10.1109/TIT.1981.1056404}; see \\cite{preset:HKSgraphs,doi:10.1201/b11707}."]},"relations":{"parents":[{"code_id":"q-ary_linear"},{"code_id":"parallel_concatenated"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-04"}]},"_zoodb":{"id":"tanner","source_file_path":"codes/classical/q-ary_digits/tanner/tanner.yml","source_file_modification_token":1683723710991.944}},"delsarte_optimal_q-ary":{"code_id":"delsarte_optimal_q-ary","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(q\\)-ary sharp configuration","introduced":"\\cite{doi:10.1007/BF00053379,preset:LevBounds,arxiv:1212.1913}","description":"A \\(q\\)-ary code that admits \\(m\\) different distances between distinct codewords and forms a design of strength \\(2m-1\\) or greater.\n","relations":{"parents":[{"code_id":"univ_opt_q-ary","detail":"All \\(q\\)-ary sharp configurations are universally optimal \\(q\\)-ary codes \\cite{arxiv:1212.1913}, but the converse is not true."},{"code_id":"delsarte_optimal"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"delsarte_optimal_q-ary","source_file_path":"codes/classical/q-ary_digits/universally_optimal/delsarte_optimal_q-ary.yml","source_file_modification_token":1678631058725.4182}},"semakov_zinoviev":{"code_id":"semakov_zinoviev","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\(ED_m\\) code","introduced":"\\cite{manual:{N. V. Semakov, V. A. Zinoviev, “Equidistant q-ary Codes with Maximal Distance and Resolvable Balanced Incomplete Block Designs”, Probl. Peredachi Inf., 4:2 (1968), 3–10; Problems Inform. Transmission, 4:2 (1968), 1–7}}","description":"Also called an \\textit{equidistant code with maximal distance}.\nMember of the family of \\( (c\\frac{qt-1}{(t-1,q-1)},qt,ct\\frac{q-1}{(t-1,q-1)}) \\) \\(q\\)-ary codes, where \\(c,t\\geq 1\\) and \\((a,b)\\) is the greatest common divisor of \\(a\\) and \\(b\\).\nSuch codes are universally optimal and are related to resolvable block designs.\n","relations":{"parents":[{"code_id":"delsarte_optimal_q-ary","detail":"The \\(ED_m\\) code is a \\(q\\)-ary sharp configuration \\cite[Table 12.1]{preset:HKSbounds}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"semakov_zinoviev","source_file_path":"codes/classical/q-ary_digits/universally_optimal/semakov_zinoviev.yml","source_file_modification_token":1682250129450.7295}},"semakov_zinoviev_zaitsev":{"code_id":"semakov_zinoviev_zaitsev","physical":"q-ary_digits","logical":"q-ary_digits","name":"Semakov-Zinoviev-Zaitsev (SZZ) equidistant code","short_name":"SZZ equidistant","introduced":"\\cite{manual:{N. V. Semakov, V. A. Zinoviev, G. V. Zaitsev, “A Class of Maximum Equidistant Codes”, Probl. Peredachi Inf., 5:2 (1969), 84–87; Problems Inform. Transmission, 5:2 (1969), 65–68}}","description":"Member of a family that is related to affine resolvable block designs and that is universally optimal.\n","relations":{"parents":[{"code_id":"delsarte_optimal_q-ary","detail":"The SZZ equidistant code is a \\(q\\)-ary sharp configuration \\cite[Table 12.1]{preset:HKSbounds}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"semakov_zinoviev_zaitsev","source_file_path":"codes/classical/q-ary_digits/universally_optimal/semakov_zinoviev_zaitsev.yml","source_file_modification_token":1682250129450.8105}},"univ_opt_q-ary":{"code_id":"univ_opt_q-ary","physical":"q-ary_digits","logical":"q-ary_digits","name":"Universally optimal \\(q\\)-ary code","introduced":"\\cite{manual:{V. I. Levenshtein. Bounds for packings of metric spaces and some of their applications. Problemy Kibernet, 40 (1983), 43-110.},doi:10.1109/18.412678,doi:10.1007/BF00053379,preset:LevBounds,doi:10.1007/s10623-016-0286-4,doi:10.1109/18.915662,arxiv:1212.1913}","description":"A binary or \\(q\\)-ary code that (weakly) minimizes all completely monotonic potentials on binary space \\cite{arxiv:1212.1913}.\n\nAll codes that obtain a linear programming (LP) bound by Delsarte \\cite{manual:{P. Delsarte, “Bounds for unrestricted codes, by linear programming,” Philips Research Reports, vol. 27, pp. 272–289, 1972}} are universally optimal \\cite{arxiv:1212.1913}.\nSuch codes are called \\textit{LP universally optimal} or \\textit{extremal}.\nHowever, not all universally optimal codes attain the Delsarte LP bound.\nSee \\cite[Table 12.1]{preset:HKSbounds} (\\cite[Table 1]{arxiv:1212.1913}) for a list of (LP) universally optimal codes.\nSee \\cite[Sec. 12.4]{preset:HKSbounds} for further discussion.\n\nAll codes that attain the Levenshtein bound \\cite{manual:{V. I. Levenshtein. Bounds for packings of metric spaces and some of their applications. Problemy Kibernet, 40 (1983), 43-110.},doi:10.1109/18.412678,doi:10.1007/BF00053379,preset:LevBounds}, which estimates the solution to Delsarte's linear program, are universally optimal \\cite{doi:10.1007/s10623-016-0286-4}; see \\cite[Thm. 12.3.23]{preset:HKSbounds}.\nHowever, not all universally optimal codes attain the Levenshtein bound.\n","relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"},{"code_id":"univ_opt"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"univ_opt_q-ary","source_file_path":"codes/classical/q-ary_digits/universally_optimal/univ_opt_q-ary.yml","source_file_modification_token":1682250129450.8918}},"uplusv":{"code_id":"uplusv","physical":"q-ary_digits","logical":"q-ary_digits","name":"\\((u|u+v)\\)-construction code","introduced":"\\cite{doi:10.1109/TIT.1960.1057584,doi:10.1109/TIT.1970.1054540}","description":"Code constructed using a concatenation procedure that takes in two \\(q\\)-ary codes \\(C_1,C_2\\) and produces a new code whose codewords are \\((u|u+v)\\) for all \\(u\\in C_1\\) and \\(v\\in C_2\\).\nIf the two codes have parameters \\((n,K_1,d_1)\\) and \\((n,K_2,d_2)\\), then the output code is a \\((2n,K_1 K_2, \\min\\{2d_1,d_2\\})\\) code \\cite[Thm. 5.10]{doi:10.1201/9781315371993}\\cite[pg. 76]{preset:MacSlo}.\n","relations":{"parents":[{"code_id":"matrix_product"}],"cousins":[{"code_id":"hamming743","detail":"Starting with the \\([6,3,3]\\) shortened Hamming code and applying the \\((u|u+v)\\) construction recursively using the repetition code yields a family of \\([2^m,m+1,2^{m-1}]\\) codes for \\(m\\geq1\\) that saturate the Griesmer bound \\cite[pg. 90]{doi:10.1201/9781315371993}."},{"code_id":"binary_quad_residue","detail":"The \\((u|u+v)\\) construction can be used to obtain nonlinear binary quadratic residue codes \\cite{doi:10.1109/TIT.1970.1054540}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-31"}]},"_zoodb":{"id":"uplusv","source_file_path":"codes/classical/q-ary_digits/uplusv.yml","source_file_modification_token":1680994436846.412}},"balanced":{"code_id":"balanced","physical":"q-ary_digits","logical":"q-ary_digits","name":"Balanced code","introduced":"\\cite{doi:10.1109/TIT.1986.1057136}","description":"An even-length-\\(n\\) \\(q\\)-ary code whose nonzero codewords all have a Hamming weight of \\(n/2\\).\nA code is \\(\\epsilon\\)\\textit{-balanced} if the relative weight (i.e., weight divided by \\(n\\)) of all nonzero codewords lies in the interval \\([\\frac{1-\\epsilon}{2},\\frac{1+\\epsilon}{2}]\\).\nA code is \\(\\gamma\\)\\textit{-unbiased} if the relative weight lies in the interval \\((\\frac{1}{2}-\\frac{1}{n^{\\gamma}},\\frac{1}{2}+\\frac{1}{n^{\\gamma}})\\).\n","protection":"Can detect unidirectional errors, such as a zero going to a one.","features":{"encoders":["Efficient encoder \\cite{doi:10.1109/TIT.1986.1057136}."],"decoders":["Efficient decoder \\cite{doi:10.1109/TIT.1986.1057136,doi:10.1109/18.52490,doi:10.1109/jsac.2010.100207}."]},"realizations":["Balanced length-eight code, known as a 6b/8b encoding, used for balancing direct current in a communications system \\cite{preset:Kees}"],"relations":{"parents":[{"code_id":"q-ary_digits_into_q-ary_digits"},{"code_id":"constant_weight"}],"cousins":[{"code_id":"ltc","detail":"Random low-rate unbiased linear codes are LTCs \\cite{doi:10.1145/1806689.1806748}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-14"}]},"_zoodb":{"id":"balanced","source_file_path":"codes/classical/q-ary_digits/weight/balanced.yml","source_file_modification_token":1682420107452.6577}},"divisible":{"code_id":"divisible","physical":"q-ary_digits","logical":"q-ary_digits","name":"Divisible code","introduced":"\\cite{doi:10.1007/BF01223730}","description":"A linear \\(q\\)-ary block code is \\(\\Delta\\)-divisible if the Hamming weight of each of its codewords is divisible by divisor \\(\\Delta\\).\nA \\(2\\)-divisible (\\(4\\)-divisible) code is called \\textit{even} (\\textit{doubly-even}) \\cite{arxiv:2112.11763,doi:10.1007/978-1-4757-6568-7}.\nA code is called \\textit{singly-even} if all codewords are even and at least one has weight equal to 2 modulo 4.\n","notes":["See Ref. \\cite{arXiv:1012.4134} for an introduction to \\textit{triply-even} binary linear codes and their construction from doubly-even codes."],"relations":{"parents":[{"code_id":"q-ary_linear"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-14"}]},"_zoodb":{"id":"divisible","source_file_path":"codes/classical/q-ary_digits/weight/divisible.yml","source_file_modification_token":1682420107452.776}},"two_weight":{"code_id":"two_weight","physical":"q-ary_digits","logical":"q-ary_digits","name":"Two-weight code","description":"A linear \\(q\\)-ary code whose codewords all have one of two possible nonzero Hamming weights.\n","notes":["See \\cite{preset:HKStwoweight}\\cite{doi:10.1112/blms/18.2.97} for overviews of two-weight codes and Refs. \\cite{doi:10.1007/s10623-010-9394-8,doi:10.1007/s10623-006-9024-7} for examples.","There is a classification of two-weight codes of length 40 \\cite{doi:10.1109/TIT.2015.2440266} as well as of \\([n,m,d]_q\\) codes with the two weights \\(n,d\\) \\cite{doi:10.1016/j.ffa.2017.12.010}.","Sizes of maximal two-weight, three-weight, and four-weight binary codes have been determined \\cite{arxiv:2210.07496}."],"relations":{"parents":[{"code_id":"q-ary_linear"}],"cousins":[{"code_id":"divisible","detail":"Two-weight codes are \\(m\\)-divisible, where \\(m\\) is the greatest common factor of their two possible weights."},{"code_id":"projective","detail":"There are several correpondences between projective and two-weight codes \\cite{doi:10.1023/A:1008294128110,doi:10.1112/blms/18.2.97,doi:10.1016/j.ffa.2017.12.010}."},{"code_id":"weight_two","detail":"Codewords of two-weight codes have one of two possible Hamming weights, while those of weight-two codes have Hamming weight two."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-15"}]},"_zoodb":{"id":"two_weight","source_file_path":"codes/classical/q-ary_digits/weight/two_weight.yml","source_file_modification_token":1682420107452.8936}},"wozencraft":{"code_id":"wozencraft","physical":"q-ary_digits","logical":"q-ary_digits","name":"Wozencraft ensemble code","introduced":"\\cite{manual:{J. L. Massey, Threshold Decoding. Cambridge, MA: M.I.T. Press, 1963.}}","description":"Stub.","relations":{"parents":[{"code_id":"q-ary_linear"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-22"}]},"_zoodb":{"id":"wozencraft","source_file_path":"codes/classical/q-ary_digits/wozencraft.yml","source_file_modification_token":1678631058725.918}},"dual_over_rings":{"code_id":"dual_over_rings","physical":"q-ary_digits","logical":"q-ary_digits","name":"Dual code over \\(R\\)","description":"For any \\(q\\)-ary linear code \\(C\\) over a ring \\(R\\), the dual code over \\(R\\) is\n\\begin{align}\nC^\\perp = \\{ y\\in R^{n} ~|~ x \\cdot y=0 \\forall x\\in C\\},\n\\end{align}\nwhere the \\textit{ordinary}, \\textit{standard}, or \\textit{Euclidean} inner product is \\(x\\cdot y = \\sum_{i=1}^n x_i y_i\\) for coordinates \\(x_i,y_i\\).\n\nA code that is contained in its dual, \\(C \\subseteq C^\\perp\\), is called \\textit{self-orthogonal over \\(R\\)} or \\textit{weakly self-dual over \\(R\\)}.\nA code that contains its dual, \\(C^\\perp \\subseteq C\\), is called \\textit{dual-containing over \\(R\\)}.\nA code that is equal to its dual, \\(C^\\perp = C\\), is called \\textit{self-dual over \\(R\\)}.\nA code is dual-containing over \\(R\\) iff its dual is self-orthogonal over \\(R\\).\n","relations":{"parents":[{"code_id":"rings_linear"}],"cousins":[{"code_id":"dual"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"}]},"_zoodb":{"id":"dual_over_rings","source_file_path":"codes/classical/rings/dual_over_rings.yml","source_file_modification_token":1682420107452.9902}},"octacode":{"code_id":"octacode","physical":"rings","logical":"rings","name":"Octacode","introduced":"\\cite{doi:10.1016/0097-3165(93)90070-O,doi:10.1007/978-1-4757-6568-7,arXiv:math/0208001}","description":"The unique self-dual linear code of length 8 over \\(\\mathbb{Z}_4\\) with generator matrix\n\\begin{align}\n  \\begin{pmatrix}\n  3 & 3 & 2 & 3 & 1 & 0 & 0 & 0\\\\\n  3 & 0 & 3 & 2 & 3 & 1 & 0 & 0\\\\\n  3 & 0 & 0 & 3 & 2 & 3 & 1 & 0\\\\\n  3 & 0 & 0 & 0 & 3 & 2 & 3 & 1\n  \\end{pmatrix}\\,.\n\\end{align}\n","relations":{"parents":[{"code_id":"quaternary_over_z4"},{"code_id":"cyclic","detail":"The octacode is a cyclic code over \\(\\mathbb{Z}_4\\) with generator polynomial \\(x^2+3x^2+2x+3\\) extended by a parity check \\cite{doi:10.1007/3-540-30731-1}."},{"code_id":"dual_over_rings","detail":"The octacode is self-dual over \\(\\mathbb{Z}_4\\)."}],"cousins":[{"code_id":"hamming844","detail":"The octacode reduces modulo-two to the \\([8,4,4]\\) extended Hamming code \\cite{doi:10.1007/3-540-30731-1}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-11"}]},"_zoodb":{"id":"octacode","source_file_path":"codes/classical/rings/octacode.yml","source_file_modification_token":1682420107453.1086}},"q-ary_over_zq":{"code_id":"q-ary_over_zq","physical":"rings","logical":"rings","name":"\\(q\\)-ary code over \\(\\mathbb{Z}_q\\)","description":"A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_q\\) of integers modulo \\(q\\).","relations":{"parents":[{"code_id":"rings_linear"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"}]},"_zoodb":{"id":"q-ary_over_zq","source_file_path":"codes/classical/rings/q-ary_over_zq.yml","source_file_modification_token":1678631058726.0146}},"quaternary_over_z4":{"code_id":"quaternary_over_z4","physical":"rings","logical":"rings","name":"Quaternary code over \\(\\mathbb{Z}_4\\)","description":"A linear code encoding \\(K\\) states (codewords) in \\(n\\) coordinates over the ring \\(\\mathbb{Z}_4\\) of integers modulo 4.","notes":["Code \\href{http://quantumcodes.info/Z4/}{Database}, including quasi-cyclic and quasi-twisted codes \\cite{arxiv:2208.06832}."],"relations":{"parents":[{"code_id":"q-ary_over_zq"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-04"}]},"_zoodb":{"id":"quaternary_over_z4","source_file_path":"codes/classical/rings/quaternary_over_z4.yml","source_file_modification_token":1678631058726.1162}},"rings_into_rings":{"code_id":"rings_into_rings","physical":"rings","name":"Ring code","description":"Encodes \\(K\\) states (codewords) in \\(n\\) coordinates over a finite ring \\(R\\).","relations":{"parents":[{"code_id":"block"},{"code_id":"ecc_finite"},{"code_id":"group_classical","detail":"A ring \\(R\\) is an abelian group under addition."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-16"}]},"_zoodb":{"id":"rings_into_rings","source_file_path":"codes/classical/rings/rings_into_rings.yml","source_file_modification_token":1678631058726.2095}},"rings_linear":{"code_id":"rings_linear","physical":"rings","logical":"rings","name":"\\(R\\)-linear code","description":"A code of length \\(n\\) over a ring \\(R\\) is \\(R\\)-linear if it is a submodule of \\(R^n\\).","relations":{"parents":[{"code_id":"rings_into_rings"},{"code_id":"group_linear","detail":"\\(R\\)-linear codes are linear over \\(G=R\\) since rings are abelian groups under addition."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-04"}]},"_zoodb":{"id":"rings_linear","source_file_path":"codes/classical/rings/rings_linear.yml","source_file_modification_token":1678631058726.3123}},"permutation_spherical":{"code_id":"permutation_spherical","physical":"spheres","logical":"reals","name":"Permutation spherical code","introduced":"\\cite{doi:10.1109/PROC.1965.3680,doi:10.1109/18.57208}","description":"Slepian group-orbit code whose codewords are constructed from an arbitrary unit vector in two possible variants. Variant 1 consists of codewords that are permutations of the vector's coordinates, while Variant 2 consists of such permutations and all possible sign changes of the vector's components.\n","features":{"rate":"Number of codewords cannot increase exponentially with dimension \\(n\\) \\cite{doi:10.1109/TIT.1971.1054601}","decoders":["Efficient maximum-likelihood decoder determining the Voronoi region of an error word."]},"notes":["See \\cite[Ch. 4]{preset:EricZin} for more details and tables of optimal codes."],"relations":{"parents":[{"code_id":"slepian_group","detail":"Permutations and sign changes can be implemented on vectors by orthogonal matrices, so permutation spherical codes are Slepian group-orbit codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-03"}]},"_zoodb":{"id":"permutation_spherical","source_file_path":"codes/classical/spherical/group_orbit/permutation_spherical.yml","source_file_modification_token":1671665864788.2004}},"sidelnikov":{"code_id":"sidelnikov","physical":"spheres","logical":"reals","name":"Real-Clifford subgroup-orbit code","introduced":"\\cite{manual:{V. M. Sidelnikov, On a finite group of matrices and codes on the Euclidean sphere (in Russian), Probl. Peredach. Inform. 33 (1997), 35–54 (1997); English translation in Problems Inform. Transmission 33 (1997), 29–44},doi:10.1109/ISIT.1997.613373}","description":"Slepian group-orbit code of dimension \\(2^r\\), approximate asympotic size \\(2.38 \\cdot 2^{r(r+1)/2+1}\\), and distance \\(1\\).\nCode is constructed by applying elements of an index-two subgroup of the real Clifford group, when taken as a subgroup of the orthogonal group \\cite{arxiv:math/0001038}, onto the vector \\((1,0,0,\\cdots,0)\\).\nThis group is the automorphism group of BW lattice, and the resulting codes coincide with the optimal spherical codes for dimensions \\(\\{4,8,16\\}\\).\n\nTaking the orbit under the entire real Clifford group yields spherical codes twice the points and with distance \\(2-\\sqrt{2}\\).\n","relations":{"parents":[{"code_id":"slepian_group"},{"code_id":"spherical_design","detail":"The orbit of any point under the real Clifford subgroup is a spherical 7-design \\cite{doi:10.1023/A:1018723416627}, and some are 11-designs \\cite{manual:{V. M. Sidelnikov, “Orbital spherical 11-designs in which the initial point is a root of an invariant polynomial”, Algebra i Analiz, 11:4 (1999), 183–203; St. Petersburg Math. J., 11:4 (2000), 673–686}}."}],"cousins":[{"code_id":"barnes_wall","detail":"The automorphism group of BW lattices is a subgroup of index 2 of a real Clifford group \\cite{manual:{V. M. Sidelnikov, On a finite group of matrices and codes on the Euclidean sphere (in Russian), Probl. Peredach. Inform. 33 (1997), 35–54 (1997); English translation in Problems Inform. Transmission 33 (1997), 29–44},doi:10.1109/ISIT.1997.613373} (see \\cite{arxiv:math/0001038} for an explanation)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-22"}]},"_zoodb":{"id":"sidelnikov","source_file_path":"codes/classical/spherical/group_orbit/sidelnikov.yml","source_file_modification_token":1683978912606.5754}},"slepian_group":{"code_id":"slepian_group","physical":"spheres","logical":"reals","name":"Slepian group-orbit code","introduced":"\\cite{doi:10.1002/j.1538-7305.1968.tb02486.x,doi:10.1109/18.104333,doi:10.1109/18.485721}","description":"Spherical code in \\(n\\) dimensions whose codewords correspond to points in an orbit of some \\textit{initial vector} under a \\textit{generating group} \\(G\\), which is a subgroup of the orthogonal group \\(O(n)\\) of rotations in \\(n\\) dimensions, i.e., the \\textit{automorphism group} of spherical codes under the Euclidean distance.\nNeither the vector nor the group are unique for a given code.\n","protection":"Code properties depend on the relationship between the group and the initial vector, and the number of codewords is the number of cosets of an initial vector's symmetry subgroup in \\(G\\) per the orbit-stabilizer theorem.\nSee Refs. \\cite{manual:{Biggs, Norman. Finite groups of automorphisms: course given at the University of Southampton, October-December 1969. Vol. 6. CUP Archive, 1971.},doi:10.1109/TIT.1977.1055744,doi:10.1137/0134060,doi:10.1007/s10623-008-9183-9} for allowed code parameters.\n","notes":["See \\cite[Ch. 8]{preset:EricZin}\\cite{doi:10.1007/BFb0042068} for more details and code tables."],"relations":{"parents":[{"code_id":"spherical"},{"code_id":"group_orbit","detail":"Slepian group-orbit codes are group-orbit codes on spheres."}],"cousins":[{"code_id":"binary_linear","detail":"Any length-\\(n\\) binary linear code can be used to define a diagonal subgroup of \\(n\\)-dimensional rotation matrices with \\(\\pm 1\\) on the diagonals via the antipodal mapping \\(0\\to+1\\) and \\(1\\to-1\\). The orbit of this subgroup yields the corresponding Slepian group-orbit code; see \\cite[Thm. 8.5.2]{preset:EricZin}."},{"code_id":"binary_antipodal","detail":"Any length-\\(n\\) binary linear code can be used to define a diagonal subgroup of \\(n\\)-dimensional rotation matrices with \\(\\pm 1\\) on the diagonals via the antipodal mapping \\(0\\to+1\\) and \\(1\\to-1\\). The orbit of this subgroup yields the corresponding Slepian group-orbit code; see \\cite[Thm. 8.5.2]{preset:EricZin}."},{"code_id":"group_linear","detail":"Any finite-group code can be mapped to a Slepian group-orbit code by representing the group using orthogonal matrices \\cite{doi:10.1109/18.104333}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-18"}]},"_zoodb":{"id":"slepian_group","source_file_path":"codes/classical/spherical/group_orbit/slepian_group.yml","source_file_modification_token":1684508734541.1326}},"bw32_shell":{"code_id":"bw32_shell","physical":"spheres","logical":"reals","name":"\\(BW_{32}\\) lattice-shell code","description":"Spherical code whose codewords are points on the \\(BW_{32}\\) Barnes-Wall lattice normalized to lie on the unit sphere.\n\nThe minimal shell of the lattice yields the \\((32,146880,1)\\) code.\n","relations":{"parents":[{"code_id":"lattice_shell"},{"code_id":"sidelnikov","detail":"The minimal \\(BW_{32}\\) lattice-shell code is equivalent to the real Clifford subgroup-orbit code for \\(n=32\\)."}],"cousins":[{"code_id":"bw32"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-22"}]},"_zoodb":{"id":"bw32_shell","source_file_path":"codes/classical/spherical/lattice_shell/bw32_shell.yml","source_file_modification_token":1672500309959.224}},"dfour_shell":{"code_id":"dfour_shell","physical":"spheres","logical":"reals","name":"\\(D_4\\) lattice-shell code","description":"Spherical code whose codewords are points on the \\(D_4\\) lattice normalized to lie on the unit sphere.\n","relations":{"parents":[{"code_id":"lattice_shell"}],"cousins":[{"code_id":"dfour"},{"code_id":"spherical_design","detail":"\\(D_4\\) \\(2m\\)-shell codes can form spherical designs \\cite{arxiv:2303.09000}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"dfour_shell","source_file_path":"codes/classical/spherical/lattice_shell/dfour_shell.yml","source_file_modification_token":1687727505567.0864}},"eeight_shell":{"code_id":"eeight_shell","physical":"spheres","logical":"reals","name":"\\(E_8\\) Gosset lattice-shell code","description":"Spherical code whose codewords are points on the \\(E_8\\) Gosset lattice normalized to lie on the unit sphere.\n\nThe minimal shell of the lattice yields the \\((8,240,1)\\) code, whose codewords form the vertices of the \\(4_{21}\\) real polytope and the Witting complex polytope.\n","protection":"Smallest-shell code yields an optimal solution to the kissing problem in 8D \\cite{doi:10.1007/BF01442795,doi:10.4153/CJM-1981-038-7}.\n","relations":{"parents":[{"code_id":"lattice_shell"}],"cousins":[{"code_id":"eeight"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"eeight_shell","source_file_path":"codes/classical/spherical/lattice_shell/eeight_shell.yml","source_file_modification_token":1672500309959.3796}},"eseven_shell":{"code_id":"eseven_shell","physical":"spheres","logical":"reals","name":"\\(E_7\\) lattice-shell code","description":"Spherical code whose codewords are points on the \\(E_7\\) lattice normalized to lie on the unit sphere.\n","relations":{"parents":[{"code_id":"lattice_shell"}],"cousins":[{"code_id":"eseven"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-05"}]},"_zoodb":{"id":"eseven_shell","source_file_path":"codes/classical/spherical/lattice_shell/eseven_shell.yml","source_file_modification_token":1678631058726.4937}},"esix_shell":{"code_id":"esix_shell","physical":"spheres","logical":"reals","name":"\\(E_6\\) lattice-shell code","description":"Spherical code whose codewords are points on the \\(E_6\\) lattice normalized to lie on the unit sphere.\n\nThe minimal shell of the lattice yields the \\((6,72,1)\\) code, whose codewords form the vertices of the \\(1_{22}\\) real polytope and the rectified Hessian polyhedron.\n","relations":{"parents":[{"code_id":"lattice_shell"}],"cousins":[{"code_id":"esix"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-29"}]},"_zoodb":{"id":"esix_shell","source_file_path":"codes/classical/spherical/lattice_shell/esix_shell.yml","source_file_modification_token":1672500309959.4626}},"lambda16_shell":{"code_id":"lambda16_shell","physical":"spheres","logical":"reals","name":"\\(\\Lambda_{16}\\) lattice-shell code","description":"Spherical code whose codewords are points on the \\(\\Lambda_{16}\\) Barnes-Wall lattice normalized to lie on the unit sphere.\n\nThe minimal shell of the lattice yields the \\((16,4320,1)\\) code.\n","relations":{"parents":[{"code_id":"lattice_shell"},{"code_id":"sidelnikov","detail":"The minimal \\(\\Lambda_{16}\\) lattice-shell code is equivalent to the real Clifford subgroup-orbit code for \\(n=16\\)."}],"cousins":[{"code_id":"lambda16"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-22"}]},"_zoodb":{"id":"lambda16_shell","source_file_path":"codes/classical/spherical/lattice_shell/lambda16_shell.yml","source_file_modification_token":1672500309959.5376}},"lattice_shell":{"code_id":"lattice_shell","physical":"spheres","logical":"reals","name":"Lattice-shell code","introduced":"\\cite{doi:10.1109/TIT.1981.1056351}","description":"Spherical code whose codewords are scaled versions of points on a lattice.\nA \\(m\\)-shell code consists of normalized lattice vectors \\(x\\) with squared norm \\(\\|x\\|^2 = m\\).\nEach code is constructed by normalizing a set of lattice vectors in one or more \\textit{shells}, i.e., sets of lattice points lying on a hypersphere.\n","notes":["See \\cite[Ch. 10]{preset:EricZin} for tables of lattice-shell codes."],"relations":{"parents":[{"code_id":"spherical"}],"cousins":[{"code_id":"points_into_lattices","detail":"Lattice-shell codes consists of lattice points that have been normalized."},{"code_id":"cyclic","detail":"Lattice-shell codewords are often permutations of a particular set of reference vectors, meaning that a cyclic permutation of a codeword yields another codeword."},{"code_id":"spherical_design","detail":"Nonempty \\(2m\\)-shell codes of extremal even unimodular lattices in \\(n\\) dimensions form spherical \\(t\\)-designs with \\(t=11\\) (\\(t=7\\), \\(t=3\\)) if \\(n \\equiv 0\\) (\\(n \\equiv 8\\), \\(n\\equiv 16\\)) modulo 24 \\cite{manual:{B. B. Venkov. Even unimodular extremal lattices, algebraic geometry and its applications. Trudy Mat. Inst. Steklov., 165:43–48, 1984.},manual:{B. Venkov. Réseaux et designs sphériques. In Réseaux euclidiens, designs sphériques et formes modulaires, volume 37 of Monogr. Enseign. Math., pages 10–86. Enseignement Math., Geneva, 2001.}}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"lattice_shell","source_file_path":"codes/classical/spherical/lattice_shell/lattice_shell.yml","source_file_modification_token":1687727505567.1863}},"leech_shell":{"code_id":"leech_shell","physical":"spheres","logical":"reals","name":"\\(\\Lambda_{24}\\) Leech lattice-shell code","introduced":"\\cite{doi:10.4153/CJM-1967-017-0}","description":"Spherical code whose codewords are points on the \\(\\Lambda_{24}\\) Leech lattice normalized to lie on the unit sphere.\nThe minimal shell of the lattice yields the \\((24,196560,1)\\) code.\n","protection":"Smallest-shell code yields an optimal solution to the kissing problem in 24D \\cite{doi:10.4153/CJM-1981-038-7}.\nThis code saturates the Levenshtein bound \\cite{manual:{V. I. Levenshtein, “On bounds for packings in n-dimensional Euclidean space”, Dokl. Akad. Nauk SSSR, 245:6 (1979), 1299–1303},manual:{V. I. Levenshtein. Bounds for packings of metric spaces and some of their applications. Problemy Kibernet, 40 (1983), 43-110.},doi:10.1016/0097-3165(79)90074-8}\\cite[pg. 337]{doi:10.1007/978-1-4757-6568-7} and is unique up to equivalence \\cite{doi:10.4153/CJM-1981-038-7}.\n","relations":{"parents":[{"code_id":"lattice_shell"}],"cousins":[{"code_id":"leech"},{"code_id":"sharp_config","detail":"Smallest-shell \\((24,196560,1)\\) code is a spherical sharp configuration \\cite{manual:{Andreev, N. N. Location of points on a sphere with minimal energy. (Russian) Tr. Mat. Inst. Steklova 219 (1997), Teor. Priblizh. Garmon. Anal., 27–31; translation in Proc. Steklov Inst. Math. 1997, no. 4(219), 20–24},arxiv:math/0607446}."},{"code_id":"spherical_design","detail":"Smallest-shell \\((24,196560,1)\\) code is a tight and unique spherical 11-design \\cite[Ch. 3]{doi:10.1007/978-1-4757-6568-7}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-17"}]},"_zoodb":{"id":"leech_shell","source_file_path":"codes/classical/spherical/lattice_shell/leech_shell.yml","source_file_modification_token":1684508734541.2732}},"bpsk":{"code_id":"bpsk","physical":"spheres","logical":"reals","name":"Binary PSK (BPSK) code","short_name":"BPSK","introduced":"\\cite{doi:10.1002/j.1538-7305.1948.tb00917.x}","description":"Also called a \\textit{binary antipodal modulation}, \\textit{phase-reversal keying (PRK)}, or \\textit{antipodal signaling}.\nEncodes one bit of information into a constellation of antipodal points \\(\\pm\\alpha\\) for complex \\(\\alpha\\).\nThese points are typically associated with two phases of an electromagnetic signal.\n","features":{"rate":"Achieve capacity of AGWN in the low signal-to-noise regime \\cite{doi:10.1109/ALLERTON.2010.5706965} (see also \\cite{doi:10.1002/j.1538-7305.1948.tb00917.x}). BPSK concatenated with quantum-classical polar codes achieves the Holevo capacity for the pure-loss channel \\cite{arxiv:1202.0533}."},"realizations":["Telephone-line modems throughout 1950s and 1960s: Bell 103 and 202, as well as international standards V.21 \\cite{manual:{International Telecommunication Union-T, Recommendation V.21: 300 bits per second duplex modem standardized for use in the general switched telephone network, 1984}} and V.23 \\cite{manual:{International Telecommunication Union-T, Recommendation V.23: 600/1200-baud modem standardized for use in the general switched telephone network, 1988}}."],"relations":{"parents":[{"code_id":"psk","detail":"BPSK is also known as 2-PSK."},{"code_id":"binary_antipodal","detail":"A single-bit binary code yields a spherical \\((n,2,4)\\) spherical code under the antipodal mapping, which is equivalent to the BPSK code for dimension \\(n=2\\)."}],"cousins":[{"code_id":"pam","detail":"BPSK for real \\(\\alpha\\) is the simplest non-trivial PAM encoding."},{"code_id":"binary_linear","detail":"Concatenating binary linear codes with BPSK yields a standard way of digitizing the analog AGWN channel \\cite[Ch. 29]{doi:10.1017/9781316822708}."},{"code_id":"two-legged-cat","detail":"BPSK (two-component cat) codes are used to transmit classical (quantum) information using (superpositions of) antipodal coherent states over classical (quantum) channels."},{"code_id":"polar_for_quantum","detail":"BPSK concatenated with quantum-classical polar codes achieves the Holevo capacity for the pure-loss channel \\cite{arxiv:1202.0533}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"}]},"_zoodb":{"id":"bpsk","source_file_path":"codes/classical/spherical/modulation/bpsk.yml","source_file_modification_token":1678631058727.0874}},"psk":{"code_id":"psk","physical":"spheres","logical":"reals","name":"Phase-shift keying (PSK) code","short_name":"PSK","description":"A \\(q\\)-ary phase-shift keying (\\(q\\)-PSK) encodes one \\(q\\)-ary digit of information into a constellation of \\(q\\) points distributed equidistantly on a circle in \\(\\mathbb{C}\\) or, equivalently, \\(\\mathbb{R}^2\\).\nFor example, such a constellation could be\n\\begin{align}\n  \\{1,e^{i\\frac{2\\pi}{q}},\\cdots,e^{i\\frac{2\\pi}{q}(q-1)}\\}~.\n\\end{align}\nEach point is typically associated with a complex amplitude of an electromagnetic signal, and information is encoded into the phase of that signal.\n\nConcatenating PSK with \\(q\\)-ary codes yields a natural non-binary way of digitizing the analog AGWN channel \\cite{manual:{Massey, J. L. \"Convolutional codes over rings.\" Fourth Joint Swedish-Soviet International Workshop on Information Theory. 1989.},manual:{Massey, J. L. \"Ring convolutional codes for phase modulation.\" presented at the IEEE Int. Symp. on Information Theory, San Diego, CA, Jan. 14-19. 1990.}}.\n","features":{"rate":"Nearly achieves Shannon AWGN capacity for one-dimensional constellations in the limit of infinite signal to noise \\cite[Fig. 11.7]{doi:10.1017/CBO9780511811401}."},"realizations":["Telephone-line modems: 1967 Milgo 4400/48 and international standard V.27 used 8-PSK \\cite{manual:{International Telecommunication Union-T, Recommendation V.27ter: 4800/2400 Bits Per Second Modem Standardized For Use in the General Switched Telephone Network, 1984}}."],"relations":{"parents":[{"code_id":"polygon","detail":"The PSK constellation forms a \\(q\\)-gon."},{"code_id":"polyphase","detail":"A polyphase code can be thought of as a concatenation of a \\(q\\)-ary outer code with a PSK inner code. When the outer code is trivial, the construction reduces to a PSK code."},{"code_id":"modulation","detail":"PSK is a modulation whose constellation consists of points arranged equidistantly on a circle."}],"cousins":[{"code_id":"gray","detail":"1D Gray codes are often concatenated with PSKs so that the Hamming distance between the bitstrings encoded into the points is a discretized version of the Euclidean distance between the points."},{"code_id":"cat","detail":"PSK (cat) codes are used to transmit classical (quantum) information using (superpositions of) single-mode coherent states distributed on a circle over classical (quantum) channels."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"}]},"_zoodb":{"id":"psk","source_file_path":"codes/classical/spherical/modulation/psk.yml","source_file_modification_token":1678631058727.1438}},"qpsk":{"code_id":"qpsk","physical":"spheres","logical":"reals","name":"Quadrature PSK (QPSK) code","short_name":"QPSK","introduced":"\\cite{doi:10.1109/TCE.1962.6373228}","description":"Also known as \\textit{quadriphase PSK}, \\textit{4-PSK}, or \\textit{4-QAM}.\nQuaternary encoding into a constellation of four points distributed equidistantly on a circle.\nFor the case of \\(\\pi/4\\)-QPSK, the constellation is \\(\\{e^{\\pm i\\frac{\\pi}{4}},e^{\\pm i\\frac{3\\pi}{4}}\\}\\).\n","realizations":["Japanese and North American digital cellular and personal systems \\cite{doi:10.1109/25.289416}.","Telephone-line modems: 1962 Bell 201 and international standard V.24 \\cite{manual:{International Telecommunication Union-T, Recommendation V.24: List of definitions for interchange circuits between data terminal equipment (DTE) and data circuit-terminating equipment (DCE), 1988}}."],"relations":{"parents":[{"code_id":"psk","detail":"QPSK is also known as 4-PSK."},{"code_id":"biorthogonal","detail":"QPSK code is equivalent to the biorthogonal spherical code for \\(n=2\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-07"}]},"_zoodb":{"id":"qpsk","source_file_path":"codes/classical/spherical/modulation/qpsk.yml","source_file_modification_token":1678631058727.196}},"annealing_spherical":{"code_id":"annealing_spherical","physical":"spheres","logical":"reals","name":"Annealing-based spherical code","introduced":"\\cite{doi:10.1139/v77-246,doi:10.1109/TIT.1987.1057277,doi:10.1107/S0108767390011370}","description":"Code whose codewords are obtained from a simulated annealing or energy-repulsion numerical optimization procedure.\n","relations":{"parents":[{"code_id":"spherical"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"annealing_spherical","source_file_path":"codes/classical/spherical/numerical/annealing_spherical.yml","source_file_modification_token":1671665864789.117}},"laminated_spherical":{"code_id":"laminated_spherical","physical":"spheres","logical":"reals","name":"Laminated spherical code","introduced":"\\cite{doi:10.1109/18.641545}","description":"Spherical code whose codewords are obtained from a recursive procedure that is similar to the procedure that creates laminated lattices.\n","relations":{"parents":[{"code_id":"spherical"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"laminated_spherical","source_file_path":"codes/classical/spherical/numerical/laminated_spherical.yml","source_file_modification_token":1671665864789.1782}},"tlsc":{"code_id":"tlsc","physical":"spheres","logical":"reals","name":"Torus-layer spherical code (TLSC)","short_name":"TLSC","introduced":"\\cite{doi:10.1109/ISIT.2009.5205529}","description":"Code whose codewords are elements of a foliation of the \\(2n-1\\)-dimensional hypersphere \\(S^{2n-1}\\) using flat tori \\(S^1\\times S^1\\cdots\\times S^1\\).\nRelated constructions include the spherical codes by Hopf foliations (SCHF) \\cite{doi:10.1109/ISIT.2019.8849464}.\n","notes":["See \\cite[Sec. 5.2]{doi:10.1007/978-3-319-67882-5} for an exposition."],"features":{"decoders":["Efficiently decodable \\cite{doi:10.1109/ISIT.2009.5205529}."]},"relations":{"parents":[{"code_id":"slepian_group","detail":"Polyphase codewords can be implemented by acting on the all-ones initial vector by diagonal orthogonal matrices whose entries are the codeword components \\cite[Ch. 8]{preset:EricZin}. TLSC codes are generalizations of polyphase codes to other initial vectors and are examples of abelian Slepian-group codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"tlsc","source_file_path":"codes/classical/spherical/numerical/tlsc.yml","source_file_modification_token":1683723710992.0588}},"wrapped_spherical":{"code_id":"wrapped_spherical","physical":"spheres","logical":"reals","name":"Wrapped spherical code","introduced":"\\cite{doi:10.1109/18.641544}","description":"Spherical code in dimension \\(n\\) whose codewords are obtained from centers of spheres from a finite \\(S^{n-1}\\)-sphere packing of \\(\\mathbb{R}^{n}\\) that is \"wrapped\" onto \\(S^n\\).\n","features":{"rate":"Asymptotically maximal spherical coding density is obtained with the densest possible sphere packing."},"relations":{"parents":[{"code_id":"spherical"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"wrapped_spherical","source_file_path":"codes/classical/spherical/numerical/wrapped_spherical.yml","source_file_modification_token":1671665864789.323}},"points_into_spheres":{"code_id":"points_into_spheres","physical":"spheres","logical":"reals","name":"Constant-energy code","description":"Code whose codewords are points on a real or complex sphere whose radius squared is called the \\textit{energy}.\nTypically, only angular distances between points are relevant for code performance, so one can normalize codewords of a constant-energy code to obtain up a spherical code, i.e., a constant energy code with energy one.\n","protection":"Constant-energy codes are sphere packings constrained to lie on a sphere, meaning that they can be used to transmit information through the AGWN channel.\nFor a given dimension \\(n\\), number of codewords \\(M\\), and average energy \\(P\\), the \\textit{constant-energy Gaussian channel coding problem} asks to find a set of \\(M\\) codewords of energy \\(nP\\) that minimizes the error probability during transmission; see \\cite[Ch. 3]{doi:10.1007/978-1-4757-6568-7}.\n","notes":["See \\cite[Ch. 7]{preset:EricZin} for more details."],"relations":{"parents":[{"code_id":"points_into_balls","detail":"Constant-energy codes are bounded-energy codes constrained to lie on a sphere."}],"cousins":[{"code_id":"constant_excitation"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-15"}]},"_zoodb":{"id":"points_into_spheres","source_file_path":"codes/classical/spherical/points_into_spheres.yml","source_file_modification_token":1684508734541.4353}},"120cell":{"code_id":"120cell","physical":"spheres","logical":"reals","name":"120-cell code","description":"Spherical \\((4,600,(7-3\\sqrt{5})/4)\\) code whose codewords are the vertices of the 120-cell.\nSee \\cite[Table 1]{arxiv:1309.7530}\\cite{preset:coxeter}\\cite[Table 3]{doi:10.3390/sym2031423} for realizations of the 600 codewords.\n","realizations":["Improved proofs of the Bell-Kochen-Specker (BKS) theorem \\cite{arxiv:1309.7530}."],"relations":{"parents":[{"code_id":"polytope"},{"code_id":"spherical_design","detail":"The code forms a spherical 11-design because its vertices can be divided into five 600-cells, each of which forms said design."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"120cell","source_file_path":"codes/classical/spherical/polytope/120cell.yml","source_file_modification_token":1683978912606.8403}},"24cell":{"code_id":"24cell","physical":"spheres","logical":"reals","name":"24-cell code","description":"Spherical \\((4,24,1)\\) code whose codewords are the vertices of the 24-cell.\nCodewords form the minimal lattice-shell code of the \\(D_4\\) lattice.\nA realization of the codewords consists of the 24 permutations of the four vectors \\((0,0,\\pm 1,\\pm 1)\\); see \\cite[Table 3]{doi:10.3390/sym2031423} for another realization.\nA realization in terms of quaternions yields the 24 elements of the binary tetrahedral group \\(2T\\) \\cite{arxiv:2205.04965}.\n\\begin{figure}\n  \\includegraphics{24cell.svg}\n  \\caption{Projection of the coordinates of the 24-cell.}\n  \\label{figure:24cell}\n\\end{figure}\n","protection":"Code yields an optimal solution to the kissing problem in 4D \\cite{manual:{Schläfli, L. (1901). Theorie der vielfachen Kontinuität (Vol. 38). Zürcher & Furrer.},arxiv:math/0309430}.\n","notes":["See \\href{https://www.gregegan.net/SCIENCE/24-cell/24-cell.html}{post} by G. Egan for more details."],"relations":{"parents":[{"code_id":"600cell","detail":"Vertices of a 600-cell can be split up into vertices of five 24-cells \\cite{manual:{Schoute, P. H. (1903). Mehrdimensionale Geometrie, Vol. 2 (Die Polytope).},preset:coxeter,arxiv:0911.2289}."},{"code_id":"disphenoidal288cell","detail":"Vertices of a disphenoidal 288-cell can be split up into vertices of a 24-cell and its dual 24-cell \\cite[Sec. 8.6]{arxiv:2205.04965}."},{"code_id":"sidelnikov","detail":"The 24-cell code is equivalent to the real Clifford subgroup-orbit code for \\(n=4\\)."},{"code_id":"spherical_design","detail":"The 24-cell code is a spherical 5-design \\cite{arxiv:math/0607447}."}],"cousins":[{"code_id":"univ_opt_spherical","detail":"The 24-cell code is not universally optimal \\cite{arxiv:math/0607447}, but comes quite close \\cite[Ex. 12.4.29]{preset:HKSbounds}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-23"}]},"_zoodb":{"id":"24cell","source_file_path":"codes/classical/spherical/polytope/24cell/24cell.yml","source_file_modification_token":1683978912606.9553}},"600cell":{"code_id":"600cell","physical":"spheres","logical":"reals","name":"600-cell code","description":"Spherical \\((4,120,(3-\\sqrt{5})/2)\\) code whose codewords are the vertices of the 600-cell.\nSee \\cite[Table 1]{arxiv:0911.2289}\\cite[Table 3]{doi:10.3390/sym2031423} for realizations of the 120 codewords.\nA realization in terms of quaternions yields the 120 elements of the binary icosahedral group \\(2I\\) \\cite{arxiv:2205.04965}.\n\\begin{figure}\n  \\includegraphics{600cell.svg}\n  \\caption{Projection of the coordinates of the \\(600\\)-cell.}\n  \\label{figure:600cell}\n\\end{figure}\n","protection":"The 600-cell code is unique up to equivalence, which follows from saturating the Boroczky bound \\cite{manual:{K. Boroczky, Packing of spheres in spaces of constant curvature, Acta Math. Acad. Sci. Hung. 32 (1978), 243–261.},doi:10.1007/PL00000504}.\n","realizations":["Improved proofs of the Bell-Kochen-Specker (BKS) theorem \\cite{arxiv:0911.2289}."],"notes":["See \\href{https://johncarlosbaez.wordpress.com/2017/12/16/the-600-cell/}{post} by J. Baez for more details."],"relations":{"parents":[{"code_id":"120cell","detail":"Vertices of a 120-cell can be split up into vertices of five 600-cells \\cite{preset:coxeter,arxiv:1309.7530}."},{"code_id":"univ_opt_spherical","detail":"The 600-cell is universally optimal, but it is not a spherical sharp configuration \\cite{arxiv:math/0607446}."},{"code_id":"spherical_design","detail":"The 600-cell code forms a spherical 11-design that is unique up to equivalence \\cite{doi:10.1007/PL00000504}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"600cell","source_file_path":"codes/classical/spherical/polytope/600cell/600cell.yml","source_file_modification_token":1683978912607.0652}},"cubeoctahedron":{"code_id":"cubeoctahedron","physical":"spheres","logical":"reals","name":"Cubeoctahedron code","description":"Spherical \\((3,12,1)\\) code whose codewords are the vertices of the cubeoctahedron.\nCodewords form the minimal lattice-shell code of the \\(D_3\\) face-centered cubic (fcc) lattice.\n","protection":"Code yields an optimal solution to the kissing problem in 3D \\cite{doi:10.1007/BF01343127}.\n","relations":{"parents":[{"code_id":"polytope"},{"code_id":"lattice_shell","detail":"Cubeoctahedron codewords form the minimal shell of the \\(D_3\\) face-centered cubic (fcc) lattice."}],"cousins":[{"code_id":"dthree","detail":"Cubeoctahedron codewords form the minimal shell of the \\(D_3\\) face-centered cubic (fcc) lattice."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"cubeoctahedron","source_file_path":"codes/classical/spherical/polytope/cubeoctahedron.yml","source_file_modification_token":1684508734541.5696}},"disphenoidal288cell":{"code_id":"disphenoidal288cell","physical":"spheres","logical":"reals","name":"Disphenoidal 288-cell code","description":"Spherical \\((4,48,2-\\sqrt{2})\\) code \\cite[Ex. 1.2.6]{preset:EricZin} whose codewords are the vertices of the disphenoidal 288-cell.\nCodewords are the union of two 24-point lattice shells of the \\(D_4\\) lattice.\nThe first shell consists of the 24 permutations of the four vectors \\((0,0,\\pm 1,\\pm 1)\\), and the second of the 16 vectors \\((\\pm 1,\\pm 1,\\pm 1,\\pm 1)\\) and the 8 permutations of the vectors \\((0,0,0,\\pm 2)\\).\nA realization in terms of quaternions yields the 48 elements of the binary octahedral group \\(2O\\) \\cite[Sec. 8.6]{arxiv:2205.04965}.\n","relations":{"parents":[{"code_id":"dfour_shell","detail":"Disphenoidal 288-cell codewords are the union of two 24-point shells of the \\(D_4\\) lattice, with each shell making up the vertices of a 24-cell."},{"code_id":"spherical_design","detail":"The disphenoidal 288-cell code forms a spherical 7-design \\cite{doi:10.1109/ITW.2003.1216742}."}],"cousins":[{"code_id":"sidelnikov","detail":"The disphenoidal 288-cell code is a group-orbit code with the group being the real Clifford group in \\(4\\) dimensions."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-19"}]},"_zoodb":{"id":"disphenoidal288cell","source_file_path":"codes/classical/spherical/polytope/disphenoidal288cell.yml","source_file_modification_token":1683978912607.164}},"hessian_polyhedron":{"code_id":"hessian_polyhedron","physical":"spheres","logical":"reals","name":"Hessian polyhedron code","introduced":"\\cite{manual:{Gosset, Thorold. \"On the regular and semi-regular figures in space of n dimensions.\" Messenger of Mathematics 29 (1900): 43-48.},manual:{Schoute, P. H. \"On the relation between the vertices of a definite six-dimensional polytope and the lines of a cubic surface.\" Proc. Roy. Acad. Amsterdam. Vol. 13. 1910.}}","description":"Also known as the \\textit{Schlafli configuration}. Spherical \\((6,27,3/2)\\) code whose codewords are the vertices of the Hessian complex polyhedron and the \\(2_{21}\\) real polytope.\nTwo copies of the code yield the \\((6,54,1)\\) \\textit{double Hessian polyhedron} code.\n\nThe code can be obtained from the Schlafli graph \\cite[Ch. 9]{preset:EricZin}. The points correspond to the 27 lines on a smooth cubic surface in the complex projective plane \\cite{arxiv:math/0607446}.\nSee \\cite[Exam. 1.2.5]{preset:EricZin} (\\cite[pg. 119]{preset:coxeterComplex}) for a real (complex) realization of the 27 codewords.\n\\begin{figure}\n  \\includegraphics{hessian_polyhedron.svg}\n  \\caption{Projection of the coordinates of the Hessian polytope.}\n  \\label{figure:hessian}\n\\end{figure}\n","protection":"The Hessian polytope code has degree \\(d=2\\) and saturates the absolute bound \\cite{preset:EricZin}.","realizations":["Quantum mechanical SIC-POVMs \\cite{arxiv:1911.05809}."],"relations":{"parents":[{"code_id":"polytope"},{"code_id":"cgs_spherical","detail":"The CGS isotropic subspace code for \\(q=2\\) reduces to the Hessian polytope."},{"code_id":"spherical_design","detail":"The Hessian polytope code forms a tight spherical 4-design \\cite[Exam. 7.3]{arxiv:1104.4692}."}],"cousins":[{"code_id":"esix","detail":"The 27 Hessian polyhedron codewords are intimately related to the \\(E_6\\) Lie group \\cite{arxiv:math/0507118}."},{"code_id":"lattice_shell","detail":"Double Hessian polyhedron codewords form the minimal lattice-shell code of the \\(E_6^{\\perp}\\) lattice."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"hessian_polyhedron","source_file_path":"codes/classical/spherical/polytope/hessian/hessian_polyhedron/hessian_polyhedron.yml","source_file_modification_token":1684508734543.699}},"rect_hessian_polyhedron":{"code_id":"rect_hessian_polyhedron","physical":"spheres","logical":"reals","name":"Rectified Hessian polyhedron code","description":"Spherical \\((6,72,1)\\) code whose codewords are the vertices of the rectified Hessian complex polyhedron and the \\(1_{22}\\) real polytope.\nCodewords form the minimal lattice-shell code of the \\(E_6\\) lattice.\nSee \\cite[pg. 127]{preset:coxeterComplex}\\cite[pg. 126]{doi:10.1007/978-1-4757-6568-7} for realizations of the 72 codewords.\n","relations":{"parents":[{"code_id":"polytope"},{"code_id":"esix_shell","detail":"Rectified Hessian polyhedron codewords form the minimal shell of the \\(E_6\\) lattice."},{"code_id":"spherical_design","detail":"The rectified Hessian polyhedron code forms a spherical 5-design \\cite{doi:10.1016/S0195-6698(03)00101-X}."}],"cousins":[{"code_id":"hessian_polyhedron","detail":"The (rectified) Hessian polyhedron is an analogue of a (octahedron) tetrahedron in 3D complex space, while the double Hessian polyhedron is the analogue of a cube \\cite[pg. 127]{preset:coxeterComplex}. The rectified and double Hessian polyhedra are dual to each other, just like the octahedron and cube. Moreover, the double Hessian consists of two Hessians, just like the cube can be constructed with two tetrahedra."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-29"}]},"_zoodb":{"id":"rect_hessian_polyhedron","source_file_path":"codes/classical/spherical/polytope/hessian/rect_hessian_polyhedron.yml","source_file_modification_token":1684508734543.7986}},"icosahedron":{"code_id":"icosahedron","physical":"spheres","logical":"reals","name":"Icosahedron code","description":"Spherical \\((3,12,2-2/\\sqrt{5})\\) code whose codewords are the vertices of the icosahedron (alternatively, the centers of the faces of a dodecahedron, the icosahedron's dual polytope).\n","protection":"Optimal configuration of 12 points in 3D space \\cite[pg. 76]{preset:EricZin}. Saturates the absolute bound for antipodal codes \\cite[pg. 314]{preset:EricZin}.","notes":["See \\href{https://blogs.ams.org/visualinsight/2015/05/15/dodecahedron-with-5-tetrahedra}{post} by J. Baez for more details."],"relations":{"parents":[{"code_id":"polytope"},{"code_id":"sharp_config","detail":"The icosahedron is a sharp configuration \\cite{manual:{Andreev, Nikolay N. \"An extremal property of the icosahedron.\" East J. Approx 2.4 (1996): 459-462.},arxiv:math/0607446}."},{"code_id":"spherical_design","detail":"The icosahedron code forms a unique tight spherical 5-design \\cite{doi:10.1007/BF03187604}\\cite[Ex. 9.6.1]{preset:EricZin}."}],"cousins":[{"code_id":"golay","detail":"The parity bits of the extended Golay code can be visualized to lie on the vertices of the icosahedron; see \\href{https://blogs.ams.org/visualinsight/2015/12/01/golay-code/}{post} by J. Baez for more details."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"icosahedron","source_file_path":"codes/classical/spherical/polytope/icosahedron.yml","source_file_modification_token":1683978912607.3801}},"biorthogonal":{"code_id":"biorthogonal","physical":"spheres","logical":"reals","name":"Biorthogonal spherical code","description":"Spherical \\((n,2n,2)\\) code whose codewords are all permutations of the \\(n\\)-dimensional vectors \\((0,0,\\cdots,0,\\pm1)\\), up to normalization.\n\nFor \\(n=3\\), biorthogonal spherical codewords make up the vertices of an octahedron.\nFor \\(n=4\\), codewords make up the vertices of a 16-cell, or, equivalently, the Möbius-Kantor complex polygon.\nA quaternion realization of the vertices yields the quaternion group \\(Q\\).\nIn general, the code makes up the vertices of an \\(n\\)-orthoplex.\n\nThe set of permutations of \\((0,0,\\cdots,0,1)\\) forms an orthogonal set and yields the biorthogonal code when combined with the set of permutations of \\((0,0,\\cdots,0,-1)\\).\n","protection":"Biorthogonal spherical codes saturate the absolute bound for antipodal codes and the third Rankin bound \\cite{preset:EricZin}.\nBiorthogonal codes are unique up to equivalence \\cite[pg. 19]{preset:EricZin}, which follows from saturating the Boroczky bound \\cite{manual:{K. Boroczky, Packing of spheres in spaces of constant curvature, Acta Math. Acad. Sci. Hung. 32 (1978), 243–261.}}.\n","relations":{"parents":[{"code_id":"polytope","detail":"Biorthogonal spherical codewords in 2 (3, 4, \\(n\\)) dimensions form the vertices of a square (octahedron, 16-cell, \\(n\\)-orthoplex)."},{"code_id":"sharp_config"},{"code_id":"spherical_design","detail":"Biorthogonal spherical codes are the only tight spherical 3-designs \\cite[Tab. 9.3]{preset:EricZin}."},{"code_id":"lattice_shell","detail":"Biorthogonal codewords form the minimal shell of the \\(\\mathbb{Z}^n\\) hypercubic lattice."},{"code_id":"permutation_spherical"}],"cousins":[{"code_id":"binary_antipodal","detail":"An RM\\((1,m)\\) code maps to a \\((2^m,2^{m+1})\\) biorthogonal signal set under the antipodal mapping \\cite{doi:10.1109/18.720542}\\cite[Sec. 6.4]{manual:{Forney, G. D. (2003). 6.451 Principles of Digital Communication II, Spring 2003.}}. This set is equivalent to the  biorthogonal code since all such codes are unique up to equivalence \\cite[pg. 19]{preset:EricZin}."},{"code_id":"24cell","detail":"Vertices of a 24-cell can be split up into vertices of three 16-cells, which are biorthogonal spherical codes for \\(n=4\\) \\cite{preset:coxeter}."},{"code_id":"hypercubic","detail":"Biorthogonal codewords form the minimal shell of the \\(\\mathbb{Z}^n\\) hypercubic lattice."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-15"}]},"_zoodb":{"id":"biorthogonal","source_file_path":"codes/classical/spherical/polytope/infinite/biorthogonal.yml","source_file_modification_token":1689550329215.8386}},"simplex_spherical":{"code_id":"simplex_spherical","physical":"spheres","logical":"reals","name":"Simplex spherical code","description":"Spherical \\((n,n+1,2+2/n)\\) code whose codewords are all permutations of the \\(n+1\\)-dimensional vector \\((1,1,\\cdots,1,-n)\\), up to normalization, forming an \\(n\\)-simplex.\nCodewords are all equidistant and their components add up to zero.\nFor example, the spherical simplex code in \\(n=3\\) makes up the vertices of a tetrahedron.\nIn general, the code makes up the vertices of an \\(n\\)-simplex.\nSee \\cite[Sec. 7.7]{preset:EricZin} for a parameterization.\n","protection":"Simplex spherical codes saturate the absolute bound, the Levenshtein bound and, for \\(2 < \\rho \\leq 4\\), the first two Rankin bounds \\cite{preset:EricZin}.\nAll simplex codes are unique up to equivalence \\cite[pg. 18]{preset:EricZin}, which follows from saturating the Boroczky bound \\cite{manual:{K. Boroczky, Packing of spheres in spaces of constant curvature, Acta Math. Acad. Sci. Hung. 32 (1978), 243–261.}}.\n","relations":{"parents":[{"code_id":"polytope","detail":"Simplex spherical codewords in 2 (3, 4, \\(n\\)) dimensions form the vertices of a triangle (tetrahedron, 5-cell, \\(n\\)-simplex)."},{"code_id":"sharp_config"},{"code_id":"spherical_design","detail":"Simplex spherical codes are the only tight spherical 2-designs \\cite[Tab. 9.3]{preset:EricZin}."},{"code_id":"permutation_spherical"}],"cousins":[{"code_id":"binary_antipodal","detail":"A binary simplex code (also known as a shortened Hadamard code) to a \\((2^m,2^m+1)\\) simplex signal set under the antipodal mapping \\cite[Sec. 6.5.2]{manual:{Forney, G. D. (2003). 6.451 Principles of Digital Communication II, Spring 2003.}}. This set is equivalent to the simplex code since all such codes are unique up to equivalence \\cite[pg. 18]{preset:EricZin}. Simplex (simplex spherical) codes form simplices in Hamming (Euclidean) space."},{"code_id":"icosahedron","detail":"Vertices of a dodecahedron can be split up into vertices of five tetrahedra, which are simplex spherical codes for \\(n=3\\) \\cite{preset:coxeter}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-15"}]},"_zoodb":{"id":"simplex_spherical","source_file_path":"codes/classical/spherical/polytope/infinite/simplex_spherical.yml","source_file_modification_token":1684508734550.358}},"polygon":{"code_id":"polygon","physical":"spheres","logical":"reals","name":"Polygon code","description":"Spherical \\((1,q,4\\sin^2 \\frac{\\pi}{q})\\) code for any \\(q\\geq1\\) whose codewords are the vertices of a \\(q\\)-gon. Special cases include the line segment (\\(q=2\\)), triangle (\\(q=3\\)), square (\\(q=4\\)), pentagon (\\(q=5\\)), and hexagon (\\(q=6\\)).\nThe code forms a tight spherical \\(q-1\\) design.\n\\begin{figure}\n  \\includegraphics{polygon.svg}\n  \\caption{\\(q\\)-gon code for \\(q=5\\). Each codeword is a vertex of the \\(5\\)-gon.}\n  \\label{figure:polygon}\n\\end{figure}\n","relations":{"parents":[{"code_id":"polytope"},{"code_id":"sharp_config"}],"cousins":[{"code_id":"cat","detail":"The \\(q(S+1)\\)-component cat coherent-state constellation forms the vertices of a \\(q(S+1)\\)-gon."},{"code_id":"quantum_psk","detail":"The PSK coherent-state constellation forms the vertices of a \\(q\\)-gon."}]},"_meta":{"changelog":[{"user_id":"ShubhamPJain","date":"2023-02-27"},{"user_id":"VictorVAlbert","date":"2023-02-24"}]},"_zoodb":{"id":"polygon","source_file_path":"codes/classical/spherical/polytope/polygon/polygon.yml","source_file_modification_token":1678631058730.9473}},"polytope":{"code_id":"polytope","physical":"spheres","logical":"reals","name":"Polytope code","description":"Spherical code whose codewords are the vertices of a polytope, i.e., a geometrical figure bounded by lines, planes, and hyperplanes \\cite{preset:coxeter}.\nPolytopes in two (three) real or complex dimensions are called polygons (polyhedra).\n","relations":{"parents":[{"code_id":"slepian_group","detail":"Vertices of polytope codes typically form an orbit of the polytope's symmetry group."}]},"notes":["See \\href{https://polytope.miraheze.org/wiki/Main_Page}{Polytope Wiki} and \\href{https://bendwavy.org/klitzing/home.htm}{webpage by R. Klitzing} for lists of polytopes."],"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"polytope","source_file_path":"codes/classical/spherical/polytope/polytope.yml","source_file_modification_token":1678631058731.024}},"snub_cube":{"code_id":"snub_cube","physical":"spheres","logical":"reals","name":"Snub-cube code","description":"Spherical \\((3,24,0.55384)\\) code whose codewords are the vertices of the snub cube.\n","protection":"Optimal configuration of 24 points in 3D space \\cite[pg. 78]{preset:EricZin}.","relations":{"parents":[{"code_id":"polytope"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"snub_cube","source_file_path":"codes/classical/spherical/polytope/snub_cube.yml","source_file_modification_token":1671665864790.1577}},"square_antiprism":{"code_id":"square_antiprism","physical":"spheres","logical":"reals","name":"Square-antiprism code","description":"Spherical \\((3,8,4(4-\\sqrt{2})/7)\\) code whose codewords are the vertices of the square antiprism.\n","protection":"Optimal configuration of nine points in 3D space \\cite[pg. 73]{preset:EricZin}.","relations":{"parents":[{"code_id":"polytope"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"square_antiprism","source_file_path":"codes/classical/spherical/polytope/square_antiprism.yml","source_file_modification_token":1671665864790.2195}},"witting_polytope":{"code_id":"witting_polytope","physical":"spheres","logical":"reals","name":"Witting polytope code","description":"Spherical \\((8,240,1)\\) code whose codewords are the vertices of the Witting complex polytope and the \\(4_{21}\\) real polytope.\nThis code is optimal and unique up to equivalence \\cite{doi:10.4153/CJM-1981-038-7,doi:10.1007/978-1-4757-6568-7}.\nCodewords form the minimal lattice-shell code of the \\(E_8\\) lattice.\n\nA representation of the codewords consists of all 112 permutations of the four vectors \\((0,0,0,0,0,0,\\pm 2,\\pm 2)\\) along with the 128 vectors \\((\\pm 1)^{\\times 8}\\) where the number of minus signs is even.\nSee \\cite[pg. 132]{preset:coxeterComplex} for a complex representation.\n","protection":"Code yields an optimal solution to the kissing problem in 4D \\cite{manual:{Schläfli, L. (1901). Theorie der vielfachen Kontinuität (Vol. 38). Zürcher & Furrer.},arxiv:math/0309430} and saturates the Levenshtein bound \\cite{doi:10.1016/0097-3165(79)90074-8}.\n","relations":{"parents":[{"code_id":"polytope"},{"code_id":"eeight_shell","detail":"Witting polytope codewords form the minimal shell of the \\(E_8\\) lattice."},{"code_id":"sharp_config","detail":"The Witting polytope code is a sharp configuration \\cite{doi:10.1515/dma.1994.4.2.143,arxiv:math/0607446}."},{"code_id":"spherical_design","detail":"The Witting polytope code forms a tight spherical 7-design \\cite[Ch. 14]{doi:10.1007/978-1-4757-6568-7}."},{"code_id":"sidelnikov","detail":"The Witting polytope code is equivalent to the real Clifford subgroup-orbit code for \\(n=8\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-28"}]},"_zoodb":{"id":"witting_polytope","source_file_path":"codes/classical/spherical/polytope/witting_polytope.yml","source_file_modification_token":1683978912607.862}},"binary_antipodal":{"code_id":"binary_antipodal","physical":"spheres","logical":"reals","name":"Binary antipodal code","description":"Also known as a \\textit{binary signal constellation}.\nAn \\((n,K,4d/n)\\) spherical code obtained from a binary \\((n,K,d)\\) code via a component-wise \\textit{antipodal mapping} (also known as a \\textit{Euclidean-space image}) \\(0\\to +1\\) and \\(1 \\to -1\\) \\cite[Example 1.2.1]{preset:EricZin}.\n","relations":{"parents":[{"code_id":"polyphase"}],"cousins":[{"code_id":"bpsk","detail":"A binary antipodal code can be thought of as a concatenation of a binary outer code with a BPSK inner code."},{"code_id":"bits_into_bits","detail":"Binary antipodal codes are spherical codes obtained from binary codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-15"}]},"_zoodb":{"id":"binary_antipodal","source_file_path":"codes/classical/spherical/q-ary/binary_antipodal.yml","source_file_modification_token":1671665864790.3855}},"binary_balanced":{"code_id":"binary_balanced","physical":"spheres","logical":"reals","name":"Binary balanced spherical code","description":"An \\((n-1,K,\\frac{nd}{nw-w^2})\\) spherical code obtained from a constant-weight-\\(w\\) binary \\((n,K,d)\\) code via a component-wise \\textit{binary balanced mapping} (also known as \\textit{the CW\\(_2\\) construction}),\n\\begin{align}\n  \\begin{split}\n    0&\\to\\sqrt{\\frac{w}{n\\left(n-w\\right)}}\\\\1&\\to -\\sqrt{\\frac{n-w}{nw}}~.\n  \\end{split}\n\\end{align}\nThis construction can be extended to the general balanced binary construction CW\\(_q\\) for spherical code alphabets of size \\(q\\) \\cite[Sec. 6.6]{preset:EricZin}.\n","notes":["See \\cite[Sec. 6.2]{preset:EricZin} for more details."],"relations":{"parents":[{"code_id":"spherical"},{"code_id":"concatenated","detail":"A binary balanced spherical code can be thought of as a concatenation of a constant-weight binary outer code with a shifted and scaled BPSK-like inner code."}],"cousins":[{"code_id":"constant_weight","detail":"Binary balanced spherical codes are obtained from constant-weight binary codes."},{"code_id":"bpsk","detail":"A binary balanced spherical code can be thought of as a concatenation of a constant-weight binary outer code with a shifted and scaled BPSK-like inner code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-16"}]},"_zoodb":{"id":"binary_balanced","source_file_path":"codes/classical/spherical/q-ary/binary_balanced.yml","source_file_modification_token":1671665864790.4592}},"polyphase":{"code_id":"polyphase","physical":"spheres","logical":"reals","name":"Polyphase code","introduced":"\\cite{doi:10.1109/TIT.1965.1053807,doi:10.1109/TIT.1966.1053876,manual:{Einarsson, Göran. \"Polyphase coding for a Gaussian channel(Polyphase coding for Gaussian channel, investigating PM signal transmission over channel disturbed by additive white Gaussian noise).\" Ericsson Technics 24.2 (1968): 75-130.},manual:{Einarsson, Göran. Performance of polyphase signals on a Gaussian channel. 1966.},manual:{Ottoson, Ragnar. \"Performance of phase- and amplitude-modulated signals on a Gaussian channel(Phase and amplitude modulated signals transmission over band limited channel disturbed by additive white Gaussian noise).\" Ericsson Technics 25.3 (1969): 153-198.},manual:{Nilsson, Magnus. \"Linear block codes over rings for phase shift keying.\" Thesis no. 331, Linkoping University (1993).},doi:10.1109/TIT.1986.1057230,manual:{V. V. Ginzburg, “Multidimensional Signals for a Continuous Channel”, Probl. Peredachi Inf., 20:1 (1984), 28–46; Problems Inform. Transmission, 20:1 (1984), 20–34},manual:{Portnoi, S. L. \"Characterizations of modulation and encoding systems as concatenated codes.\" Probl. Inform. Transm. 21.3 (1985): 14-27.},manual:{V. V. Zyablov, S. L. Portnoi, “Modulation/Coding System for a Gaussian Channel”, Probl. Peredachi Inf., 23:3 (1987), 18–26; Problems Inform. Transmission, 23:3 (1987), 187–193},manual:{V.A. Zinoviev, S.N. Litsyn and S.L. Portnoi, Cascade codes in Euclidean space, Problems of Information Transmission, Vol. 25, No. 3, pp. 62-75, 1989.}}","description":"A spherical code obtained from a binary code, \\(q\\)-ary code, or \\(q\\)-ary code over \\(\\mathbb{Z}_q\\) via a component-wise mapping of each \\(q\\)-ary digit to a \\(q\\)th root of unity.\n\nFor example, for the case \\(q=4\\), one can map either the ring-based alphabet \\(\\mathbb{Z}_4 = \\{0,1,2,3\\}\\) or the field-based alphabet \\(GF(2)^2 = \\{00,01,10,11\\}\\) to the set \\(\\{1,\\theta,\\theta^2,\\theta^3\\}\\) for some fourth root of unity \\(\\theta\\).\n","notes":["See \\cite[Ch. 7]{preset:EricZin} for more details."],"relations":{"parents":[{"code_id":"tlsc"},{"code_id":"concatenated","detail":"A polyphase code can be thought of as a concatenation of a \\(q\\)-ary outer code with a PSK inner code."}],"cousins":[{"code_id":"q-ary_digits_into_q-ary_digits","detail":"Polyphase codes are spherical codes that can be obtained from \\(q\\)-ary codes."},{"code_id":"q-ary_over_zq","detail":"Polyphase codes are spherical codes that can be obtained from \\(q\\)-ary codes over rings \\(\\mathbb{Z}_q\\)."},{"code_id":"simplex_spherical","detail":"Simplex spherical codes for dimension \\(n=(p-1)/2\\) with \\(p\\) an odd prime admit a polyphase realization \\cite[Sec. 7.7]{preset:EricZin}."},{"code_id":"biorthogonal","detail":"Biorthogonal spherical codes for dimension \\(n=p\\) with \\(p\\) an odd prime admit a polyphase realization \\cite[Sec. 7.7]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-18"}]},"_zoodb":{"id":"polyphase","source_file_path":"codes/classical/spherical/q-ary/polyphase.yml","source_file_modification_token":1671665864790.537}},"cgs_spherical":{"code_id":"cgs_spherical","physical":"spheres","logical":"reals","name":"Cameron-Goethals-Seidel (CGS) isotropic subspace code","short_name":"CGS isotropic subspace","introduced":"\\cite{doi:10.1016/0021-8693(78)90220-X}","description":"Member of a \\((q(q^2-q+1),(q+1)(q^3+1),2-2/q^2)\\) family of spherical codes for any prime-power \\(q\\).\nConstructed from generalized quadrangles, which in this case correspond to sets of totally isotropic points and lines in the projective space \\(PG_{5}(q)\\) \\cite[Ex. 9.4.5]{preset:EricZin}.\nThere exist multiple distinct spherical codes using this construction for \\(q>3\\) \\cite{arxiv:math/0607446}.\n","protection":"CGS isotropic subspace codes saturate the Levenshtein bound \\cite[pg. 64]{preset:EricZin}.","relations":{"parents":[{"code_id":"sharp_config","detail":"CGS isotropic subspace codes are the only known spherical sharp configrations not derived from regular polytopes or lattices \\cite{arxiv:math/0607446}."}],"cousins":[{"code_id":"projective","detail":"CSG isotropic subspace codes are constructed from incidence matrices of \\(PG_5(q)\\) \\cite[Ex. 9.4.5]{preset:EricZin}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-23"}]},"_zoodb":{"id":"cgs_spherical","source_file_path":"codes/classical/spherical/sharp_config/cgs_spherical.yml","source_file_modification_token":1678631058731.2944}},"sharp_config":{"code_id":"sharp_config","physical":"spheres","logical":"reals","name":"Spherical sharp configuration","introduced":"\\cite{manual:{V. I. Levenshtein, \"On choosing polynomials to obtain bounds in packing problems.\" Proc. Seventh All-Union Conf. on Coding Theory and Information Transmission, Part II, Moscow, Vilnius. 1978.},manual:{V. I. Levenshtein, “On bounds for packings in n-dimensional Euclidean space”, Dokl. Akad. Nauk SSSR, 245:6 (1979), 1299–1303},doi:10.1007/BF00053379,arxiv:math/0607446}","description":"A spherical code that is a spherical design of strength \\(2m-1\\) for some \\(m\\) and that has \\(m\\) distances between distinct points.\nAll known spherical sharp configrations are either obtained from the Leech or \\(E_8\\) lattice, certain regular polytopes, or are CGS isotropic subspace spherical codes.\n","relations":{"parents":[{"code_id":"univ_opt_spherical","detail":"All sharp configurations are universally optimal \\cite{arxiv:math/0607446}, but not all universally optimal spherical codes are sharp configurations. The one known exception is the 600-cell."},{"code_id":"delsarte_optimal"},{"code_id":"spherical_design","detail":"Spherical sharp configurations are spherical designs of strength \\(2m-1\\) for some \\(m\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-23"}]},"_zoodb":{"id":"sharp_config","source_file_path":"codes/classical/spherical/sharp_config/sharp_config.yml","source_file_modification_token":1683978912607.973}},"smith_spherical":{"code_id":"smith_spherical","physical":"spheres","logical":"reals","name":"Smith \\(40\\)-point code","introduced":"\\cite{manual:{Sloane, N. J. A., R. H. Hardin, and W. D. Smith. \"Tables of spherical codes.\" collaboration with R. H. Hardin, W. D. Smith and others. Published electronically at http://neilsloane.com/packings/ (2004).},arxiv:math/0611451}","description":"A \\((10,40,1/6)\\) spherical code found by W. D. Smith \\cite{manual:{Sloane, N. J. A., R. H. Hardin, and W. D. Smith. \"Tables of spherical codes.\" collaboration with R. H. Hardin, W. D. Smith and others. Published electronically at http://neilsloane.com/packings/ (2004).}} and conjectured to be optimal in terms of minimizing potential energy functions \\cite{arxiv:math/0611451}.\nA beautified set of coordinates can be found on the site \\cite{manual:{Sloane, N. J. A., R. H. Hardin, and W. D. Smith. \"Tables of spherical codes.\" collaboration with R. H. Hardin, W. D. Smith and others. Published electronically at http://neilsloane.com/packings/ (2004).}}.\n","relations":{"parents":[{"code_id":"spherical"}],"cousins":[{"code_id":"sharp_config","detail":"The Smith spherical code is conjectured to be a global minimum of completely monotonic potential functions \\cite{arxiv:math/0611451}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-23"}]},"_zoodb":{"id":"smith_spherical","source_file_path":"codes/classical/spherical/sharp_config/smith_spherical.yml","source_file_modification_token":1678631058731.402}},"univ_opt_spherical":{"code_id":"univ_opt_spherical","physical":"spheres","logical":"reals","name":"Universally optimal spherical code","introduced":"\\cite{manual:{V. A. Yudin, “Minimum potential energy of a point system of charges”, Diskr. Mat., 4:2 (1992), 115–121; Discrete Math. Appl., 3:1 (1993), 75–81},doi:10.1109/18.915662,doi:10.1007/BF02789828,doi:10.1007/BF03024331,arxiv:math/0607446}","description":"A spherical code that (weakly) minimizes all completely monotonic potentials on the sphere for its cardinality. See \\cite[Sec. 12.4]{preset:HKSbounds}\\cite{arxiv:1407.8282} for further discussion.\n","relations":{"parents":[{"code_id":"spherical"},{"code_id":"univ_opt"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-05"},{"user_id":"AlexanderBarg","date":"2023-03-05"},{"user_id":"VictorVAlbert","date":"2023-02-28"}]},"_zoodb":{"id":"univ_opt_spherical","source_file_path":"codes/classical/spherical/sharp_config/univ_opt_spherical.yml","source_file_modification_token":1682250129451.7834}},"spherical":{"code_id":"spherical","physical":"spheres","logical":"reals","name":"Spherical code","description":"Code whose codewords are points on an \\(n\\)-dimensional sphere \\(S^{n}\\) with radius one.\nIt is denoted as \\((n,M,\\rho)\\), where \\(n\\) is the code \\textit{dimension}, \\(M\\) is the size or number of codewords, and \\(\\rho\\) is the \\textit{squared minimum distance}, i.e., the smallest Euclidean distance between pairs of distinct codewords,\n\\begin{align}\n  \\rho=\\min\\left\\{ \\left\\Vert x-y\\right\\Vert ^{2}\\,\\text{s.t.}\\,x,y\\in C,\\,\\,x\\neq y\\right\\}~.\n\\end{align}\n\nA spherical code can be defined using the Gram matrix \\(G = XX^T\\), where the rows of \\(X\\) are the codeword vectors.\nThe Gram matrix is symmetric, positive-definite, and has all diagonal elements equal to one.\nThe code dimension is equal to the rank of \\(G\\), which can be less than the dimension of the codeword vectors.\n\nSpherical codeword components are often taken from a discrete set of real values called an \\textit{alphabet}.\nFor example, codewords of any length-\\(n\\) binary code can be mapped into spherical codewords with alphabet \\(\\{\\pm 1/\\sqrt{n} \\}\\) via the antipodal mapping \\(0\\to +1\\) and \\(1 \\to -1\\) \\cite[Example 1.2.1]{preset:EricZin}.\n","protection":"The Euclidean distance between two points is related to the dot product as\n\\begin{align}\n  \\left\\Vert x-y\\right\\Vert^{2} = 2-2x \\cdot y~,\n\\end{align}\nwhere \\(x\\cdot y\\) is the Euclidean inner product. As a result, the \\textit{angular distance},\n\\begin{align}\n  \\theta=\\arccos(x\\cdot y) \\in[0,\\pi]~,\n\\end{align}\ncan be equivalently used to quantify code performance.\n\nThe size of an \\((n,M,\\rho)\\) spherical code with \\(d\\) distances between distinct points satisfies the \\textit{absolute bound}, \\cite{doi:10.1007/BF03187604}\n\\begin{align}\n  M\\leq{n+d-1 \\choose d}+{n+d-2 \\choose d-1}~.\n\\end{align}\nThe parameter \\(d\\) is sometimes called the \\(degree\\) of the code.\nFor antipodal codes, i.e., codes that are invariant under \\(x\\to-x\\), the bound is\n\\begin{align}\n  M\\leq2{n+d-2 \\choose d-1}~.\n\\end{align}\n\nDenote \\(A_n(\\rho)\\) to be the largest possible size of a spherical code with distance \\(\\rho\\).\nSpherical code parameters \\((n,M,\\rho)\\) as well as \\(A_n(\\rho)\\) satisfy the following three \\textit{Rankin bounds} \\cite{doi:10.2307/1969393,manual:{Davenport, H., & Hajos, G. (1951). Aufgabe 35. Math. Lapok, 58.},doi:10.1017/S2040618500033219}\n\\begin{align}\n  \\begin{split}\n  \\rho & \\leq\\frac{2M}{M-1}\\\\\n  A_{n}\\left(\\rho\\right) & \\leq n+1\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,\\,2<\\rho\\leq4\\\\\n  A_{n}\\left(2\\right) & \\leq2n~.\n  \\end{split}\n\\end{align}\nSee \\cite[Ch. 1.2]{doi:10.1007/978-1-4757-6568-7} for other bounds on \\(A_n(\\rho)\\).\n\nOther bounds on spherical codes include the Fejes Toth bound \\cite{manual:{L. Fejes Toth, Uber die Abschatzung des kiirzesten Abstandes zweier Punkte eines auf einer Kugelflache liegenden Punktsystemes, Jber. Deut. Math. Verein., Vol. 53, pp. 66-68, 1943.}}, the Wyner bound \\cite{doi:10.1002/j.1538-7305.1965.tb04170.x} and the apple-picking bound \\cite{doi:10.1109/TIT.1987.1057277}.\n","notes":["See \\cite{preset:EricZin,manual:{Sloane, N. J. A., R. H. Hardin, and W. D. Smith. \"Tables of spherical codes.\" collaboration with RH Hardin, WD Smith and others. Published electronically at http://neilsloane.com/packings/ (2004).}} for more details and tables of optimal codes.","See article \\cite{doi:10.1007/BF03024331} for relations of spherical codes to other fields."],"relations":{"parents":[{"code_id":"points_into_spheres"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-03"},{"user_id":"VictorVAlbert","date":"2022-02-16"}]},"_zoodb":{"id":"spherical","source_file_path":"codes/classical/spherical/spherical.yml","source_file_modification_token":1678631058731.5422}},"spherical_design":{"code_id":"spherical_design","physical":"spheres","logical":"reals","name":"Spherical design code","introduced":"\\cite{doi:10.1007/BF03187604}","description":"Spherical code whose codewords are uniformly distributed in a way that is useful for determining averages of polynomials over the real sphere.\nA spherical code is a spherical design of \\textit{strength} \\(t\\), i.e., a \\(t\\)-design, if the average of any polynomial of degree up to \\(t\\) over its codewords is equal to the average over the entire sphere.\n\nSpherical designs can also be defined for complex spheres, and there are ways to convert between the two \\cite[Lemma 3.6]{arxiv:1104.4692}.\n","protection":"The number of points \\(|X|\\) of an \\(n\\)-dimensional spherical design \\(X\\) is bounded by \\cite{doi:10.1007/BF03187604}\n\\begin{align}\n  |X|\\geq\\begin{cases}\n  {n+s-1 \\choose n-1}+{n+s-2 \\choose n-1} & t=2s\\\\\n  2{n+s-1 \\choose n-1} & t=2s+1\n  \\end{cases}~,\n\\end{align}\nand designs saturating the above inequality are called \\textit{tight}.\n","notes":["See Refs. \\cite{doi:10.1016/j.ejc.2008.11.007,preset:EricZin}\\cite[pg. 89]{doi:10.1007/978-1-4757-6568-7}\\cite{doi:10.5802/alco.213} for reviews and examples on spherical designs."],"relations":{"parents":[{"code_id":"spherical"}],"cousins":[{"code_id":"combinatorial_design"},{"code_id":"slepian_group","detail":"Slepian group-orbit codes can form spherical designs \\cite{doi:10.2969/jmsj/03620341,doi:10.1016/S0195-6698(03)00101-X}. Polynomial invariants of a discrete subgroup \\(G\\) of the orthogonal group can be used to determine the design strength of orbits of \\(G\\) \\cite{doi:10.1007/978-0-387-34149-1_21}. Let \\(t+1\\) be the degree of the lowest-degree \\(G\\)-invariant polynomial that is not a polynomial in the norm \\(\\left\\Vert x\\right\\Vert^2\\). Then, any orbit under \\(G\\) forms a Slepian group-orbit code that is also a spherical \\(t\\)-design."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-12"}]},"_zoodb":{"id":"spherical_design","source_file_path":"codes/classical/spherical/spherical_design.yml","source_file_modification_token":1687727505567.4607}},"classical_into_quantum":{"code_id":"classical_into_quantum","name":"Classical-quantum (c-q) code","description":"Code designed specifically for transmission of classical information through non-classical channels, e.g., quantum channels, hybrid quantum-classical channels, or channels with classical inputs and quantum outputs. Such codes include maps from a classical alphabet into a quantum Hilbert space.\n","features":{"rate":"The Holevo channel capacity,\n\\begin{align}\n  C=\\lim_{n\\to\\infty}\\frac{1}{n}\\chi\\left({\\cal N}^{\\otimes n}\\right)~,\n\\end{align}\nwhere \\(\\chi\\) is the Holevo information,\nis the highest rate of classical information transmission through a quantum channel with arbitrarily small error rate \\cite{manual:{A. S. Holevo, “Bounds for the Quantity of Information Transmitted by a Quantum Communication Channel”, Probl. Peredachi Inf., 9:3 (1973), 3–11; Problems Inform. Transmission, 9:3 (1973), 177–183},doi:10.1103/PhysRevA.56.131,doi:10.1109/18.651037}.\n\nThis capacity is equal to the \\textit{single-letter} Holevo information of a single copy of the channel, \\(\\chi(\\cal{N})\\), for all known deterministically constructed channels.\nHowever, it is known to be superadditive, i.e., not equal to the single-copy case, for particular random channels \\cite{arxiv:0809.3972}.\n\nCorrections to the Holevo capacity and tradeoff between decoding error, code rate and code length are determined in quantum generalizations of small \\cite{arxiv:1308.6503}, moderate \\cite{arxiv:1701.03114,arxiv:1709.05258}, and large \\cite{arxiv:1409.3562} deviation analysis.\nBounds also exist on the one-shot capacity, i.e., the achievability of classical codes given only one use of the quantum channel \\cite{arxiv:quant-ph/9703013,arxiv:quant-ph/0206186,arxiv:quant-ph/0611013,arxiv:1007.5456,arxiv:1312.3822,arxiv:2208.02132}; see \\cite[Table 2]{arxiv:2208.02132} for a summary.\n"},"relations":{"parents":[{"code_id":"oaecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"classical_into_quantum","source_file_path":"codes/classical_into_quantum/classical_into_quantum.yml","source_file_modification_token":1678631058731.6409}},"concatenated_c-q":{"code_id":"concatenated_c-q","name":"Concatenated c-q code","description":"A c-q code constructed out of two classical or quantum codes for the purposes of transmission of classical information over quantum channels.","relations":{"parents":[{"code_id":"classical_into_quantum"}],"cousins":[{"code_id":"generalized_concatenated"},{"code_id":"quantum_concatenated"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-31"}]},"_zoodb":{"id":"concatenated_c-q","source_file_path":"codes/classical_into_quantum/concatenated_c-q.yml","source_file_modification_token":1687727505567.559}},"bosonic_classical_into_quantum":{"code_id":"bosonic_classical_into_quantum","physical":"oscillators","logical":"reals","name":"Bosonic c-q code","description":"Bosonic code designed for transmission of classical information through non-classical channels.\n","features":{"rate":"The Holevo capacity has been calculated for various bosonic quantum channels \\cite{doi:10.1109/JSTQE.2009.2024959,arxiv:2002.05766,doi:10.1515/9783110642490} such as the lossy bosonic channel \\cite{arxiv:quant-ph/0308012} or quantum AGWN \\cite{arxiv:1312.6225}. The energy-constrained capacity of the noiseless bosonic c-q channel is finite due to quantum effects \\cite{doi:10.1103/PhysRevLett.70.363,doi:10.1103/RevModPhys.66.481}, while the Shannon capacity can be infinite. Gordon was the first to calculate such capacities (in a published work) for a specific case \\cite{manual:{J. P. Gordon, in Advances in Quantum Electronics edited by J. R. Singer (Columbia University, New York, 1961), p. 509},doi:10.1109/JRPROC.1962.288169,manual:{J.P. Gordon, in Quantum Electronics and Coherent Light, Proceedings of the International School of Physics \"Enrico Fermi,\" Course XXXI, edited by PA. Miles (Academic, New York, 1964), p. 156.}}, and a related discussion is given by Forney \\cite{manual:{G.D. Forney, Jr., S.M. thesis, Massachusetts Institute of Technology, 1963 (unpublished).}}."},"relations":{"parents":[{"code_id":"classical_into_quantum"}],"cousins":[{"code_id":"oscillators","detail":"Bosonic c-q codes are bosonic codes designed to transmit classical information."}]},"_meta":{"changelog":[{"user_id":"JasSidhu","date":"2023-03-21"},{"user_id":"VictorVAlbert","date":"2023-03-21"},{"user_id":"VictorVAlbert","date":"2022-12-04"}]},"_zoodb":{"id":"bosonic_classical_into_quantum","source_file_path":"codes/classical_into_quantum/oscillators/bosonic_classical_into_quantum.yml","source_file_modification_token":1687727505567.669}},"coherent_state_c-q":{"code_id":"coherent_state_c-q","physical":"oscillators","logical":"reals","name":"Coherent-state c-q code","description":"Bosonic c-q code whose codewords form a constellation of coherent states.\nEncodes real numbers into coherent states for transmission over a quantum channel and decoding with a quantum-enhanced \\textit{receiver}.\n\nThe codes consists of \\(K\\) coherent states on \\(n\\) modes, where the \\(j\\)th state, or codeword, is uniquely defined through the amplitude vector \\(\\boldsymbol{\\alpha}^j=(\\alpha_1^j, \\alpha_2^j, \\cdots, \\alpha_n^j)\\).\nThe \\textit{codebook},\n\\begin{align}\nC=\\left(\\begin{array}{c}\n\\boldsymbol{\\alpha}^{1}\\\\\n\\vdots\\\\\n\\boldsymbol{\\alpha}^{K}\n\\end{array}\\right)=\\left(\\begin{array}{cccc}\n\\alpha_{1}^{1} & \\alpha_{2}^{1} & \\dots & \\alpha_{n}^{1}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\n\\alpha_{1}^{K} & \\alpha_{2}^{K} & \\dots & \\alpha_{n}^{K}\n\\end{array}\\right)~,\n\\end{align}\ncollects each codeword into the matrix \\(C\\) that characterizes the system of states to discriminate.\n\nFrom the properties of \\(C\\), we can assess whether it is possible to optimally discriminate the codebook unambiguously.\nOptimal unambiguous state discrimination requires each vector to be linearly independent, which corresponds to a full-rank codebook.\nThis is possible only if \\(K \\leq n\\).\n\nOptimal receiver performance in ambiguous state discrimination is determined using the \\textit{Yuen-Kennedy-Lax (YKL) conditions} \\cite{doi:10.1109/TIT.1975.1055351}.\nSee review \\cite{doi:10.1116/5.0036959} for details on receivers used for coherent-state c-q codes.\n","features":{"rate":"Random Gaussian-distributed coherent-state c-q codes achieve the capacity of the lossy bosonic channel \\cite{arxiv:quant-ph/0308012}.","decoders":["Joint-detection receiver that can attain channel capacity \\cite{arxiv:1101.1550}.","Various near-optimal receiver designs that can handle arbitrary constellations of coherent states with possible degeneracies \\cite{arxiv:2109.00008}."]},"realizations":["Continuous-variable quantum key distribution (CV-QKD) \\cite{arxiv:quant-ph/9907073,arxiv:quant-ph/0109084,arxiv:quant-ph/0312016}."],"relations":{"parents":[{"code_id":"bosonic_classical_into_quantum"}],"cousins":[{"code_id":"coherent_constellation","detail":"Coherent-state c-q codes encode classical alphabets into constellations of coherent states, while coherent-state constellation codes encode quantum information into superpositions of coherent states."},{"code_id":"modulation","detail":"Coherent-state c-q codes are modulation schemes to transmission of classical information over quantum analog channels."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-31"}]},"_zoodb":{"id":"coherent_state_c-q","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/coherent_state_c-q.yml","source_file_modification_token":1687727505567.7595}},"niset_andersen_cerf":{"code_id":"niset_andersen_cerf","physical":"oscillators","logical":"reals","name":"Niset-Andersen-Cerf code","introduced":"\\cite{arXiv:0710.4858}","description":"Coherent-state c-q code encoding two-mode coherent states \\(\\{|\\alpha\\rangle, |\\beta\\rangle\\}\\) into four modes such that the complex values \\((\\alpha,\\beta)\\) are recoverable after a single-mode erasure. There are two variations of the storage procedure: a deterministic protocol that offers recovery against a single mode erasure, and a probabalistic that can protect against multiple errors with post selection. This code is effectively protecting classical information stored in \\((\\alpha,\\beta)\\) using quantum operations.","protection":"The deterministic protocol protects against a single erasure error on a known mode. This recovers one state perfectly and the other state with fidelity \\(F = \\frac{1}{1 + e^{-2 r}}\\) for an initial EPR pair squeezed with variance \\(e^{-2r}\\). The probabalistic protocol utilizes post-selection to protect against multiple erasures with state-dependent fidelity.","features":{"encoders":["After an EPR pair preparation, use 2 continuous CNOT and 2 continuous inverse CNOT gates to entangle a bosonic EPR pair with initial states \\(|\\alpha \\rangle\\) and \\(|\\beta \\rangle\\).","Alternate optical encoder using a two-mode squeezed vacuum state and two balanced beam splitters to mix the input coherent states with the EPR pair."],"decoders":["Optical decoder using three beam splitters, electronic gain detectors, and two phase-insensitive amplifiers as described in Ref. \\cite{arXiv:0710.4858}."]},"realizations":["Realized in Ref. \\cite{arxiv:1006.3941} in an optical system with 3 beam-splitters. The fidelity peaked around \\(0.6\\) for deterministic approach, and around \\(0.77\\) for the probabilistic approach (with a 25\\% chance of error)."],"relations":{"parents":[{"code_id":"coherent_state_c-q"}],"cousins":[{"code_id":"qam","detail":"The Niset-Andersen-Cerf code encodes two coherent states at a time with arbitrary complex values, making it analogous to a two-point QAM code. The code does not encode any quantum information since superpositions of the coherent states are not stored. However, analysis of the code is done via a quantum treatment."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"},{"user_id":"VictorVAlbert","date":"2022-07-06"},{"user_id":"VictorVAlbert","date":"2022-01-04"},{"user_id":"SiddharthTaneja","date":"2021-12-19"}]},"_zoodb":{"id":"niset_andersen_cerf","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/niset_andersen_cerf.yml","source_file_modification_token":1687727505567.8267}},"quantum_bpsk":{"code_id":"quantum_bpsk","physical":"oscillators","logical":"reals","name":"BPSK c-q code","description":"Coherent-state c-q binary code encoding into two coherent states \\(|\\pm\\alpha\\rangle\\) for complex \\(\\alpha\\). The three-state subcode \\(\\{|\\alpha,\\alpha\\rangle,|-\\alpha,\\alpha\\rangle,|\\alpha,-\\alpha\\rangle\\}\\) of two-mode BPSK is called the \\textit{single-degeneracy code} \\cite{arxiv:1101.1550}.","features":{"rate":"The single-degeneracy code yields an improved PIE by \\(2.8\\%\\) over BPSK \\cite{doi:10.1103/PhysRevA.61.032309} (see \\cite{arxiv:1101.1550}).","decoders":["Linear-optical quantum receiver \\cite{arxiv:1103.5592}.","Kennedy receiver \\cite{manual:{Kennedy, Robert S. \"A near-optimum receiver for the binary coherent state quantum channel.\" Quarterly Progress Report 108 (1973): 219-225.},arxiv:0706.1038}.","Photon-number resolving detector \\cite{arxiv:1807.05199}.","Non-Gaussian near-optimal receiver \\cite{arxiv:0706.1038}.","Multi-stage quantum receiver \\cite{arxiv:1404.5033}."]},"realizations":["Linear-optical quantum receiver \\cite{arxiv:1103.5592}.","Homodyne receiver \\cite{arxiv:0809.4953}.","Kennedy receiver \\cite{arxiv:0809.4953,arxiv:1911.08932}.","Photon-number resolving detector \\cite{arxiv:1807.05199}.","Communication over dephasing \\cite{arxiv:1907.12515}, time-varying phase-noise \\cite{doi:10.1103/PhysRevResearch.2.023384}, and thermal-noise \\cite{arxiv:2007.11109} channels.","Adaptive decoder using displacements and photon detection \\cite{arxiv:2207.12234}."],"relations":{"parents":[{"code_id":"quantum_psk"},{"code_id":"quantum_hadamard_bpsk"}],"cousins":[{"code_id":"bpsk","detail":"BPSK (BPSK c-q) codes are used to transmit classical information using antipodal coherent states over classical (quantum) channels."},{"code_id":"two-legged-cat","detail":"BPSK c-q (two-component cat) codes are used to transmit classical (quantum) information using (superpositions of) antipodal coherent states over quantum channels."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-13"}]},"_zoodb":{"id":"quantum_bpsk","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/psk/quantum_bpsk.yml","source_file_modification_token":1687727505567.9165}},"quantum_hadamard_bpsk":{"code_id":"quantum_hadamard_bpsk","physical":"oscillators","logical":"reals","name":"Hadamard BPSK c-q code","introduced":"\\cite{arxiv:1101.1550}","description":"Multimode coherent-state c-q code \\(n\\)-mode coherent states whose components \\(\\pm\\alpha\\) are arranged according to rows of a Hadamard matrix.\n","features":{"rate":"Using a joint-detection receiver, the code achieves the Holevo capacity of the lossy bosonic channel \\cite{arxiv:1101.1550}."},"relations":{"parents":[{"code_id":"coherent_state_c-q"},{"code_id":"concatenated_c-q","detail":"The Hadamard BPSK c-q code can be thought of as a concatenation of the Hadamard binary linear code with BPSK for the purposes of transmission of classical information over quantum channels."}],"cousins":[{"code_id":"hadamard","detail":"The Hadamard BPSK c-q code can be thought of as a concatenation of the Hadamard binary linear code with BPSK for the purposes of transmission of classical information over quantum channels."},{"code_id":"bpsk","detail":"The Hadamard BPSK c-q code can be thought of as a concatenation of the Hadamard binary linear code with BPSK for the purposes of transmission of classical information over quantum channels."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-31"}]},"_zoodb":{"id":"quantum_hadamard_bpsk","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/psk/quantum_hadamard_bpsk.yml","source_file_modification_token":1687727505567.9783}},"quantum_psk":{"code_id":"quantum_psk","physical":"oscillators","logical":"reals","name":"PSK c-q code","introduced":"\\cite{doi:10.1038/nphoton.2014.280}","description":"Coherent-state c-q \\(q\\)-ary code whose \\(j\\)th codeword corresponds to a coherent state whose phase is the \\(j\\)th multiple of \\(2\\pi/q\\). These states are also called geometrically uniform states (GUS) \\cite{doi:10.1109/18.915636}.","protection":"The error probability for \\(q=4\\) under an optimal quantum detector is worked out in \\cite[Sec. IV.3]{preset:Helstrom}; see also \\cite{doi:10.1109/18.915636,doi:10.1109/26.752130,arxiv:1410.5282}.\n","features":{"decoders":["Multi-stage quantum receivers \\cite{arxiv:quant-ph/0410133,doi:10.1103/PhysRevA.84.062324,arxiv:0905.2496,arxiv:1208.1815,arxiv:1302.2691,arxiv:1304.7316}.","Bayesian inference \\cite{arxiv:1802.08287}."]},"realizations":["Unambiguous state discrimination using displacement-based receiver for 4-PSK \\cite{doi:10.1038/ncomms3028}.","Multi-stage quantum receivers \\cite{doi:10.1038/nphoton.2012.316,arxiv:2001.05902,doi:10.1038/nphoton.2014.280,arxiv:1711.00074}.","Bayesian inference \\cite{doi:10.1364/CLEO_QELS.2020.FF1D.1}.","Time resolving quantum receiver opertaing in the telecom C band \\cite{doi:10.1116/5.0123880}.","Displacements and photon detection \\cite{arxiv:2009.02558}.","Adaptive decoder using linear-optical elements and photon detection \\cite{arxiv:2207.12234}."],"relations":{"parents":[{"code_id":"quantum_fsk","detail":"The CFSK c-q code reduces to the \\(q\\)-ary PSK c-q code when \\(\\Delta\\omega = 0\\) and \\(\\Delta\\theta = 2\\pi/q\\)."}],"cousins":[{"code_id":"psk","detail":"PSK (PSK c-q) codes are used to transmit classical information using single-mode coherent states distributed on a circle over classical (quantum) channels."},{"code_id":"cat","detail":"PSK c-q (cat) codes are used to transmit classical (quantum) information using (superpositions of) single-mode coherent states distributed on a circle over quantum channels."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"}]},"_zoodb":{"id":"quantum_psk","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/psk/quantum_psk.yml","source_file_modification_token":1687727505568.0388}},"quantum_fsk":{"code_id":"quantum_fsk","physical":"oscillators","logical":"reals","name":"Coherent FSK (CFSK) c-q code","short_name":"CFSK c-q","introduced":"\\cite{arXiv:1802.08287,doi:10.1103/PRXQuantum.1.010308}","description":"\\hyperref[code:coherent_state_c-q]{Coherent-state c-q code} encoding into coherent states that are frequency-shifted with certain initial relative phase. Codewords are coherent states \\(|\\alpha_m\\rangle\\), where \\begin{align} \\alpha_m = \\alpha e^{i(\\omega_0+[m-1]\\Delta\\omega)t+i(m-1)\\Delta\\theta} \\end{align} for common frequency \\(\\omega_0\\), frequency shift \\(\\Delta\\omega < 2\\pi/T\\), total time \\(T\\), and phase shift \\(\\Delta\\theta\\).","protection":"The square-root measurement is not optimal for CFSK c-q codes, unlike for PSK c-q codes \\cite{arXiv:2203.09822}.\n","features":{"decoders":["Bondurant receiver \\cite{doi:10.1364/OL.18.001896}.","Cyclic receiver \\cite{doi:10.1364/OSAC.409200}.","Time-resolving receiver \\cite{arXiv:1802.08287,doi:10.1103/PRXQuantum.1.010308,doi:10.1038/s41534-022-00573-9}.","Bayesian inference \\cite{arxiv:1802.08287}."]},"realizations":["Time-resolving quantum receiver \\cite{doi:10.1038/s41534-022-00573-9}.","Bondurant receiver \\cite{doi:10.1364/OSAC.409200}.","Bayesian inference \\cite{doi:10.1103/PRXQuantum.1.010308}."],"relations":{"parents":[{"code_id":"coherent_state_c-q"}],"cousins":[{"code_id":"fsk"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"},{"user_id":"IvanBurenkov","date":"2022-12-04"}]},"_zoodb":{"id":"quantum_fsk","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/quantum_fsk.yml","source_file_modification_token":1687727505568.0996}},"quantum_ook":{"code_id":"quantum_ook","physical":"oscillators","logical":"reals","name":"On-off keyed (OOK) c-q code","short_name":"OOK c-q","introduced":"\\cite{doi:10.1038/nature05655}","description":"Coherent-state c-q binary code whose encoding is either in the vacuum \\(|0\\rangle\\) or in a nonzero coherent state \\(|\\alpha\\rangle\\).","features":{"decoders":["Dolinar receiver \\cite{manual:{Dolinar, Samuel Joseph. \"An optimum receiver for the binary coherent state quantum channel.\" Research Laboratory of Electronics, MIT, Quarterly Progress Report 11 (1973): 115-120.}}.","Superconducting transition edge sensor (TES) photon-number resolving detector \\cite{doi:10.1364/OE.18.008107}."]},"realizations":["Proof-of-principle experiments using Dolinar \\cite{doi:10.1038/nature05655} and TES receivers \\cite{doi:10.1364/OE.18.008107}."],"relations":{"parents":[{"code_id":"coherent_state_c-q"}],"cousins":[{"code_id":"quantum_bpsk","detail":"OOK c-q codewords are related to BPSK c-q codewords by a displacement in phase space."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-13"}]},"_zoodb":{"id":"quantum_ook","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/quantum_ook.yml","source_file_modification_token":1687727505568.157}},"quantum_ppm":{"code_id":"quantum_ppm","physical":"oscillators","logical":"reals","name":"PPM c-q code","introduced":"\\cite{arXiv:1111.4017}","description":"A \\(q\\)-PPM c-q code is a coherent-state c-q code whose \\(j\\)th codeword corresponds to a tensor-product state of zero-amplitude coherent states at all modes except mode \\(j\\).\nFor example, a 3-PPM encoding corresponds to the three-mode states \\(|\\alpha\\rangle|0\\rangle|0\\rangle\\), \\(|0\\rangle|\\alpha\\rangle|0\\rangle\\), and \\(|0\\rangle|0\\rangle|\\alpha\\rangle\\) for some complex \\(\\alpha\\).\nThe dual of a PPM code is obtained by the exchange \\(0\\leftrightarrow\\alpha\\).\n","protection":"The error probability under an optimal quantum detector is worked out in \\cite[Sec. IV.2]{preset:Helstrom}.\n","features":{"decoders":["Conditional pulse nulling (CPN) receiver \\cite{manual:{S. J. Dolinar, Jr., “A near-optimum receiver structure for the detection of M-ary optical PPM signals”, The Telecommunications and Data Acquisition Progress Report 42 72: December 1982; NASA: Pasadena, CA, (1983)}}."]},"realizations":["Conditional pulse nulling (CPN) receiver \\cite{arxiv:1111.4017}."],"relations":{"parents":[{"code_id":"coherent_state_c-q"}],"cousins":[{"code_id":"ppm"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"}]},"_zoodb":{"id":"quantum_ppm","source_file_path":"codes/classical_into_quantum/oscillators/coherent_state/quantum_ppm.yml","source_file_modification_token":1687727505568.2131}},"polar_for_quantum":{"code_id":"polar_for_quantum","physical":"qubits","logical":"bits","name":"Polar c-q code","introduced":"\\cite{arxiv:1109.2591,arxiv:1701.03397}","description":"Polar code adapted to transmit classical information over channels with classical inputs and quantum outputs.\n","features":{"rate":"Codes achieve the symmetric Holevo information for sending classical information over any quantum channel.","decoders":["Quantum-limited successive-cancellation (SC) joint-detection receiver \\cite{arxiv:1109.2591}."]},"relations":{"parents":[{"code_id":"qubit_classical_into_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"},{"user_id":"VictorVAlbert","date":"2022-10-31"}]},"_zoodb":{"id":"polar_for_quantum","source_file_path":"codes/classical_into_quantum/qubits/polar_for_quantum.yml","source_file_modification_token":1678631058732.3071}},"qubit_classical_into_quantum":{"code_id":"qubit_classical_into_quantum","physical":"qubits","logical":"bits","name":"Qubit c-q code","description":"Qubit code designed for transmission of classical information in the form of bits through non-classical channels.\n","relations":{"parents":[{"code_id":"classical_into_quantum"}],"cousins":[{"code_id":"qubits_into_qubits","detail":"Qubit c-q codes are qubit codes designed to transmit classical information."}]},"realizations":["Quantum enhancement was demonstrated using a polarization-based non-error-correcting c-q encodings \\cite{arxiv:1704.07036}."],"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"}]},"_zoodb":{"id":"qubit_classical_into_quantum","source_file_path":"codes/classical_into_quantum/qubits/qubit_classical_into_quantum.yml","source_file_modification_token":1684508734551.5242}},"eacq":{"code_id":"eacq","name":"Entanglement-assisted hybrid classical-quantum (EACQ) code","short_name":"EACQ","introduced":"\\cite{arXiv:0802.2414,arxiv:0807.2080,arxiv:1911.12260,arxiv:2202.02184}","description":"Stub..","relations":{"parents":[{"code_id":"oaecc","detail":"EACQ codes utilize additional ancillary subsystems in a pre-shared entangled state, but reduce to operator-algebra QECCs when said subsystems are interpreted as noiseless physical subsystems."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-12"}]},"_zoodb":{"id":"eacq","source_file_path":"codes/eacq.yml","source_file_modification_token":1687727505568.3037}},"oaecc":{"code_id":"oaecc","name":"Operator-algebra error-correcting code","short_name":"Operator-algebra QECC","introduced":"\\cite{arXiv:quant-ph/0203105,arxiv:quant-ph/0608071,arXiv:0705.1574,arxiv:1005.0353,doi:10.1142/S0219749908003839,arxiv:2012.14001}","description":"Encodes quantum and/or classical information into a collection of subsystems of a Hilbert space \\(\\mathsf{H}\\) that is determined by a finite dimensional \\(C^*\\) algebra \\(\\mathcal{A}\\) of operators on \\(\\mathsf{H}\\).\nThis \\textit{logical algebra} induces a decomposition of the Hilbert space as\n\\begin{align}\\mathsf{H} = \\bigoplus_\\gamma A_\\gamma \\otimes B_\\gamma,\\end{align}\nwith respect to which \\(\\mathcal{A}\\) takes the form\n\\begin{align}\\mathcal{A} = \\bigoplus_\\gamma I_\\gamma \\otimes \\mathcal{L}(B_\\gamma),\\end{align}\nwhere \\(\\mathcal{L}(B_\\gamma)\\) denotes the full set of linear maps on \\(B_\\gamma\\).","protection":"Given an error operation \\(\\mathcal{E}\\), one says that \\(\\mathcal{A}\\) is \\textit{correctable} for \\(\\mathcal{E}\\) if there exists a recovery operation \\(\\mathcal{R}\\) such that\n\\begin{align}P_{\\mathcal{A}} (\\mathcal{R} \\circ \\mathcal{E})^\\dagger(X) P_{\\mathcal{A}} = X\\end{align} for all \\(X \\in \\mathcal{A}\\), where \\(P_{\\mathcal{A}}\\) is the unit projection onto \\(\\mathcal{A}\\).\n\nEquivalently, \\(\\mathcal{A}\\) is correctable for \\(\\mathcal{E}\\) if there exists a recovery operation \\(\\mathcal{R}\\) such that for any \\(\\gamma\\) and density operators \\(\\rho_\\gamma,\\sigma_\\gamma\\) supported on \\(A_\\gamma\\) and \\(B_\\gamma\\), respectively, there exists a state \\(\\tau_\\gamma\\) supported on \\(A_\\gamma\\) such that\n\\begin{align}(\\mathcal{R} \\circ \\mathcal{E})(\\rho_\\gamma \\otimes \\sigma_\\gamma) = \\tau_\\gamma \\otimes \\sigma_\\gamma.\\end{align}\n\nAn algebraic condition for correctability can be given in terms of the Kraus operators \\(E_j\\) of \\(\\mathcal{E}\\).\nIndeed, \\(\\mathcal{A}\\) is correctable for \\(\\mathcal{E}\\) if \\begin{align}P_{\\mathcal{A}} E_j^\\dagger E_k P_{\\mathcal{A}} \\in \\mathcal{A}'\\end{align}\nfor all \\(j,k\\), where \\(\\mathcal{A}'\\) is the commutant of \\(\\mathcal{A}\\).\n","_meta":{"changelog":[{"user_id":"MichaelLiu","date":"2023-17-06"},{"user_id":"VictorVAlbert","date":"2021-11-24"}]},"_zoodb":{"id":"oaecc","source_file_path":"codes/oaecc.yml","source_file_modification_token":1689550329216.0496}},"category_quantum":{"code_id":"category_quantum","physical":"categories","logical":"categories","name":"Category-based quantum code","description":"Encodes a finite-dimensional \\textit{logical} Hilbert space into a \\textit{physical} Hilbert space associated with a finite category.\nCodes on modular fusion categories are often associated with a particular topological quantum field theory (TQFT), as the data of such theories is described by such categories.\n","relations":{"parents":[{"code_id":"qecc_finite"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-08"}]},"_zoodb":{"id":"category_quantum","source_file_path":"codes/quantum/categories/category_quantum.yml","source_file_modification_token":1678631058732.5054}},"enriched_string_net":{"code_id":"enriched_string_net","physical":"categories","logical":"categories","name":"Multi-fusion string-net code","introduced":"\\cite{arxiv:1412.6589}","description":"Family of codes resulting from the string-net construction but whose input is a unitary multi-fusion category (as opposed to a unitary fusion category).\n","relations":{"parents":[{"code_id":"category_quantum"},{"code_id":"commuting_projector"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-05"}]},"_zoodb":{"id":"enriched_string_net","source_file_path":"codes/quantum/categories/enriched_string_net.yml","source_file_modification_token":1684508734551.7087}},"fibonacci":{"code_id":"fibonacci","physical":"categories","logical":"categories","name":"Fibonacci string-net code","introduced":"\\cite{arxiv:cond-mat/0404617,arxiv:1002.2816}","description":"Quantum error correcting code associated with the Levin-Wen string-net model with the Fibonacci input category, admitting two types of encodings.\n\nThe first type of encoding is into the ground-state subspace of the Levin-Wen model Hamiltonian, defined on a cell decomposition (dual to a triangulation) of a manifold with a qubit on each link. The code space is the simultaneous \\(+1\\) eigenspace of a set of vertex operators and plaquette operators, which are defined by the fusion rules and the numerical data of the Fibonacci category, respectively. The degeneracy of the code space is \\(4g\\),\nwere \\(g\\) is the genus of the surface on which the cell decomposition is defined.\n\nThe second type of encoding is into the degenerate fusion space of a number of anyonic quasiparticle excitations of the Levin-Wen model. This can equivalently constructed by braiding holes in a spherical geometry \\cite[Sec. 5]{arxiv:1002.2816}.\n","protection":"When defined on a \\(L \\times L\\) tailed honeycomb lattice on a torus, the code distance for ground-state encoding is \\(L\\).","features":{"transversal_gates":"A universal transversal gate set could be implemented in a folded version of this code using the techniques introduced in Ref.\\cite{arXiv:1711.05752}.","general_gates":["Universal gate set for the ground-state encoding is implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles. These Dehn-twists can be implemented using constant-dept circuits when allowing long-range permutations of qubits \\cite{arXiv:1806.02358,arxiv:1806.06078}.","Universal gate set for the fusion-space encoding is implemented through braiding of the computational anyons \\cite{arXiv:quant-ph/0001108,arxiv:1002.2816}. Circuit-based gates can be converted into braid patterns via quantum compiling algorithms \\cite{arxiv:1310.4150,arxiv:2008.10790}."],"decoders":["Clustering decoder (provides best known threshold for this code) \\cite{arxiv:1506.03815,arxiv:1607.02159,arXiv:2012.04610}.","Fusion-aware iterative minimum-weight perfect matching decoder. Note that ordinary MWPM decoders do not produce a threshold with this code \\cite{arXiv:2012.04610}.","Cellular automaton decoder \\cite{arxiv:2301.00054}."],"code_capacity_threshold":["\\(4.7\\%\\) for depolarizing noise, \\(7.3\\%\\) for dephasing noise, and \\(3.8\\%\\) for bit-flip noise with clustering decoder, assuming perfect measurements and gates \\cite{arXiv:2012.04610}. See also Ref. \\cite{arxiv:1506.03815}.","\\(3.0\\%\\) for depolarizing noise, \\(6.0\\%\\) for dephasing noise, and \\(2.5\\%\\) for bit-flip noise with fusion-aware iterative MWPM decoder, assuming perfect measurements and gates \\cite{arXiv:2012.04610}."],"threshold":["Between \\(10^{-2}\\%\\) and \\(5\\cdot 10^{-2}\\%\\) for pair-creation and measurement noise \\cite{arxiv:2301.00054}."]},"realizations":["NMR: Implementation of braiding-based Hamamard gate on two qubits \\cite{arxiv:2210.12145}."],"relations":{"parents":[{"code_id":"string_net"}]},"_meta":{"changelog":[{"user_id":"AlexisSchotte","date":"2022-01-24"},{"user_id":"VictorVAlbert","date":"2022-01-24"}]},"_zoodb":{"id":"fibonacci","source_file_path":"codes/quantum/categories/fibonacci.yml","source_file_modification_token":1674162588687.9128}},"groupoid_surface":{"code_id":"groupoid_surface","physical":"categories","logical":"categories","name":"Groupoid toric code","introduced":"\\cite{arxiv:2212.01021}","description":"Extension of the Kitaev surface code from abelian groups to groupoids, i.e., multi-fusion categories in which every morphism is an isomorphism \\cite{doi:10.1112/blms/19.2.113}.\nSome models admit fracton-like features such as extensive ground-state degeneracy and excitations with restricted mobility.\nThe robustness of these features has not yet been established.\n","relations":{"parents":[{"code_id":"enriched_string_net","detail":"Groupoid toric-code categories are unitary multi-fusion categories based on matrix algebras \\cite{arxiv:1412.6589}, so groupoid toric codes can equivalently be formulated as multi-fusion string-net codes."}],"cousins":[{"code_id":"fracton","detail":"Some groupiod toric code models admit fracton-like features such as extensive ground-state degeneracy and excitations with restricted mobility."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-05"},{"user_id":"MengCheng","date":"2022-12-05"}]},"_zoodb":{"id":"groupoid_surface","source_file_path":"codes/quantum/categories/groupoid_surface.yml","source_file_modification_token":1671665864791.639}},"string_net":{"code_id":"string_net","physical":"categories","logical":"categories","name":"String-net code","introduced":"\\cite{arxiv:cond-mat/0404617,arxiv:1002.2816}","description":"Also called a \\textit{Turaev-Viro} or \\textit{Levin-Wen model} code.\nCode whose codewords realize a 2D topological order rendered by a Turaev-Viro topological field theory.\nThe corresponding anyon theory is defined by a unitary fusion category \\( \\mathcal{C} \\).\nThe code is defined on a cell decomposition dual to a triangulation of a two-dimensional surface, with a qudit of dimension \\( |\\mathcal{C}| \\) located at each edge of the decomposition.\n\nThe codespace is the ground-state subspace of the Levin-Wen model commuting-projector Hamiltonian \\cite{arxiv:cond-mat/0404617}, a many-body Hamiltonian realizing the 3-manifold Turaev-Viro invariant \\cite{arxiv:1002.2816,arxiv:1106.6033}.\nAlternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model \\cite{arXiv:quant-ph/0001108,arxiv:1002.2816}.\nThe fusion space can have dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.\n\nString-net codes can equivalently be formulated in terms of unitary quantum groupoids \\cite{arxiv:1309.4181}.\n","protection":"Error-correcting properties established in Ref. \\cite{arxiv:2004.11982}.","features":{"encoders":["For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit \\cite{arxiv:2110.02020} or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates \\cite{arXiv:0712.0348,arxiv:0806.4583}."],"general_gates":["Gates can be implemented through topological operations corresponding to elements of the mapping class group, which is generated by Dehn-twists along non-contractible cycles for triangulations of toroidal \\cite{arXiv:1806.02358,arxiv:1806.06078} and hyperbolic \\cite{arXiv:1901.11029} manifolds. Whether or not a gate set is universal depends on the choice of input category; in some cases such as the Ising category, gates can be complemented by topological charge measurements to obtain a universal gate set.","Alternatively, one could encode the logical quantum information into the degenerate fusion space of a number of computational anyons. In this case, a universal logical gate set can be implemented through the braiding of the computational anyons \\cite{arXiv:quant-ph/0001108,arXiv:math/0103200,arxiv:1002.2816}, e.g., for the case of the \\hyperref[code:fibonacci]{Fibonacci} input category."],"decoders":["Fusing nonabelian anyons cannot be done in one step \\cite{arxiv:hep-th/0110205}.","Syndrome measurement circuits analyzed in Ref. \\cite{arXiv:1206.6048}.","Clustering decoder \\cite{arxiv:1607.02159}."]},"relations":{"parents":[{"code_id":"enriched_string_net"},{"code_id":"topological","detail":"String-net codes can be realized using Levin-Wen model Hamiltonians, which realize 2D topological phases based on unitary fusion categories \\cite{arxiv:cond-mat/0404617,arxiv:1002.2816,arxiv:1106.6033}."}]},"_meta":{"changelog":[{"user_id":"AlexisSchotte","date":"2022-01-24"},{"user_id":"DavidAasen","date":"2022-01-24"},{"user_id":"VictorVAlbert","date":"2022-01-24"}]},"_zoodb":{"id":"string_net","source_file_path":"codes/quantum/categories/string_net.yml","source_file_modification_token":1684508734551.886}},"walker_wang":{"code_id":"walker_wang","physical":"categories","logical":"categories","name":"Walker-Wang model code","introduced":"\\cite{arxiv:1104.2632}","description":"A 3D topological code defined by a unitary braided fusion category \\( \\mathcal{C} \\) (also known as a unitary premodular category).\nThe code is defined on a cubic lattice that is resolved to be trivalent, with a qudit of dimension \\( |\\mathcal{C}| \\) located at each edge.\nThe codespace is the ground-state subspace of the Walker-Wang model Hamiltonian \\cite{arxiv:1104.2632}.\nA single-state version of the code provides a resource state for MBQC \\cite{arxiv:2011.04693}.\n","features":{"encoders":["For modular chiral anyon theories, a unitary encoder is conjectured to not be implementable in constant depth because it is believed to be an example of a quantum cellular automaton (i.e., causal or locality-preserving automorphism) that cannot be locally implemented \\cite{arxiv:1812.01625,arxiv:2205.09141}. States of modular gapped gapped theories can be initialized in constant depth \\cite{arxiv:2208.03397}."]},"relations":{"parents":[{"code_id":"category_quantum"},{"code_id":"topological","detail":"Walker-Wang model codes can be realized using Walker-Wang model Hamiltonians, which realize 3D topological phases based on unitary braided fusion categories."}],"cousins":[{"code_id":"string_net","detail":"The Walker-Wang model is a generalization of the 3D version of the Levin-Wen model \\cite[Sec. 5]{arxiv:cond-mat/0404617}, which realizes gauge theories coupled with bosons and fermions."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-28"}]},"_zoodb":{"id":"walker_wang","source_file_path":"codes/quantum/categories/walker_wang.yml","source_file_modification_token":1687727505568.4238}},"eaoecc":{"code_id":"eaoecc","name":"Entanglement-assisted (EA) operator QECC","short_name":"EAOQECC","introduced":"\\cite{arxiv:0708.2142,doi:10.1109/ISIT.2007.4557160}","description":"Subsystem QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.","relations":{"parents":[{"code_id":"oecc","detail":"EQ operator QECCs utilize additional ancillary subsystems in a pre-shared entangled state, but reduce to subsystem QECCs when said subsystems are interpreted as noiseless physical subsystems."},{"code_id":"eacq"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-12"}]},"_zoodb":{"id":"eaoecc","source_file_path":"codes/quantum/eaoecc.yml","source_file_modification_token":1674162588688.027}},"eaqecc":{"code_id":"eaqecc","name":"Entanglement-assisted (EA) QECC","short_name":"EAQECC","introduced":"\\cite{arxiv:quant-ph/0608027,arxiv:quant-ph/0610092}","description":"QECC whose encoding and decoding utilizes pre-shared entanglement between sender and receiver.","notes":["See Ref. \\cite{doi:10.1017/CBO9781139034807.009} for an introduction to EA QEC."],"relations":{"parents":[{"code_id":"qecc","detail":"EA QECCs utilize additional ancillary subsystems in a pre-shared entangled state, but reduce to QECCs when said subsystems are interpreted as noiseless physical subsystems."},{"code_id":"eacq"}],"cousins":[{"code_id":"qudits_into_qudits","detail":"Pure modular-qudit codes can be used to make EA-QECCs with the same distance and dimension; see Thm. 10 of Ref. \\cite{arxiv:2010.07902}."},{"code_id":"binary_linear","detail":"Any linear binary code can be used to construct an EAQECC."},{"code_id":"q-ary_linear","detail":"Any linear \\(q\\)-ary code can be used to construct an EAQECC."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-31"}]},"_zoodb":{"id":"eaqecc","source_file_path":"codes/quantum/eaqecc.yml","source_file_modification_token":1681484685076.322}},"group_gkp":{"code_id":"group_gkp","physical":"groups","logical":"groups","name":"Group GKP code","introduced":"\\cite{arXiv:1911.00099}","description":"Group-based quantum code whose construction is based on nested subgroups \\(H\\subset K\n\\subset G\\). Logical subspace is spanned by basis states that are equal\nsuperpositions of elements of cosets of \\(H\\) in \\(K\\), and can be finite- or\ninfinite-dimensional.\n\nThe group GKP code was originally formulated as an extension of the \\hyperref[code:gkp]{GKP code} construction, and has turned out to encompass a wide variety of codes, tabulated in \\ref{table:group-gkp-codes}.\n\\begin{table}\n  \\begin{cells}\n  \\celldata<c H, c H, c H, l H>{Space & \\(G\\) & \\(H\\) & Related code}\n  \\celldata<c, c, c, l>{\n  \\(n\\) qubits & \\(\\mathbb{Z}_2^n\\) & \\(\\mathbb{Z}_2^m\\)\n      & qubit CSS\n      \\\\\n  \\(n\\) modular qudits & \\(\\mathbb{Z}_q^n\\) & \\(\\mathbb{Z}_q^m\\)\n      & modular-qudit CSS\n      \\\\\n  \\(n\\) modes & \\( \\mathbb{R}^n \\) & \\( \\mathbb{R}^m \\)\n      & analog stabilizer\n      \\\\\n  \\(n\\) modes & \\( \\mathbb{R}^n \\) & \\( \\mathbb{Z}^n \\)\n      & multimode GKP\n      \\\\\n  \\(n\\) modes & \\( \\mathbb{R}^n \\) & \\( \\mathbb{Z}^{m<n} \\)\n      & GKP-stabilizer\n      \\\\\n  planar rotor & \\(U(1)\\) & \\(\\mathbb{Z}_n\\)\n      & rotor GKP\n      \\\\\n  rigid body & \\(SO(3)\\) & point group\n      & molecular\n  }\n  \\end{cells}\n  \\caption{Special cases of group GKP codes}\n  \\label{table:group-gkp-codes}\n\\end{table}\n","protection":"Protects against generalized bit-flip errors \\(g\\in G\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).","features":{"transversal_gates":"Group-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{ k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates representing \\(G\\) \\cite{arxiv:1902.07714}."},"realizations":["Cryptographic applications stemming from the monogamy of entanglement of group GKP code and error words \\cite{arxiv:2212.03935}."],"relations":{"parents":[{"code_id":"group_quantum"}],"cousins":[{"code_id":"css","detail":"Group GKP codes are stabilized by \\(X\\)-type Pauli matrices representing \\(H\\) and all \\(Z\\)-type operators that are constant on \\(K\\). However, the \\(Z\\)-type operators are not unitary for nonabelian groups."},{"code_id":"oscillator_stabilizer","detail":"The group-GKP construction encompasses all bosonic CSS codes. A single-mode qubit GKP code corresponds to the \\(2\\mathbb{Z}\\subset\\mathbb{Z}\\subset\\mathbb{R}\\) group construction, and multimode GKP codes can be similarly described. An \\([[n,k,d]]_{\\mathbb{R}}\\) analog stabilizer code corresponds to the \\(\\mathbb{R}^{ k_1} \\subseteq \\mathbb{R}^{ k_2} \\subset \\mathbb{R}^{n}\\) group construction, where \\(k=k_2/k_1\\). GKP stabilizer codes for \\(n\\) modes correspond to subgroups \\(\\mathbb{Z}^m\\) for \\(m<n\\)."},{"code_id":"cluster_state","detail":"Cluster states can be generalized to finite groups \\cite{arxiv:1408.6237}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-06-03"},{"user_id":"AlexCowtan","date":"2023-06-03"},{"user_id":"VictorVAlbert","date":"2022-09-28"},{"user_id":"PhilippeFaist","date":"2022-09-27"},{"user_id":"VictorVAlbert","date":"2021-11-29"}]},"_zoodb":{"id":"group_gkp","source_file_path":"codes/quantum/groups/group_gkp.yml","source_file_modification_token":1687727505568.534}},"group_quantum":{"code_id":"group_quantum","physical":"groups","logical":"groups","name":"Group-based quantum code","description":"Encodes a \\textit{logical} Hilbert space, finite- or infinite-dimensional, into a \\textit{physical} Hilbert space of \\(\\ell^2\\)-normalizable functions on a second-countable unimodular group. For \\(K\\)-dimensional logical subspace and for groups \\(G^{n}\\), can be denoted as \\(((n,K))_G\\). When the logical subspace is the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(G^{ k}\\), can be denoted as \\([[n,k]]_G\\). Ideal codewords may not be normalizable, depending on whether \\(G\\) is continuous and/or noncompact, so approximate versions have to be constructed in practice.","relations":{"parents":[{"code_id":"qecc"}],"cousins":[{"code_id":"category_quantum","detail":"Category quantum codes whose physical spaces are constructed using a finite group as the category are group codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-03"}]},"_zoodb":{"id":"group_quantum","source_file_path":"codes/quantum/groups/group_quantum.yml","source_file_modification_token":1680994436846.989}},"molecular":{"code_id":"molecular","physical":"groups","logical":"rigid_bodies","name":"Molecular code","introduced":"\\cite{arXiv:1911.00099}","description":"Encodes finite-dimensional Hilbert space into the Hilbert space of \\(\\ell^2\\)-normalizable functions on the group \\(SO_3\\). Construction is based on nested subgroups \\(H\\subset K \\subset SO_3\\), where \\(H,K\\) are finite. The \\(|K|/|H|\\)-dimensional logical subspace is spanned by basis states that are equal superpositions of elements of cosets of \\(H\\) in \\(K\\).","protection":"Protects against generalized bit-flip errors \\(g\\in SO_3\\) that are inside the fundamental domain of \\(G/K\\). Protection against phase-flip errors determined by branching rules of irreps of \\(G\\) into those of \\(K\\), and further into those of \\(H\\).","notes":["Physical space characterizes orientations of a rigid body in 3D, which correspond to rotational states of an asymmetric molecule. See APS Physics Synopsis \\cite{doi:10.1103/Physics.13.s111} and \\href{https://www.youtube.com/watch?v=gjBbMMZ3L1k}{Physical Review Journal club} discussing molecular applications."],"relations":{"parents":[{"code_id":"group_gkp"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"molecular","source_file_path":"codes/quantum/groups/molecular.yml","source_file_modification_token":1678631058732.7888}},"rotor":{"code_id":"rotor","physical":"groups","logical":"groups","name":"Rotor code","description":"Encodes a \\textit{logical} Hilbert space, finite- or infinite-dimensional, into a \\textit{physical} Hilbert space of \\(\\ell^2\\)-normalizable functions on either the integers \\(\\mathbb Z\\) or the circle group \\(U(1)\\).\nIdeal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed in practice.\n","protection":"A rotor analogue of the Pauli string basis for \\hyperref[code:qubits_into_qubits]{qubit} codes consists of rotor generalized Pauli operators.\nFor a single rotor, its elements are products of exponentials of the rotor's angular position (\\(\\hat\\phi\\)) and angular momentum (\\(\\hat L\\)) operators, acting on the rotor's angular position states \\(|\\phi\\rangle\\) for \\(\\phi\\in U(1)\\) as\n\\begin{align}\n  e^{-i\\varphi\\hat{L}}\\left|\\phi\\right\\rangle =\\left|\\phi+\\varphi\\right\\rangle \\,\\,\\text{ and }\\,\\,e^{i\\ell\\hat{\\phi}}\\left|\\phi\\right\\rangle =e^{i\\ell\\phi}\\left|\\phi\\right\\rangle ~,\n\\end{align}\nwhere \\(\\varphi\\in U(1)\\) and \\(\\ell\\in\\mathbb{Z}\\).\nFor multiple rotors, error set elements are tensor products of elements of the single-rotor error set.\nFor multiple rotors, error set elements are tensor products of elements of the single-rotor error set, characterized by vectors of angle and integer coefficients multiplying vectors of angular momentum (\\(\\hat\\boldsymbol{L}\\)) and angular position (\\(\\hat\\boldsymbol{\\phi}\\)) operators.\n","notes":["See Refs. \\cite{arxiv:1709.04460}\\cite[Sec. IV]{arXiv:1911.00099} for introductions to rotor Hilbert spaces."],"relations":{"parents":[{"code_id":"group_quantum","detail":"Group quantum codes whose physical spaces are constructed using either the group of the integers \\(\\mathbb{Z}\\) or the circle group \\(U(1)\\) are rotor codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-27"}]},"_zoodb":{"id":"rotor","source_file_path":"codes/quantum/groups/rotors/rotor.yml","source_file_modification_token":1681484685076.555}},"current_mirror":{"code_id":"current_mirror","physical":"groups","logical":"qudits","name":"Kitaev current-mirror qubit code","introduced":"\\cite{arXiv:cond-mat/0609441,manual:{Kitaev, Alexei Yu. \"Protected qubit based on superconducting current mirror.\" United States Patent Number 7858966B2 (2006).},arxiv:2303.13723}","description":"Member of the family of \\([[2n,(0,2),(2,n)]]_{\\mathbb{Z}}\\) homological rotor codes on a thin Möbius strip.\nThe ideal code can be obtained from a Josephson-junction \\cite{doi:10.1093/acprof:oso/9780199681181.003.0003} system \\cite{arxiv:2303.13723}.\n\nLogical codewords can be expressed in the basis of angular momentum states as\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\sum_{\\overset{\\ell_{1},\\dots,\\ell_{n}\\in\\mathbb{Z}}{\\sum_{k=1}^{n}\\ell_{k}=\\mathrm{even}}}\\left|\\ell_{1},\\dots,\\ell_{n},-\\ell_{1},\\dots,-\\ell_{n}\\right\\rangle \\\\|\\overline{1}\\rangle&=\\sum_{\\overset{\\ell_{1},\\dots,\\ell_{n}\\in\\mathbb{Z}}{\\sum_{k=1}^{n}\\ell_{k}=\\mathrm{odd}}}\\left|\\ell_{1},\\dots,\\ell_{n},-\\ell_{1},\\dots,-\\ell_{n}\\right\\rangle~.\n\\end{split}\n\\end{align}\n","protection":"Protection in the context of superconducting circuits investigated in Refs. \\cite{arxiv:1908.04615}.\n","features":{"general_gates":["One- and two-qubit phase gates utilizing ancillary osillators in GKP states \\cite{arXiv:cond-mat/0609441}."]},"relations":{"parents":[{"code_id":"homological_rotor"},{"code_id":"small_distance"}],"cousins":[{"code_id":"gkp","detail":"Current-mirror code phase gates utilize ancillary osillators in square-lattice GKP states \\cite{arXiv:cond-mat/0609441,arxiv:1302.4122}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-12"}]},"_zoodb":{"id":"current_mirror","source_file_path":"codes/quantum/groups/rotors/stabilizer/css/current_mirror.yml","source_file_modification_token":1681484685076.6802}},"homological_rotor":{"code_id":"homological_rotor","physical":"groups","logical":"groups","name":"Homological rotor code","introduced":"\\cite{arXiv:2303.13723}","description":"A homological quantum rotor code is an extension of \\hyperref[code:analog_stabilizer]{analog stabilizer} codes to rotors.\nThe code is stabilized by a continuous group of rotor X-type and Z-type generalized Pauli operators.\nCodes are formulated using an extension of the \\hyperref[topic:CSS-to-homology-correspondence]{qubit CSS-to-homology correspondence} to rotors.\nThe homology group of the logical operators has a torsion component because the chain complexes are defined over the ring of integers, which yields codes with finite logical dimension, i.e., encoding logical qudits instead of only logical rotors.\nSuch finite-dimensional encodings are not possible with \\hyperref[code:analog_stabilizer]{analog stabilizer} codes.\n\nA homological rotor code encoding \\(k\\) logical rotors and a \\(q\\)-dimensional logical qudit is denoted as \\([[n,(k,q)]]_{\\mathbb{Z}}\\) or \\([[n,(k,q),(d_X,\\delta_Z)]]_{\\mathbb{Z}}\\), where \\(d_X\\) and \\(\\delta_Z\\) are the code's \\(X\\) and \\(Z\\) distances, respectively.\nThe subscript \\(\\mathbb{Z}\\) refers to the label used for the rotor's angular momentum, but shifts in the dual angular position degree of freedom are also used to construct stabilizers.\n\nThe stabilizer group is defined using two integer matrices \\(H_X\\in\\mathbb{Z}^{r_X\\times n}\\) and \\(H_Z\\in\\mathbb{Z}^{r_Z\\times n}\\) which are such that\n\\begin{align}\n      H_XH_Z^T = 0.\\label{eq:commutation}\n\\end{align}\nThe stabilizer is then defined as\n\\begin{align}\n  \\mathsf{S}=\\left\\langle e^{-i\\boldsymbol{s}H_{X}\\cdot\\hat{\\boldsymbol{L}}}e^{i\\boldsymbol{\\varphi}H_{Z}\\cdot\\hat{\\boldsymbol{\\phi}}}\\middle\\vert\\forall\\boldsymbol{s}\\in\\mathbb{Z}^{r_{X}},\\forall\\boldsymbol{\\varphi}\\in U(1)^{r_{Z}}\\right\\rangle .\\label{eq:stabilizer}\n\\end{align}\nThe condition \\eqref{eq:commutation} ensures that \\(\\mathsf{S}\\) has a common +1 eigenspace.\n\nAs with \\hyperref[code:css]{CSS} codes, there is a natural connection to a length-3 integer chain complexes,\n\\begin{align}\n  \\mathcal{A}:~\\mathbb{Z}^{r_X} \\xrightarrow{H_X} \\mathbb{Z}^n \\xrightarrow{H_Z^T} \\mathbb{Z}^{r_Z}~,\n\\end{align}\nwhose middle homology group describes the logical \\(X\\) operators fo the code.\nThe logical \\(Z\\) operators are defined by the middle cohomology group where the cohomology is taken with phase coefficients, \\(\\mathbb{T} = \\mathbb{R}/2\\pi\\mathbb{Z}\\),\n\\begin{align}\n  \\mathcal{A}^*:~\\mathbb{T}^{r_X} \\xleftarrow{H_X^T} \\mathbb{T}^n \\xleftarrow{H_Z} \\mathbb{T}^{r_Z}.\n\\end{align}\n\nThe logical subspace can contain logical rotors as well as logical qudits.\nThe former correspond to the so called free part of the homology group while the latter correspond to the torsion part,\n\\begin{align}\n  H_1(\\mathcal{A},\\mathbb{Z}) = \\mathbb{Z}^{k^\\prime}\\oplus\\mathbb{Z}_{d_1}\\oplus\\cdots\\oplus\\mathbb{Z}_{d_{k^{\\prime\\prime}}}.\n\\end{align}\n","protection":"The \\(X\\) distance \\(d_X\\) of a code is the (slightly generalized notion of) weight of the smallest logical operator constructed out of angular position shifts.\nThe \\(Z\\) distance \\(\\delta_Z\\) depends on whether or not the code encodes logical rotors, but a similar notion exists in the case of only a logical qudit encoding.\nOne can extend the idea of disjointness \\cite{arxiv:1710.07256} to rotors to obtain distance bounds \\cite{arxiv:2303.13723}.\n","features":{"transversal_gates":"All generalized Pauli gates are realized transversally."},"notes":["A Sage notebook to look at small examples can be found in \\url{https://github.com/cianibegood/quantum-rotor-codes}."],"relations":{"parents":[{"code_id":"rotor_stabilizer"},{"code_id":"generalized_homological_product_css","detail":"Homological rotor codes are formulated using an extension of the \\hyperref[topic:CSS-to-homology-correspondence]{qubit CSS-to-homology correspondence} to rotors. The homology group of the logical operators has a torsion component because the chain complexes are defined over the ring of integers, which yields codes with finite logical dimension. Products of chain complexes can also yield rotor codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-12"},{"user_id":"ChristopheVuillot","date":"2023-03-28"}]},"_zoodb":{"id":"homological_rotor","source_file_path":"codes/quantum/groups/rotors/stabilizer/css/homological_rotor.yml","source_file_modification_token":1681484685076.7622}},"rotor_3_1_2":{"code_id":"rotor_3_1_2","physical":"groups","logical":"groups","name":"Three-rotor code","introduced":"\\cite{arxiv:1709.04471}","description":"\\([[3,1,2]]_{\\mathbb Z}\\) rotor code that is an extension of the \\([[3,1,2]]_3\\) qutrit CSS code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and its ideal codewords,\n\\begin{align}\n  |\\overline{x}\\rangle = \\sum_{y\\in\\mathbb{Z}} \\left| -3y,y-x,2(y+x) \\right\\rangle~,\n\\end{align}\nwhere \\(x\\in\\mathbb{Z}\\), are not normalizable.\n","protection":"Normalized codewords approximately protect against erasure while maintaining covariance \\cite{arxiv:1902.07714}.\n","relations":{"parents":[{"code_id":"homological_rotor","detail":"Taking \\(H_X=\\begin{pmatrix}-3 & 1 & 2\\end{pmatrix}\\) and \\(H_Z=\\begin{pmatrix}4&6&3\\end{pmatrix}\\) yields the three-rotor code."},{"code_id":"covariant","detail":"The three-rotor code is \\(U(1)\\)-covariant."},{"code_id":"small_distance"}],"cousins":[{"code_id":"stab_3_1_2"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-27"}]},"_zoodb":{"id":"rotor_3_1_2","source_file_path":"codes/quantum/groups/rotors/stabilizer/css/rotor_3_1_2.yml","source_file_modification_token":1681484685076.829}},"zero_pi":{"code_id":"zero_pi","physical":"groups","logical":"qudits","name":"Zero-pi qubit code","introduced":"\\cite{arxiv:1302.4122,arxiv:1402.7310,arxiv:2303.13723}","description":"A \\([[2,(0,2),(2,1)]]_{\\mathbb{Z}}\\) homological rotor code on the smallest tiling of the projective plane \\(\\mathbb{R}P^2\\).\nThe ideal code can be obtained from a four-rotor Josephson-junction \\cite{doi:10.1093/acprof:oso/9780199681181.003.0003} system after a choice of grounding \\cite{arxiv:2303.13723}.\n\nLogical codewords can be expressed in the basis of angular momentum states as\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\sum_{\\ell\\in\\mathbb{Z}}\\left|2\\ell,-2\\ell\\right\\rangle \\\\|\\overline{1}\\rangle&=\\sum_{\\ell\\in\\mathbb{Z}}\\left|2\\ell+1,-2\\ell-1\\right\\rangle~.\n\\end{split}\n\\end{align}\nAn alternative codeword basis in terms of angular position states is\n\\begin{align}\n\\begin{split}\n  |\\overline{+}\\rangle&=\\intop_{U(1)}d\\phi\\left|\\phi,\\phi\\right\\rangle \\\\|\\overline{-}\\rangle&=\\intop_{U(1)}d\\phi\\left|\\phi,\\phi+\\pi\\right\\rangle~.\n\\end{split}\n\\end{align}\n","protection":"Protection in the context of superconducting circuits investigated in Refs. \\cite{arxiv:1708.02886}.\n","features":{"general_gates":["One- and two-qubit phase gates utilizing ancillary osillators in GKP states \\cite{arXiv:cond-mat/0609441,arxiv:1302.4122}."],"fault_tolerance":["One- and two-qubit phase gate errors can be suppressed \\cite{arxiv:1302.4122}."]},"realizations":["A related superconducting circuit has been realized by the Houck group \\cite{arxiv:1910.07542}."],"notes":["The zero-pi qubit is based on earlier blueprints for protected subspaces using superconducting circuits \\cite{arXiv:cond-mat/0202115,arXiv:cond-mat/0205186}."],"relations":{"parents":[{"code_id":"homological_rotor"},{"code_id":"small_distance"}],"cousins":[{"code_id":"gkp","detail":"Zero-pi code phase gates utilize ancillary osillators in square-lattice GKP states \\cite{arXiv:cond-mat/0609441,arxiv:1302.4122}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-12"}]},"_zoodb":{"id":"zero_pi","source_file_path":"codes/quantum/groups/rotors/stabilizer/css/zero_pi.yml","source_file_modification_token":1681484685076.8933}},"rotor_5_1_3":{"code_id":"rotor_5_1_3","physical":"groups","logical":"groups","name":"Five-rotor code","introduced":"\\cite{arxiv:1902.07714}","description":"Extension of the five-qubit stabilizer code to the integer alphabet, i.e., the angular momentum states of a planar rotor. The code is \\(U(1)\\)-covariant and ideal codewords are not normalizable.\n","protection":"Normalized codewords approximately protect against erasure while maintaining covariance \\cite{arxiv:1902.07714}.\n","relations":{"parents":[{"code_id":"rotor_stabilizer"},{"code_id":"covariant","detail":"The five-rotor code is \\(U(1)\\)-covariant."},{"code_id":"quantum_cyclic"},{"code_id":"small_distance"}],"cousins":[{"code_id":"qudit_5_1_3","detail":"The five-rotor code is a bosonic analogue of the five-qudit code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-27"}]},"_zoodb":{"id":"rotor_5_1_3","source_file_path":"codes/quantum/groups/rotors/stabilizer/rotor_5_1_3.yml","source_file_modification_token":1681484685076.9417}},"rotor_gkp":{"code_id":"rotor_gkp","physical":"groups","logical":"qudits","name":"Rotor GKP code","introduced":"\\cite{arxiv:quant-ph/0008040,arxiv:1911.00099}","description":"GKP code protecting against small angular position and momentum shifts of a planar rotor.","relations":{"parents":[{"code_id":"rotor_stabilizer"},{"code_id":"group_gkp","detail":"Rotor GKP codes correspond to the \\(\\mathbb{Z}_{k_1} \\subseteq \\mathbb{Z}_{k_2} \\subset U(1)\\) group construction, where \\(k=k_2/k_1\\)."}],"cousins":[{"code_id":"gkp","detail":"GKP (rotor GKP) codes protect against shifts in linear (angular) degrees of freedom."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-30"}]},"_zoodb":{"id":"rotor_gkp","source_file_path":"codes/quantum/groups/rotors/stabilizer/rotor_gkp.yml","source_file_modification_token":1681484685076.996}},"rotor_stabilizer":{"code_id":"rotor_stabilizer","physical":"groups","name":"Rotor stabilizer code","description":"Rotor code whose codespace is defined as the common \\(+1\\) eigenspace of a group of mutually commuting rotor generalized Pauli operators.\nThe stabilizer group can be either discrete or continuous, corresponding to modular or linear constraints on angular positions and momenta.\nBoth cases can yield finite or infinite logical dimension.\nExact codewords are non-normalizable, so approximate constructions have to be considered.\n","relations":{"parents":[{"code_id":"rotor"},{"code_id":"stabilizer"}],"cousins":[{"code_id":"css","detail":"A rotor stabilizer code admitting a set of generators such that each generator consists of either angular position or angular momentum operators is a CSS code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-12"}]},"_zoodb":{"id":"rotor_stabilizer","source_file_path":"codes/quantum/groups/rotors/stabilizer/rotor_stabilizer.yml","source_file_modification_token":1681484685077.073}},"generalized_color":{"code_id":"generalized_color","physical":"groups","logical":"groups","name":"Generalized color code","introduced":"\\cite{arXiv:1408.6238}","description":"Member of a family of nonabelian topological codes, defined by a finite group \\( G \\), that serves as a generalization of the color code (for which \\(G=\\mathbb{Z}_2\\times\\mathbb{Z}_2\\)).\n","relations":{"parents":[{"code_id":"tqd","detail":"The anyon theory corresponding to a generalized color code is a trivial-cocycle TQD associated with the group \\(G \\times G/[G,G]\\), where \\(G\\) is any finite group."}],"cousins":[{"code_id":"group_gkp","detail":"Generalized color-code Hamiltonians should be expressable in terms of \\(X\\)- and \\(Z\\)-type operators of group-GKP codes; see \\cite[Sec. 3.3]{arxiv:2111.12096}."},{"code_id":"quantum_double","detail":"Generalized color code for group \\(G\\) on the 4.8.8 lattice is equivalent to a \\(G\\) quantum double model and another \\(G/[G,G]\\) quantum double model defined using the abelianization of \\(G\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-31"}]},"_zoodb":{"id":"generalized_color","source_file_path":"codes/quantum/groups/topological/generalized_color.yml","source_file_modification_token":1683723710996.6714}},"quantum_double":{"code_id":"quantum_double","physical":"groups","logical":"groups","name":"Quantum-double code","introduced":"\\cite{arXiv:quant-ph/9707021}","description":"Group-GKP stabilizer code whose codewords realize 2D modular gapped topological order defined by a finite group \\(G\\).\nThe code's generators are few-body operators associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface (with a qudit of dimension \\( |G| \\) located at each edge of the tesselation).\n\nThe physical Hilbert space has dimension \\( |G|^E  \\), where \\( E \\) is the number of  edges in the tessellation. The dimension of the code space is the number of orbits of the conjugation action of \\( G \\) on \\( \\text{Hom}(\\pi_1(\\Sigma),G) \\), the set of group homomorphisms from the fundamental group of the surface \\( \\Sigma \\) into the finite group \\( G \\) \\cite{arXiv:1908.02829}. When \\( G \\) is abelian, the formula for the dimension simplifies to \\( |G|^{2g} \\), where \\( g \\) is the genus of the surface \\( \\Sigma \\).\n\nThe codespace is the ground-state subspace of the quantum double model Hamiltonian.\nFor nonabelian groups, alternative constructions are possible, encoding information in the fusion space of the low-energy anyonic quasiparticle excitations of the model \\cite{doi:10.1007/3-540-49208-9_31,arXiv:quant-ph/0306063,doi:10.1017/CBO9780511792908}.\nThe fusion space of such nonabelian anyons has dimension greater than one, allowing for topological quantum computation of logical information stored in the fusion outcomes.\n","protection":"Error-correcting properties established in Ref. \\cite{arxiv:1908.02829}.\nThe code distance is the number of edges in the shortest non contractible cycle in the tesselation or dual tesselation  \\cite{arXiv:quant-ph/0110143}.\n","features":{"encoders":["A depth-\\(L^2\\) circuit that grows the code out of a small patch on an \\(L\\times L\\) square lattice using CMULT gates (i.e., \"local moves\") \\cite{arxiv:0712.0348,arxiv:1101.0527}.","For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit \\cite{arXiv:0901.1345,arXiv:1101.0527} or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates \\cite{arXiv:0712.0348,arxiv:0806.4583}.","For any solvable group \\(G\\), ground-state preparation and anyon-pair creation can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout \\cite{arXiv:2112.01519,arXiv:2205.01933} (see Ref. \\cite{arXiv:2112.03061} for specific dihedral groups). Anyon-pair creation requires an adaptive circuit for any nonabelian \\(G\\) \\cite{arXiv:2205.01933}."],"general_gates":["Universal topological quantum computation possible for certain groups \\cite{arxiv:quant-ph/0306063,arxiv:0901.1345}."],"decoders":["For any solvable group \\(G\\), topological charge measurements can be done with an adaptive constant-depth circuit with geometrically local gates and measurements throughout \\cite{arXiv:2205.01933}."]},"notes":["See Ref. \\cite{doi:10.1103/RevModPhys.51.659} for a review of gauge theory, which admits quantum-double topological phases."],"relations":{"parents":[{"code_id":"group_gkp","detail":"Quantum-double Hamiltonians can be expressed in terms of \\(X\\)- and \\(Z\\)-type operators of group-GKP codes; see \\cite[Sec. 3.3]{arxiv:2111.12096}."},{"code_id":"tqd","detail":"The anyon theory corresponding to a quantum-double code is a TQD with trivial cocycle."},{"code_id":"string_net","detail":"String-net model reduces to the quantum-double model for group categories."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-05"},{"user_id":"VictorVAlbert","date":"2022-01-03"},{"user_id":"IanTeixeira","date":"2021-12-19"}]},"_zoodb":{"id":"quantum_double","source_file_path":"codes/quantum/groups/topological/quantum_double.yml","source_file_modification_token":1689550329216.1768}},"quantum_double_dihedral":{"code_id":"quantum_double_dihedral","physical":"groups","logical":"groups","name":"Dihedral \\(G=D_m\\) quantum-double code","introduced":"\\cite{arXiv:quant-ph/9707021}","description":"Quantum-double code whose codewords realize \\(G=D_m\\) topological order associated with a \\(2m\\)-element dihedral group \\(D_m\\).\nIncludes the simplest non-Abelian order \\(D_3 = S_3\\) associated with the permutation group of three objects.\n","features":{"general_gates":["Universal topological quantum computation possible for certain groups such as \\(G=D_3=S_3\\) \\cite{arxiv:quant-ph/0306063,arxiv:0901.1345}."]},"realizations":["Signatures of a phase equivalent to the \\(G=D_4\\) quantum double detected in a 27-qubit trapped-ion device by Quantinuum \\cite{arxiv:2305.03766}. Preparation of ground states and braiding of anyons has also been performed. The phase was realized as a gauged \\(G=\\mathbb{Z}_3^2\\) twisted quantum double  \\cite{arxiv:1508.03468}, which is the same topological order as the \\(G=D_4\\) quantum double \\cite{arxiv:hep-th/9511195,arxiv:2112.12757}."],"notes":["See \\cite[Sec. 5.4]{doi:10.1017/CBO9780511792908} for an introduction to this code.","The \\( \\Phi, \\Lambda \\)  \\href{https://citizensciencegames.com/games/decodoku/}{Decodoku game} is based on the quantum double model for the group \\(D_3=S_3\\) of permutations on three letters.","Popular summary of realization of non-Abelian topological order in \\href{https://www.quantamagazine.org/physicists-create-elusive-particles-that-remember-their-pasts-20230509/}{Quanta Magazine}."],"relations":{"parents":[{"code_id":"quantum_double"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-09"}]},"_zoodb":{"id":"quantum_double_dihedral","source_file_path":"codes/quantum/groups/topological/quantum_double_dihedral.yml","source_file_modification_token":1683978912608.1658}},"tqd":{"code_id":"tqd","physical":"groups","logical":"groups","name":"Twisted quantum double (TQD) code","short_name":"TQD","introduced":"\\cite{arxiv:1211.3695,arxiv:2107.13091}","description":"Code whose codewords realize a 2D topological order rendered by a Chern-Simons topological field theory.\nThe corresponding anyon theory is defined by a finite group \\(G\\) and a Type-III group cocycle.\n\nA code Hamiltonian can be obtained from a 2D model with symmetry-protected topological (SPT) order by gauging the model's symmetry.\nThe same group and cocycle data classifies both 2D SPTs and TQDs \\cite{arxiv:1301.0861}.\n","relations":{"parents":[{"code_id":"group_quantum"},{"code_id":"string_net","detail":"String-net models reduce to TQDs for categories \\(\\text{Vec}_G^\\omega\\), where \\(G\\) is a finite group, and \\(\\omega\\) is a Type III cocycle. There is also a more direct duality between a large class of string–net models and certain TQD models \\cite{arxiv:1211.3695}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-06"}]},"_zoodb":{"id":"tqd","source_file_path":"codes/quantum/groups/topological/tqd.yml","source_file_modification_token":1680994436847.3442}},"oecc":{"code_id":"oecc","name":"Subsystem quantum error-correcting code","short_name":"Subsystem QECC","introduced":"\\cite{arXiv:quant-ph/0412076,arXiv:quant-ph/0504189}","description":"A subsystem code, also known as an \\textit{operator QECC} or \\textit{gauge QECC}, encodes information in a subsystem \\(\\mathsf{A}\\) of the code space \\(\\mathsf{C}\\), which is part of the system Hilbert space \\(\\mathsf{H}\\), as\n\\begin{align}\n\\mathsf{H}=\\mathsf{C} \\oplus \\mathsf{C}^{\\perp} = \\mathsf{A} \\otimes \\mathsf{B} \\oplus \\mathsf{C}^{\\perp}~.\n\\end{align}\nFollowing an error, it is sufficient to revert back to the original state modulo a transformation on the auxiliary or \\textit{gauge} subsystem \\(\\mathsf{B}\\). The subsystem \\(\\mathsf{B}\\) therefore gives additional freedom to the error correction process, and is said to encode \\textit{gauge qubits} when its dimension is a power of two. While strictly speaking all operator QECCs are also ordinary QECCs, the attachment of a subsystem to a code allows for a wider variety of encoding procedures, fault-tolerant logical operations, and efficient error-correction protocols.\n","protection":"Necessary and sufficient \\cite{arxiv:quant-ph/0506069} error-correction conditions are, for all errors \\(E_a,E_b\\) in an error set \\(\\cal{E}\\),\n\\begin{align}\nP E^{\\dagger}_a E_b P = I_{\\mathsf{A}} \\otimes g_{ab}^{\\mathsf{B}}\n\\end{align}\nwhere \\(P\\) is a projector onto the codespace \\(\\mathsf{C}\\), and \\(g_{ab}^{\\mathsf{B}}\\) is an arbitrary operator on the gauge subsystem.\n","notes":["See Ref. \\cite{doi:10.1017/CBO9781139034807.008} for an introduction to operator QEC."],"relations":{"parents":[{"code_id":"oaecc"},{"code_id":"quantum_into_quantum"}],"cousins":[{"code_id":"qecc","detail":"A subsystem code reduces to an ordinary error-correcting code when the gauge subsystem is trivial, \\(\\mathsf{B} = \\mathbb{C}\\). Conversely, any QECC with a tensor-product logical subspace can be turned into a subsystem code by treating a logical tensor factor as a gauge subsystem."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-02"},{"user_id":"SrilekhaGandhari","date":"2021-12-14"},{"user_id":"VictorVAlbert","date":"2021-11-24"}]},"_zoodb":{"id":"oecc","source_file_path":"codes/quantum/oecc.yml","source_file_modification_token":1687727505568.6487}},"2t_qutrit":{"code_id":"2t_qutrit","physical":"oscillators","logical":"qubits","name":"2T-qutrit code","introduced":"\\cite{arxiv:2210.16188}","description":"Two-mode qutrit code constructed out of superpositions of coherent states whose amplitudes make up the binary tetrahedral group \\(2T\\).\nThe codespace is a particular three-dimensional subspace of the 24-dimensional two-mode coherent-state subspace,\n\\begin{align}\n  \\mathrm{Span}( \\{|\\sqrt{2} e^{i (2k+1) \\pi/4} \\alpha\\rangle |0\\rangle,  |0\\rangle |\\sqrt{2} e^{i (2k+1) \\pi/4} \\alpha\\rangle, |e^{i k\\pi/2} \\alpha\\rangle |e^{i \\ell \\pi/2} \\alpha\\rangle \\: : \\: 0\\leq  k, \\ell \\leq 3\\})\n\\end{align}\nfor any \\(\\alpha \\geq 0\\).\nA basis can be constructed whose elements are equal superpositions of coherent states whose amplitudes make up cosets of the quaternion subgroup \\(Q\\) in \\(2T\\).\n\\begin{figure}\n  \\includegraphics{2t_qutrit.svg}\n  \\caption{Projection of the \\( 4\\{3\\}4 \\) polytope with logical constellations marked in different colours.}\n  \\label{figure:2t_qutrit}\n\\end{figure}\n","features":{"general_gates":["Logical phase-flip can be implemented using an excitation-preserving Gaussian transformation. Degree-four polynomial in the lowering operators of the two modes serves as a non-unitary logical bit-flip. Rotations of either mode by \\(\\pi/4\\) are logical gates that swap two logical codewords."]},"relations":{"parents":[{"code_id":"qsc","detail":"The \\(2T\\)-qutrit is a QSC on the two-dimensional complex sphere whose code constellation is the \\(4\\{3\\}4\\) complex polytope."}],"cousins":[{"code_id":"chuang-leung-yamamoto","detail":"The \\(2T\\)-qutrit code reduces to the two-mode \"0-2-4\" CLY code as \\(\\alpha\\to 0\\)."}]},"_meta":{"changelog":[{"user_id":"ShubhamPJain","date":"2023-03-01"},{"user_id":"VictorVAlbert","date":"2022-10-31"}]},"_zoodb":{"id":"2t_qutrit","source_file_path":"codes/quantum/oscillators/coherent_state/2t_qutrit/2t_qutrit.yml","source_file_modification_token":1687727505570.8474}},"cat":{"code_id":"cat","physical":"oscillators","logical":"qubits","name":"Cat code","introduced":"\\cite{arXiv:1207.0679}","description":"Rotation-symmetric bosonic Fock-state code encoding a \\(q\\)-dimensional qudit into one oscillator which utilizes a constellation of \\(q(S+1)\\) coherent states distributed equidistantly around a circle in phase space of radius \\(\\alpha\\).\n\nCodewords for a qubit code (\\(q=2\\)) consist of a coherent state \\(|\\alpha\\rangle\\) projected onto a subspace of Fock state number modulo \\(2(S+1)\\). The logical state \\(|\\overline{0}\\rangle\\) is in the \\(\\{|0\\rangle , |2(S+1)\\rangle , |4(S+1)\\rangle \\cdots \\}\\) Fock-state subspace, while \\(|\\overline{1}\\rangle\\) is in the \\(\\{|(S+1)\\rangle, |3(S+1)\\rangle , |5(S+1)\\rangle , |7(S+1)\\rangle \\cdots \\}\\) subspace.\n","protection":"Due to the spacing between sets of Fock states, the distance between two distinct logical states is \\(d=S+1\\). Hence, this code is able to detect \\(S\\)-photon loss error.","features":{"encoders":["Lindbladian-based dissipative encoding utilizing multi-photon generalization of two-photon absorption \\cite{doi:10.1103/PhysRevLett.60.1836,doi:10.1103/PhysRevA.50.4330,doi:10.1103/PhysRevA.49.490,doi:10.1103/PhysRevA.49.2785}. Encoding passively protects against modal dephasing, suppressing dephasing noise exponentially with \\(|\\alpha|^2\\) \\cite{arXiv:1312.2017}.","Approximate can states can be prepared using Gaussian operations and photon detectors \\cite{arxiv:1902.02323}."],"general_gates":["Holonomic gates utilizing the Berry phase of coherent states are universal \\cite{arxiv:1503.00194}.","Universal gates in the microwave setting for the \\(S=1\\) code can be performed using squeezing operators and a rotation based on the Kerr nonlinearity \\cite{arXiv:1312.2017}.","Error-detecting \\(CCZ\\) and \\(cSWAP\\) gates for four-component cat code using three-level ancilla \\cite{arxiv:2212.11196}."],"decoders":["Measuring the Fock-state number modulo \\(2S\\) can be used to determine if photon loss or excitation errors occurred. For \\(S=1\\), this is the occupation number parity."]},"realizations":["Parity-syndrome measurement tested \\cite{arxiv:1311.2534} and implemented for the four-component (\\(S=1\\)) cat code \\cite{arXiv:1602.04768} in a microwave cavity coupled to a superconducting circuit. The latter work \\cite{arXiv:1602.04768} is the first to reach break-even error-correction, where the lifetime of a logical qubit is on par with the cavity lifetime, despite protection against dephasing not being implemented. A fault-tolerant version of parity measurement has also been realized \\cite{arxiv:1803.00102}."],"relations":{"parents":[{"code_id":"qsc","detail":"Cat codes are QSCs on the one-dimensional complex sphere."},{"code_id":"bosonic_rotation","detail":"The cat code is a bosonic rotation code whose primitive state is the coherent state \\(|\\alpha\\rangle\\) \\cite{arxiv:1901.08071}."}],"cousins":[{"code_id":"number_phase","detail":"In the limit as \\(N,S \\to \\infty\\), phase measurement in the cat code has vanishing variance, just like in a number-phase code \\cite{arxiv:1901.08071}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-06"},{"user_id":"VictorVAlbert","date":"2022-07-03"},{"user_id":"AlexanderGrimm","date":"2022-07-03"},{"user_id":"VictorVAlbert","date":"2022-01-11"},{"user_id":"JosephTIosue","date":"2021-12-19"},{"user_id":"YijiaXu","date":"2021-12-14"}]},"_zoodb":{"id":"cat","source_file_path":"codes/quantum/oscillators/coherent_state/cat.yml","source_file_modification_token":1687727505570.9287}},"clifford_group":{"code_id":"clifford_group","physical":"oscillators","logical":"qubits","name":"Clifford subgroup-orbit QSC","introduced":"\\cite{arxiv:2302.11593}","description":"A \\(((2^r,2,2-\\sqrt{2},8))\\) QSC for \\(r \\geq 2\\) constructed using the real-Clifford subgroup-orbit code.\nLogical constellations are constructed by applying elements of an index-two subgroup of the real Clifford group, when taken as a subgroup of the orthogonal group \\cite{arxiv:math/0001038} to \\(2\\) different vectors on the complex sphere.\nThe code is known as the \\textit{Witting code} for \\(r=2\\) because its two logical constellations form vertices of Witting polytopes.\n","relations":{"parents":[{"code_id":"qsc"}],"cousins":[{"code_id":"sidelnikov","detail":"Clifford group-orbit QSCs are quantum analogues of real Clifford subgroup-orbit codes."},{"code_id":"witting_polytope","detail":"Logical constellations of the Clifford subgroup-orbit code for \\(r=2\\) form vertices of Witting polytopes."},{"code_id":"24cell","detail":"Logical constellations of the Clifford subgroup-orbit code for \\(r=1\\) form vertices of 24-cells when mapped into the real sphere, while code constellations form vertices of a disphenoidal 288-cell."},{"code_id":"disphenoidal288cell","detail":"Logical constellations of the Clifford subgroup-orbit code for \\(r=1\\) form vertices of 24-cells when mapped into the real sphere, while code constellations form vertices of a disphenoidal 288-cell."}]},"_meta":{"changelog":[{"user_id":"ShubhamPJain","date":"2023-04-15"}]},"_zoodb":{"id":"clifford_group","source_file_path":"codes/quantum/oscillators/coherent_state/clifford_group.yml","source_file_modification_token":1687727505570.9905}},"coherent_constellation":{"code_id":"coherent_constellation","physical":"oscillators","logical":"qubits","name":"Coherent-state constellation code","description":"Qudit-into-oscillator code whose codewords can succinctly be expressed as superpositions of a countable set of coherent states that is called a \\textit{constellation}. Some useful constellations form a group (see \\hyperref[code:gkp]{gkp}, \\hyperref[code:cat]{cat} or \\hyperref[code:2t_qutrit]{\\(2T\\)-qutrit} codes) while others make up a Gaussian quadrature rule \\cite{arxiv:1603.05970,doi:10.1109/ISIT.2016.7541749}.\n","features":{"rate":"Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the Gaussian coherent information of the thermal noise channel \\cite{arxiv:1603.05970,doi:10.1109/ISIT.2016.7541749}."},"relations":{"parents":[{"code_id":"oscillators"}],"cousins":[{"code_id":"quantum_polar","detail":"Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the Gaussian coherent information of the thermal noise channel \\cite{arxiv:1603.05970,doi:10.1109/ISIT.2016.7541749}."},{"code_id":"quantum_concatenated","detail":"Coherent-state constellation codes consisting of points from a Gaussian quadrature rule can be concatenated with quantum polar codes to achieve the Gaussian coherent information of the thermal noise channel \\cite{arxiv:1603.05970,doi:10.1109/ISIT.2016.7541749}."},{"code_id":"modulation","detail":"Coherent-state constellation codes are quantum versions of modulation schemes in that their codewords are superpositions of points in a constellation. Additionally, analog codes that achieve AGWN capacity \\cite{doi:10.1109/ALLERTON.2010.5706965} can be used to develop capacity-achieving concatenations of coherent-state constellation codes with quantum polar codes \\cite{arxiv:1603.05970,doi:10.1109/ISIT.2016.7541749}."}]},"_meta":{"changelog":[{"user_id":"ArminGerami","date":"2023-02-22"},{"user_id":"VictorVAlbert","date":"2023-02-22"},{"user_id":"VictorVAlbert","date":"2022-10-31"}]},"_zoodb":{"id":"coherent_constellation","source_file_path":"codes/quantum/oscillators/coherent_state/coherent_constellation.yml","source_file_modification_token":1687727505571.0532}},"hessian_qsc":{"code_id":"hessian_qsc","physical":"oscillators","logical":"qubits","name":"Hessian QSC","introduced":"\\cite{arxiv:2302.11593}","description":"Quantum spherical code encoding a logical qubit, with each codeword an equal superposition of vertices of a Hessian complex polyhedron.\nFor the unit sphere, the codewords are\n\\begin{align}\n  |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{27}}\\left( \\sum_{\\mu,\\nu=0}^{2} |0,\\omega^{\\mu},-\\omega^{\\nu}\\rangle + |-\\omega^{\\nu},0,\\omega^{\\mu}\\rangle + |\\omega^{\\mu},-\\omega^{\\nu},0\\rangle   \\right) \\\\\n  |\\overline{1}\\rangle &= \\frac{1}{\\sqrt{27}}\\left( \\sum_{\\mu,\\nu=0}^{2} |0,-\\omega^{\\mu},\\omega^{\\nu}\\rangle + |\\omega^{\\nu},0,-\\omega^{\\mu}\\rangle + |-\\omega^{\\mu},\\omega^{\\nu},0\\rangle   \\right)~,\n\\end{align}\nwhere \\(\\omega = e^{\\frac{2\\pi i}{3}}\\).\n\\begin{figure}\n  \\includegraphics{hessian_qsc.svg}\n  \\caption{Projection of the \\textit{double Hessian} code constellation with each copy of the \\textit{Hessian} logical constellation marked in a different colour.}\n  \\label{figure:hessian_qsc}\n\\end{figure}\n","protection":"The Hessian QSC is a \\(\\langle 4, 5, 9 \\rangle\\) code, i.e. it detects 8 photon losses and protects against 3. The code also detects up to 4 ladder errors (losses or gains). The code resolution \\( d_E = 1.0\\).","relations":{"parents":[{"code_id":"qsc","detail":"The Hessian QSC is an example of a QSC with logical constellation built from the Hessian complex polyhedron."}],"cousins":[{"code_id":"hessian_polyhedron","detail":"The Hessian QSC is the quantum generalization of the classical Hessian polyhedron code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-09"},{"user_id":"ShubhamPJain","date":"2023-04-08"}]},"_zoodb":{"id":"hessian_qsc","source_file_path":"codes/quantum/oscillators/coherent_state/hessian_qsc/hessian_qsc.yml","source_file_modification_token":1687727505571.7605}},"qsc":{"code_id":"qsc","physical":"oscillators","logical":"qubits","name":"Quantum spherical code (QSC)","short_name":"QSC","introduced":"\\cite{arxiv:2302.11593}","description":"Code whose codewords are superpositions of points on an \\(n\\)-dimensional real or complex sphere.\nSuch codes can in principle be defined on any configuration space housing a sphere, but the focus of this entry is on QSCs constructed out of coherent-state constellations.\n\nMore technically, a QSC is a collection \\(\\{\\mathcal{C}_k\\}_{k=1}^K\\) of \\textit{codeword constellations}, each of which yields a codeword by taking a quantum superposition of all points \\(\\mathbf{x}\\in \\mathcal{C}_k\\).\nTaken together, the codeword constellations yield the \\textit{code constellation}, \\(\\mathcal{C}=\\bigcup_{k=1}^{K}\\mathcal{C}_{k}\\).\n\nCodewords of coherent-state QSCs of uniform superposition are defined as\n\\begin{align}\n  |\\mathcal{C}_{k}\\rangle\\sim\\frac{1}{\\sqrt{|{\\mathcal{C}}_{k}|}}\\sum_{\\boldsymbol{\\alpha}\\in\\mathcal{C}_{k}}|\\sqrt{\\bar{N}}\\boldsymbol{\\alpha}\\rangle~,\n\\end{align}\nwhere \\( |\\boldsymbol{\\alpha} \\rangle = |\\alpha_1,\\alpha_2,...\\alpha_n \\rangle \\) is an \\(n\\)-mode coherent state.\nThis expression is valid in the limit of large energy \\(\\bar{N}\\to\\infty\\).\n\nCoherent-state QSCs on \\(n\\) modes are denoted by\n\\(((n,K,d_E,\\langle t_{\\downarrow},d_{\\updownarrow},d_{\\downarrow}\\rangle))\\),\nwhere \\(K\\) is codespace dimension, \\(d_E\\) is the \\textit{squared minimum distance}, i.e., the smallest Euclidean distance between pairs of distinct points across all codewords, and \\( t_{\\downarrow},d_{\\updownarrow},d_{\\downarrow} \\) are the number of \\textit{correctable} losses (plus 1), the degree distance, and the number of \\textit{detectable} losses (plus 1), respectively.\n","protection":"The \\textit{resolution} \\(d_E\\) of the code is defined as\n  \\begin{align}\n    d_E = \\min_{\\boldsymbol{\\alpha},\\boldsymbol{\\beta}\\in\\mathcal{C}} \\Vert\\boldsymbol{\\alpha}-\\boldsymbol{\\beta}\\Vert^2~.\n  \\end{align}\nThe code protects against passive Gaussian transformations, which manifest as rotations on the sphere, \\( |\\boldsymbol{\\alpha}\\rangle \\rightarrow |\\mathbf{R}\\boldsymbol{\\alpha}\\rangle \\) for all \\(\\mathbf{R}\\).\nDetectable transformations corresponds to rotations for which\n  \\begin{align}\n    \\Vert \\mathbf{R}\\boldsymbol{\\alpha} - \\boldsymbol{\\alpha}\\Vert^2 < d_E~,\n  \\end{align}\nin the large \\(\\bar{N}\\) limit.\n\nThe code also protects against general ladder errors, which are defined as\n\\begin{align}\n  L_{\\mathbf{p},\\mathbf{q}}(\\mathbf{a}^{\\dagger},\\mathbf{a})=\\prod_{j=1}^{n}a_{j}^{\\dagger p_{j}}a_{j}^{q_{j}}~.\n\\end{align}\nAny pure-loss ladder error \\(L_{\\mathbf{p}=\\boldsymbol{0},\\mathbf{q}}\\) with \\(|\\mathbf{q}|<d_{\\downarrow}\\) is detectable.\nAny ladder error \\(L_{\\mathbf{p},\\mathbf{q}}\\) with \\(|\\mathbf{p}|,|\\mathbf{q}|<t_{\\downarrow}\\) is detectable, implying that up to \\(t_{\\downarrow}-1\\) losses are correctable.\nAny ladder error with degree \\(|\\mathbf{p}+\\mathbf{q}|<d_{\\updownarrow}\\) is detectable.\n","relations":{"parents":[{"code_id":"coherent_constellation","detail":"Coherent-state QSCs are coherent-state constellation codes constrained to lie on a sphere."}],"cousins":[{"code_id":"points_into_spheres","detail":"QSCs are quantum analogues of spherical and constant-energy codes because they store information in quantum superpositions of points on a sphere in quantum phase space."},{"code_id":"spherical","detail":"QSCs are quantum analogues of spherical and constant-energy codes because they store information in quantum superpositions of points on a sphere in quantum phase space."},{"code_id":"single_spin","detail":"Single-spin codes whose codewords are expressed in terms of discrete sets of spin-coherent states may also be interpreted as QSCs."},{"code_id":"paircat","detail":"Pair-cat codes are QSCs embedded into the configuration space of pair-coherent states."},{"code_id":"qubit_css","detail":"CSS codes concatenated with two-component cat codes form QSCs which have a weight-based notion of distance."},{"code_id":"quantum_concatenated","detail":"CSS codes concatenated with two-component cat codes form QSCs which have a weight-based notion of distance."},{"code_id":"two-legged-cat","detail":"CSS codes concatenated with two-component cat codes form QSCs which have a weight-based notion of distance."}]},"_meta":{"changelog":[{"user_id":"ShubhamPJain","date":"2023-02-23"},{"user_id":"VictorVAlbert","date":"2023-02-23"}]},"_zoodb":{"id":"qsc","source_file_path":"codes/quantum/oscillators/coherent_state/qsc.yml","source_file_modification_token":1687727505571.8696}},"rg_cat":{"code_id":"rg_cat","physical":"oscillators","logical":"qubits","name":"Renormalization group (RG) cat code","short_name":"RG cat","introduced":"\\cite{arxiv:2012.14001,arXiv:2112.05099}","description":"Code whose codespace is spanned by \\(q\\) field-theoretic coherent states which are flowing under the renormalization group (RG) flow of massive free fields. The code approximately protects against displacements that represent local (i.e., short-distance, ultraviolet, or UV) operators. Intuitively, this is because RG cat codewords represent non-local (i.e., long-distance) degrees of freedom, which should only be excitable by acting on a macroscopically large number of short-distance degrees of freedom.\n","protection":"Approximately protects against displacements that represent ultraviolet coherent operators, i.e., short-distance degrees of freedom of the field theory.\n","relations":{"parents":[{"code_id":"coherent_constellation"}],"cousins":[{"code_id":"approximate_qecc","detail":"RG cat codes approximately protect against displacements that represent ultraviolet coherent operators."},{"code_id":"holographic","detail":"The RG cat code encoder has similar coarse-graining features as that of a holographic code \\cite{arxiv:2012.14001}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-29"}]},"_zoodb":{"id":"rg_cat","source_file_path":"codes/quantum/oscillators/coherent_state/rg_cat.yml","source_file_modification_token":1687727505571.9321}},"two-legged-cat":{"code_id":"two-legged-cat","physical":"oscillators","logical":"qubits","name":"Two-component cat code","introduced":"\\cite{arXiv:quant-ph/9809037}","description":"Code whose codespace is spanned by two coherent states \\(\\left|\\pm\\alpha\\right\\rangle\\) for nonzero complex \\(\\alpha\\). An orthonormal basis for the codespace consists of the bosonic \\textit{cat states}\n\\begin{align}\n  |\\overline{\\pm}\\rangle=\\frac{\\left|\\alpha\\right\\rangle \\pm\\left|-\\alpha\\right\\rangle }{\\sqrt{2\\left(1\\pm e^{-2|\\alpha|^{2}}\\right)}}\n\\end{align}\nfor any complex \\(\\alpha\\).\n\nA closely related approximate cat code is called \\textit{T4C code} \\cite{arxiv:2004.09322}.\n","protection":"Two-legged cat codes for large \\(\\alpha\\) provide protection against modal dephasing, i.e., diffusion of the angular degree of freedom of the mode. They do not protect against photon loss events, but there exist modifications based on sign alternation \\cite{arXiv:1901.05358}, squeezing \\cite{arXiv:2201.02570,arxiv:2210.13406,arxiv:2210.13359}, and detuning \\cite{arxiv:2211.03689} that can add such protection.","features":{"encoders":["Lindbladian-based dissipative encoding \\cite{arXiv:1312.2017} utilizing two-photon absorption \\cite{doi:10.1103/PhysRevLett.60.1836,doi:10.1103/PhysRevA.50.4330,doi:10.1103/PhysRevA.49.490,doi:10.1103/PhysRevA.49.2785}. Encoding passively protects against cavity dephasing, suppressing dephasing noise exponentially with \\(|\\alpha|^2\\) \\cite{arXiv:1312.2017}.","Hamiltonian-based 'Kerr-cat' encoding utilizing the Kerr-effect Hamiltonian \\cite{arXiv:1605.09408} (see also Ref. \\cite{arxiv:1510.02566}).","Colored dissipation \\cite{arxiv:2107.09198}.","Combined dissipative and Hamiltonian-based encoding utilizing two-photon exchange with an ancillary qubit \\cite{arXiv:2112.05545}.","Critical encoding at non-zero detuning \\cite{arxiv:2208.04928}."],"general_gates":["Universal gates in the quantum optical setting can be performed using teleportation, Bell measurements, displacements, and rotations \\cite{arXiv:quant-ph/0306004}. An earlier protocol requires a non-linear interaction and uses state teleportation \\cite{arxiv:quant-ph/0109077}.","Universal gates in the microwave setting can be performed using displacement operators and a rotation based on the Kerr nonlinearity \\cite{arXiv:1312.2017}. Kerr nonlinearity converts coherent states into Yurke-Stoler states \\cite{doi:10.1103/PhysRevLett.57.13}.","Bias-preserving Hamiltonian-based CNOT gate utilizing an \\(X\\) gate with a topological Berry phase \\cite{arxiv:1904.09474,arXiv:1905.00450}. Bias-preserving SWAP gate \\cite{arxiv:2009.10756}."],"decoders":["All-optical decoder \\cite{arxiv:2108.12225} based on Knill error correction (a.k.a. telecorrection \\cite{arxiv:quant-ph/0601066}), which is based on teleportation \\cite{arxiv:quant-ph/0410199,arXiv:quant-ph/0312190}."],"fault_tolerance":["Fault-tolerant error-correction procedure using small amplitude coherent states \\cite{arxiv:0707.0327}.","Bias-preserving Hamiltonian-based CNOT gate \\cite{arXiv:1905.00450} is part of a universal bias-preserving gate set that can be made fault tolerant using concatenation \\cite{arXiv:1904.09474,arXiv:1905.00450}.","Ancilla qubits encoded in two-component cat codes yield fault-tolerant syndrome extraction circuits \\cite{arxiv:1807.09334}."]},"realizations":["Lindbladian-based \\cite{arXiv:1412.4633,arxiv:1705.02401} and Hamiltonian-based 'Kerr-cat' \\cite{arxiv:1907.12131} encodings have been achieved in superconducting circuit devices by the Devoret group; Ref. \\cite{arxiv:1705.02401} also demonstrated a displacement-based gate. The Lindbladian-based scheme has further achieved a suppression of bit-flip errors that is exponential in the average photon number \\cite{arXiv:1907.11729} up to a bit-flip time of 1ms. A bit-flip time of 1s has been achieved in a similar system in the classical bit regime \\cite{arxiv:2204.09128}.","T4C code realized in a superconducting circuit device by the Wang group \\cite{arxiv:2004.09322}."],"notes":["Pedagogical introduction to cat codes in the context of microwave cavities can be found in Refs. \\cite{arXiv:2203.03222,manual:{Shruti Puri, \\href{https://physinfo.fr/houches2019/files/Puri_v1.pdf}{QEC when the noise is biased}, 2019.}}, and in the context of optical systems in books \\cite{doi:10.1093/acprof:oso/9780198509141.001.0001,doi:10.1142/9781860948169_0009,doi:10.1002/9783527695805}."],"relations":{"parents":[{"code_id":"cat","detail":"The cat code reduces to its two-component version for \\(S=0\\)."}],"cousins":[{"code_id":"hamiltonian","detail":"The two-legged cat code forms the ground-state subspace of a Kerr Hamiltonian \\cite{arXiv:1605.09408}."},{"code_id":"quantum_repetition","detail":"Two-legged cat and quantum repetition codes can be thought of as classical codes because they protect against only one type of noise. Two-legged cat codes (quantum repetition) codes suppress cavity dephasing (bit-flip) noise exponentially with \\(|\\alpha|^2\\) (\\(n\\)). The stability offered by cat codes has been linked to several favorable properties of phases of matter associated with the repetition-code Hamiltonian \\cite{arxiv:1804.11293,arxiv:2008.02816}."},{"code_id":"coherent_state_c-q","detail":"Two-component cat codes can be thought of as coherent-state c-q codes because they protect against only one type of noise and thus only reliably store classical information."},{"code_id":"self_correct","detail":"A concatenation of the repetition code with the two-component cat code is a candidate for a memory that may be self-correcting, but only in the limit of infinite energy per mode \\cite{arxiv:2205.09767}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-06"},{"user_id":"HyunseokJeong","date":"2022-11-06"}]},"_zoodb":{"id":"two-legged-cat","source_file_path":"codes/quantum/oscillators/coherent_state/two-legged-cat.yml","source_file_modification_token":1689550329216.3943}},"chi2":{"code_id":"chi2","physical":"oscillators","logical":"qudits","name":"\\(\\chi^{(2)}\\) code","introduced":"\\cite{arXiv:1709.05302}","description":"A \\(3n\\)-mode bosonic Fock-state code that requires only linear optics and the \\(\\chi^{(2)}\\) optical nonlinear interaction for encoding, decoding, and logical gates.\nCodewords lie in Fock-state subspaces that are invariant under Hermitian combinations of the \\(\\chi^{(2)}\\) nonlinearities \\(abc^\\dagger\\) and \\(i abc^\\dagger\\), where \\(a\\), \\(b\\), and \\(c\\) are lowering operators acting on one of the \\(n\\) triples of modes on which the codes are defined.\nCodewords are also \\(+1\\) eigenstates of stabilizer-like \\textit{symmetry operators}, and photon parities are error syndromes.\n","protection":"Codes protect against loss, gain, and dephasing errors conditional on the knowledge of the total number of photons lost.","features":{"encoders":["Linear optics and \\(\\chi^{(2)}\\) interactions."],"decoders":["Linear optics and \\(\\chi^{(2)}\\) interactions."],"general_gates":["Linear optics and \\(\\chi^{(2)}\\) interactions yield a universal set of gates."]},"relations":{"parents":[{"code_id":"fock_state"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-10"}]},"_zoodb":{"id":"chi2","source_file_path":"codes/quantum/oscillators/fock_state/chi2.yml","source_file_modification_token":1673511200349.12}},"chuang-leung-yamamoto":{"code_id":"chuang-leung-yamamoto","physical":"oscillators","logical":"qubits","name":"Chuang-Leung-Yamamoto (CLY) code","introduced":"\\cite{doi:10.1103/PhysRevA.56.1114}","description":"Bosonic Fock-state code that encodes \\(k\\) qubits into \\(n\\) oscillators, with each oscillator restricted to having at most \\(N\\) excitations. Codewords are superpositions of oscillator Fock states which have exactly \\(N\\) total excitations, and are either uniform (i.e., balanced) superpositions or unbalanced superpositions. Codes can be denoted as \\([[N,n,2^k,d]]\\), which conflicts with \\hyperref[code:stabilizer]{stabilizer code} notation.\n\nA simple example of a CLY code is a two-mode \"0-2-4\" qubit code with codewords\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{2}}\\left(|40\\rangle+|04\\rangle\\right)\\\\\n  |\\overline{1}\\rangle&=|22\\rangle~.\n\\end{split}\n\\end{align}\n","protection":"Protects against amplitude damping for up to \\(t = d-1\\) excitation losses. Defining the \\textit{spacing} between two Fock states \\(|u_1\\cdots u_n\\rangle\\) and \\(|v_1\\cdots v_n\\rangle\\),\n\\begin{align}\n\\text{Spacing}(u,v) = \\frac{1}{2}\\sum_{i=1}^n |u_i - v_i|,\n\\end{align}\nthe code distance \\(d\\) can be defined as the minimial spacing between Fock states making up the codewords.\n","features":{"rate":"Code rate is \\(\\frac{k}{n \\log_2(N+1)}\\). To correct the loss of up to \\(t\\) excitations with \\(K+1\\) codewords, a code exists with scaling \\(N \\sim t^3 K/2\\).","encoders":["Photon Fock state input into a network of beamsplitters, phase shifters, and Kerr media. These operations all preserve total photon number. Beamsplitters and phase shifters take annihilation operators to linear combinations of annihilation operators, and the transformation matrix is unitary. The operations corresponding to Kerr nonlinear media are diagonal in the Fock basis, but they implement phases that in general depend nonlinearly on the number of photons in each mode. State preparation may require ancillary modes and be conditioned on photon-number measurement results."],"decoders":["Destructive decoding with a photon number measurement on each mode.","State can be decoded with a network of beamsplitters, phase shifters, and Kerr media."]},"relations":{"parents":[{"code_id":"fock_state","detail":"Chuang-Leung-Yamamoto code are multi-mode Fock-state codes."},{"code_id":"constant_excitation","detail":"Chuang-Leung-Yamamoto codewords are constructed out of Fock states with the same total excitation number."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-02"},{"user_id":"DhruvDevulapalli","date":"2021-12-17"},{"user_id":"JonathanKunjummen","date":"2021-12-07"}]},"_zoodb":{"id":"chuang-leung-yamamoto","source_file_path":"codes/quantum/oscillators/fock_state/constant_excitation/chuang-leung-yamamoto.yml","source_file_modification_token":1678631058733.6614}},"constant_excitation_permutation_invariant":{"code_id":"constant_excitation_permutation_invariant","physical":"oscillators","name":"Ouyang-Chao constant-excitation permutation-invariant code","short_name":"Ouyang-Chao","introduced":"\\cite{arXiv:1809.09801}","description":"Stub.\n","relations":{"parents":[{"code_id":"fock_state"},{"code_id":"permutation_invariant"},{"code_id":"constant_excitation"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-01"}]},"_zoodb":{"id":"constant_excitation_permutation_invariant","source_file_path":"codes/quantum/oscillators/fock_state/constant_excitation/constant_excitation_permutation_invariant.yml","source_file_modification_token":1678631058733.7222}},"dual_rail":{"code_id":"dual_rail","physical":"oscillators","logical":"qubits","name":"Dual-rail quantum code","introduced":"\\cite{doi:10.1103/PhysRevA.52.3489}","description":"Two-mode code encoding a logical qubit in Fock states with one excitation. The logical-zero state is represented by \\(|01\\rangle\\), while the logical-one state is represented by \\(|10\\rangle\\). The two modes of the encoding can represent temporal or spatial modes, corresponding to a \\textit{time-bin} or \\textit{frequency-bin} encoding.","protection":"This is an error-detecting code against one photon loss event; it is often used in photonic quantum devices because of its ease of realization. A single loss event can be detected because, after the loss occurs, the output state \\(|00\\rangle\\) is orthogonal to the codespace. Recovery is not possible, so a successful run of a quantum circuit is conditioned on not losing a photon during the circuit.\n\nFor Deutsch''s  problem specifically, this code protects against errors resulting in states that have the correct photon number, but in the wrong modes \\cite{doi:10.1103/PhysRevA.52.3489}.\n","features":{"general_gates":["General gates are performed using beamsplitters and Kerr non-linearities. Universal quantum computing can be achieved with photons in dual-rail encodings using the KLM protocol \\cite{doi:10.1038/35051009} with only linear optical elements and photon detectors.","Error-detecting \\(CCZ\\) and \\(cSWAP\\) gates using three-level ancilla \\cite{arxiv:2212.11196}."],"fault_tolerance":["Dual-rail qubits can be used to convert leakage and amplitude damping noise into erasure noise \\cite{arxiv:2208.05461}."]},"realizations":["The dual-rail code is ubiquitous in linear optical quantum devices \\cite{arxiv:quant-ph/0512071}.","Superconducting circuit devices: error detection has been demonstrated by Quantum Circuits Inc. \\cite{arxiv:2307.03169}, following an earlier theoretical proposal \\cite{arxiv:2212.12077}."],"notes":["For Deutsch's problem \\cite{doi:10.1098/rspa.1992.0167} with optical qubits, error correction using photon number detection reduces the error probability from \\(\\frac{1}{4} (1+e^{-\\gamma}-2e^{-3\\gamma/2}) \\)   to \\(\\frac{1}{2} (1- \\text{sech} \\gamma/2)\\).","See review \\cite{arxiv:quant-ph/0512071} for more details."],"relations":{"parents":[{"code_id":"one_hot_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-18"},{"user_id":"DhruvDevulapalli","date":"2021-12-17"}]},"_zoodb":{"id":"dual_rail","source_file_path":"codes/quantum/oscillators/fock_state/constant_excitation/dual_rail.yml","source_file_modification_token":1689550329216.5154}},"one_hot_quantum":{"code_id":"one_hot_quantum","physical":"oscillators","logical":"qudits","name":"One-hot quantum code","introduced":"\\cite{arxiv:2302.07357}","description":"Encoding of a \\(q\\)-dimensional qudit into the single-excitation subspace of \\(q\\) modes. The \\(j\\)th logical state is the multi-mode Fock state with one photon in mode \\(j\\) and zero photons in the other modes.\n","protection":"This is an error-detecting code against one photon loss event.\n","features":{"general_gates":["Non-deterministic gates using linear optics and photon-number resolving detectors \\cite{arxiv:2302.07357}."]},"relations":{"parents":[{"code_id":"chuang-leung-yamamoto"},{"code_id":"constant_excitation"},{"code_id":"permutation_invariant"}],"cousins":[{"code_id":"one_hot","detail":"The one-hot quantum code is the quantum version of the one-hot code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-06"}]},"_zoodb":{"id":"one_hot_quantum","source_file_path":"codes/quantum/oscillators/fock_state/constant_excitation/one_hot_quantum.yml","source_file_modification_token":1678631058733.8457}},"very-small-logical-qubit":{"code_id":"very-small-logical-qubit","physical":"oscillators","logical":"qubits","name":"Very small logical qubit (VSLQ) code","short_name":"VSLQ","introduced":"\\cite{arxiv:1510.06117,arxiv:2302.06707}","description":"The two logical codewords are \\(|\\pm\\rangle \\propto (|0\\rangle\\pm|2\\rangle)(|0\\rangle\\pm|2\\rangle)\\), where the total Hilbert space is the tensor product of two transmon qudits (whose ground states \\(|0\\rangle\\) and second excited states \\(|2\\rangle\\) are used in the codewords).\nSince the code is intended to protect against losses, the qutrits can equivalently be thought of as oscillator Fock-state subspaces.\n\nIn the original proposal for autonomous stabilization \\cite{arxiv:1510.06117}, the single logical qubit is given by the two lowest energy states of a time-dependent Hamiltonian acting on two transmon qutrits and two lossy oscillators.\n","protection":"Protects against a single photon loss.","features":{"encoders":["Engineering a circuit made of two transmons and two oscillators coupled through three driven superconducting quantum interference devices (SQUIDs) results in passive stabilization of the logical states."],"general_gates":["Single logical qubit operations implemented by resonant physical qubit driving and phase shifting the SQUID drives.","A CZ gate between two logical qubits implemented by coupling devices through another driven SQUID and applying a pulse to the coupling squid simultaneously with a single qubit operation on one of the logical qubits."],"decoders":["Logical qubit can be measured with physical qubit measurements along \\(X\\). Can be implemented by engineering a coupling of one of the qubits to a readout cavity via the interaction \\(\\sigma_x (a+a^\\dagger)\\) \\cite{doi:10.1103/PhysRevLett.115.203601}. This results in an \\(X\\)-dependent shift of the readout cavity resonance which can be measured.","Star-code autonomous correction scheme \\cite{arxiv:2302.06707}."]},"realizations":["Star-code autonomous correction scheme realized using superconducting circuits \\cite{arxiv:2302.06707}."],"relations":{"parents":[{"code_id":"fock_state"},{"code_id":"constant_excitation"},{"code_id":"permutation_invariant"}],"cousins":[{"code_id":"hybrid_qudit_oscillator","detail":"VSLQ decoder utilizes two ancillary oscillators."},{"code_id":"quantum_repetition","detail":"Parts of the VSLQ codewords resemble the two-qubit phase-flip repetition code, though the code cannot correct phase errors. Unlike the phase-flip code, the VSLQ code can correct for single photon loss because it uses the second excited state in the construction, which remains distinct from the vacuum even after photon loss."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-09"},{"user_id":"JonathanKunjummen","date":"2021-12-07"}]},"_zoodb":{"id":"very-small-logical-qubit","source_file_path":"codes/quantum/oscillators/fock_state/constant_excitation/very-small-logical-qubit.yml","source_file_modification_token":1678631058733.905}},"wasilewski-banaszek":{"code_id":"wasilewski-banaszek","physical":"oscillators","logical":"qubits","name":"Wasilewski-Banaszek code","introduced":"\\cite{arxiv:quant-ph/0702075}","description":"Three-oscillator Fock-state code encoding a single logical qubit using codewords \\begin{align} \\begin{split} |\\overline{0}\\rangle &= \\frac{1}{\\sqrt{3}}(|003\\rangle+|030\\rangle+|300\\rangle)\\\\ |\\overline{1}\\rangle &= |111\\rangle \\end{split}. \\end{align}","protection":"Protects against single photon loss in any one mode.","features":{"encoders":["A qubit in the dual-rail code can be transferred to this code via a linear optical network using four ancillary modes, each with one photon input. Successful encoding is conditioned on measuring the state \\(|110\\rangle\\) on the last three modes."],"general_gates":["Single-qubit gates implemented using linear optical networks, sometimes with the addition of auxiliary modes with vacuum input and (conditional) output."],"decoders":["Destructive measurement with photon number measurements on each mode."]},"relations":{"parents":[{"code_id":"constant_excitation_permutation_invariant","detail":"The Wasilewski-Banaszek code is a simple example of an Ouyang-Chao code \\cite{arXiv:1809.09801}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-09"},{"user_id":"JonathanKunjummen","date":"2021-12-07"}]},"_zoodb":{"id":"wasilewski-banaszek","source_file_path":"codes/quantum/oscillators/fock_state/constant_excitation/wasilewski-banaszek.yml","source_file_modification_token":1678631058733.963}},"fock_state":{"code_id":"fock_state","physical":"oscillators","logical":"qudits","name":"Fock-state bosonic code","description":"Qudit-into-oscillator code whose protection against amplitude damping (i.e., photon loss) stems from the use of disjoint sets of Fock states for the construction of each code basis state. The simplest example is the dual-rail code, which has codewords consisting of single Fock states \\(|10\\rangle\\) and \\(|01\\rangle\\). This code can detect a single loss error since a loss operator in either mode maps one of the codewords to a different Fock state \\(|00\\rangle\\). More involved codewords consist of several well-separated Fock states such that multiple loss events can be detected and corrected.","protection":"Code distance \\(d\\) is the minimum distance (assuming some metric) between any two labels of Fock states corresponding to different code basis states. For a single mode, \\(d\\) is the minimum absolute value of the difference between any two Fock-state labels; such codes can detect up to \\(d-1\\) loss events. Multimode distances can be defined analogously; see, e.g., \\hyperref[code:chuang-leung-yamamoto]{Chuang-Leung-Yamamoto codes}. There are tradeoffs in how well a Fock-state code protects against loss/gain errors and dephasing noise \\cite{arxiv:2008.12576}.","relations":{"parents":[{"code_id":"qudits_into_oscillators"}],"cousins":[{"code_id":"bits_into_bits","detail":"Fock-state code distance is a natural extension of Hamming distance between binary strings."},{"code_id":"qubits_into_qubits","detail":"Fock-state code whose codewords are finite superpositions of Fock states with maximum occupation \\(N\\) can be mapped into a qubit code with \\(n\\geq\\log_2 N\\) by performing a binary expansion of the Fock-state labels \\(n\\) and treating each binary digit as an index for a qubit state. Pauli operators for the constituent qubits can be expressed in terms of bosonic raising and lowering operators \\cite{manual:{Victor V. Albert, private communication, 2016}}. However, noise models for the two code families induce different notions of locality and thus qualitatively different physical interpretations \\cite{arxiv:2111.08894}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-30"}]},"_zoodb":{"id":"fock_state","source_file_path":"codes/quantum/oscillators/fock_state/fock_state.yml","source_file_modification_token":1678631058734.046}},"matrix_qm":{"code_id":"matrix_qm","physical":"oscillators","logical":"qudits","name":"Matrix-model code","introduced":"\\cite{arxiv:2211.08448}","description":"Multimode-mode Fock-state bosonic approximate code derived from a matrix model, i.e., a nonabelian bosonic gauge theory with a large gauge group.\nThe model's degrees of freedom are matrix-valued bosons \\(a\\), each consisting of \\(N^2\\) harmonic oscillator modes and subject to an \\(SU(N)\\) gauge symmetry.\n\nA simple matrix-model code consists of two spatially separated bosons with codewords\n\\begin{align}\n    |\\mathcal{I}\\rangle :=\\prod_{(m,n)\\in \\mathcal{I} } \\frac{\\text{Tr}(a_1^{\\dagger m}a_2^{\\dagger n})}{N^{\\frac{m+n}{2}}}|0\\rangle_{12}~,\n\\end{align}\nwhere \\(\\cal I\\) is some set of integer two-tuples, and \\(n,m\\geq 0\\).\n\nGauge symmetry is assumed to be enforced in the above model.\nIn other variants, gauge symmetry is enforced energetically, requiring a parameter to scale as \\(\\log(N)\\) for polynomial memory lifetime. This translates to the bath coupling being suppressed as \\(1/N\\).\n","protection":"For the spatially separated boson code, logical errors stemming from gauge-invariant physical errors are suppressed polynomially with the number of modes \\(N\\), as shown per the error-correction conditions.\nMemory time scales as \\(N^2\\) when the model is subject to a thermal bath.\n","relations":{"parents":[{"code_id":"fock_state","detail":"Matrix-model logical states are lie in a low-energy Fock-state subspace."},{"code_id":"approximate_qecc","detail":"Matrix-model codes approximately protect against gauge-invariant errors in the large-mode limit."},{"code_id":"hamiltonian","detail":"Matrix-model codewords for simple codes are eigenstates of a matrix-model Hamiltonian."}],"cousins":[{"code_id":"holographic","detail":"Matrix-model codes are motivated by the Ads/CFT correspondence because it is manifest in continuous nonabelian gauge theories with large gauge groups \\cite{arxiv:2211.08448}."},{"code_id":"self_correct","detail":"Matrix-model codes are similar to self-correcting memories in the sense that memory time becomes infinite in the thermodynamic limit, but with corrections being polynomial in \\(N\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-27"}]},"_zoodb":{"id":"matrix_qm","source_file_path":"codes/quantum/oscillators/fock_state/matrix_qm.yml","source_file_modification_token":1680994436847.4539}},"numopt":{"code_id":"numopt","physical":"oscillators","logical":"qubits","name":"Numerically optimized code","introduced":"\\cite{arXiv:1602.00008,arxiv:1708.05010}","description":"Bosonic Fock-state code obtained from a numerical minimization procedure, e.g., from enforcing error-correction criteria against some number of losses while minimizing average occupation number. Useful single-mode codes can be determined using basic numerical optimization \\cite{arXiv:1602.00008,arxiv:1708.05010}, semidefinite-program recovery/encoding optimization \\cite{arxiv:1801.07271,arxiv:2205.00341}, or reinforcement learning \\cite{arxiv:2108.02766,arxiv:2212.11651}.\n\nThe smallest numerically optimized code protecting against a single loss error is the \\(\\sqrt(17)\\) code \\cite{arxiv:1602.00008},\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{7-\\sqrt{17}}|0\\rangle+\\sqrt{\\sqrt{17}-1}|3\\rangle\\right)\\\\\n|\\overline{1}\\rangle&=\\frac{1}{\\sqrt{6}}\\left(\\sqrt{9-\\sqrt{17}}|1\\rangle-\\sqrt{\\sqrt{17}-3}|4\\rangle\\right)~,\n\\end{split}\n\\end{align}\ncorrecting a single loss error. The average occupation number of the codewords is \\(\\approx 1.6\\), which is \\(0.4\\) photons lower than that of the smallest binomial code with the same level of protection.\n","protection":"Number phase codes protect from a finite number of loss events. However, unlike Fock-state codes, their protection does not stem from a Fock-state spacing.","relations":{"parents":[{"code_id":"oscillators"}],"cousins":[{"code_id":"multimodegkp","detail":"Numerically optimizing GKP code lattices yields codes for three and nine modes with larger distances and fidelities than known GKP codes \\cite{arxiv:2303.04702}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-10"}]},"_zoodb":{"id":"numopt","source_file_path":"codes/quantum/oscillators/fock_state/numopt.yml","source_file_modification_token":1678726895515.8755}},"paircat":{"code_id":"paircat","physical":"oscillators","logical":"qubits","name":"Pair-cat code","introduced":"\\cite{arxiv:1801.05897}","description":"Two- or higher-mode extension of cat codes whose codewords are right eigenstates of powers of products of the modes' lowering operators. Many gadgets for cat codes have two-mode pair-cat analogues, with the advantage being that such gates can be done in parallel with a dissipative error-correction process.\n\nTwo-mode codewords are supported by Fock states with occupation number \\(\\hat{n}_2-\\hat{n}_1\\) fixed to some integer \\(\\Delta\\). In the \\textit{two-component} case, \\(|\\overline{0}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta \\rangle + (-1)^\\Delta |i\\gamma_\\Delta\\rangle\\) and \\(|\\overline{1}_{\\gamma,\\Delta}\\rangle \\sim |\\gamma_\\Delta\\rangle - (-1)^\\Delta |i \\gamma\\rangle\\), where\n\\begin{align}\n|\\alpha_\\Delta \\rangle \\propto \\sum_{n=0}^\\infty \\frac{\\alpha^{2n+\\Delta}}{\\sqrt{n! (n+\\Delta)!}} |n,n+\\Delta\\rangle\n\\end{align}\nis the corresponding pair-coherent state \\cite{doi:10.1007/BF01646483,doi:10.1103/PhysRevLett.57.827,doi:10.1364/JOSAB.5.001940} with complex amplitude \\(\\alpha\\), up to normalization.\n","protection":"The occupation-number differences form the syndromes, as opposed to the photon number parity for the single-mode cat code. Any loss even combination that changes the relative differences of photons between modes is a detectable error. The two-mode two-component paircat code can detect arbitrary single-mode losses, but cannot detect simultaneous photon loss in both modes. An \\(n\\)-mode code can detect any loss errors of at most \\(n-1\\) weight. Higher numbers of legs correspond to more pair-coherent state present in the codewords, and allow for protection against simulataneous losses.","features":{"decoders":["Lindbladian-based dissipative encoding utilizing two-mode two-photon absorption \\cite{doi:10.1103/PhysRevLett.57.827}. Encoding passively protects against cavity dephasing, suppressing dephasing noise exponentially with \\(\\gamma^2\\)."],"general_gates":["Hamiltonian \\(X\\), \\(XX\\), \\(Z\\) gates, holonomic \\(Z\\) gate, control-phase gate.","Bias-preserving gates \\cite{arxiv:2208.06913}."]},"realizations":["Microwave cavities coupled to superconducting circuits by the Wang group \\cite{arxiv:2209.11643}."],"relations":{"parents":[{"code_id":"fock_state"}],"cousins":[{"code_id":"cat","detail":"Cat (pair-cat) codewords are superpositions of coherent (pair-coherent) states. Many cat-code protocols have analogues for the two-mode pair-cat codes."},{"code_id":"hamiltonian","detail":"Two-legged pair-cat codewords form ground-state subspace of a multimode Kerr Hamiltonian."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-16"},{"user_id":"YijiaXu","date":"2022-05-03"}]},"_zoodb":{"id":"paircat","source_file_path":"codes/quantum/oscillators/fock_state/paircat.yml","source_file_modification_token":1678631058734.22}},"binomial":{"code_id":"binomial","physical":"oscillators","logical":"qudits","name":"Binomial code","introduced":"\\cite{arXiv:1602.00008}","description":"Bosonic rotation codes designed to approximately protect against errors consisting of powers of raising and lowering operators up to some maximum power. Binomial codes can be thought of as spin-coherent states embedded into an oscillator \\cite{arXiv:1708.05010}.\n\nA simple example of a binomial code is the \\textit{\"0-2-4\"} qubit code with codewords\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{2}}\\left(|0\\rangle+|4\\rangle\\right)\\\\\n  |\\overline{1}\\rangle&=|2\\rangle~,\n\\end{split}\n\\end{align}\nconstructed out of binomial states \\cite{doi:10.1080/713821735}.\n\nGeneral \\(q\\)-dimensional qudit \\((N, S)\\) binomial codeword states are \\(\\{|\\overline{i}\\rangle\\mid i\\in \\mathbb Z_q \\}\\), where\n  \\begin{align}\n    |\\overline{i}\\rangle = \\frac{1}{\\sqrt{q^N}} \\sum_{\\substack{p=0\\\\p\\equiv i \\pmod{q}}}^{(q-1)(N+1)} \\sqrt{\\binom{N+1}{p}_q} \\ket{p(S+1)}.\n  \\end{align}\n  The set \\( \\ket{i} \\mid i \\in \\mathbb{N}\\) is the set of Fock states. Also, \\(\\binom{N+1}{p}_q\\) are extended binomial coefficients, or polynomial coeffiients, defined recursively as\n  \\begin{align}\n    \\binom{n}{m}_1 \\equiv 1,\\quad \\binom{n}{m}_q \\equiv \\sum_{k=0}^n \\binom{n}{k}\\binom{k}{m-k}_{q-1}.\n  \\end{align}\n  The extended binomial coefficients \\( \\binom{n}{m}_q \\) are also the coefficients of \\( x^m \\) in the polynomial \\( (1 + x + \\cdots + x^{q-1})^n \\).\n","protection":"An \\((N, S)\\) binomial code protects against \\(L\\) boson losses, \\(G\\) boson gains, and dephasing up to \\(\\hat{n}^{D}\\), where \\(S=L+G\\) and \\(N = \\mathrm{max}(L,G,2D)\\).  Binomial codes approximately protect against continuous-time amplitude damping, boson loss and gain, and dephasing.","features":{"general_gates":["Error-detecting \\(CCZ\\) and \\(cSWAP\\) gates for \"0-2-4\" code using three-level ancilla \\cite{arxiv:2212.11196}."],"decoders":["Photon loss and dephasing errors can be detected by measuring the phase-space rotation \\(\\exp\\left(2\\pi\\mathrm{i} \\hat{n} / (S+1)\\right)\\) and the check operator \\(J_x/J\\) in the spin-coherent state language, where \\(J\\) is the total angular momentum and \\(J_x\\) is the angular momentum in the \\(x\\) direction \\cite{arXiv:1708.05010}. This type of error correction fails for errors that are products of photon loss/gain and dephasing errors. However, for certain \\((N,S)\\) instances of the binomial code, detection of these types of errors can be done.","Recovery can be done via projective measurements and unitary operations \\cite{arXiv:1602.00008,arXiv:1708.05010}."]},"realizations":["Microwave cavities coupled to superconducting circuits: state transfer between a binomial codeword to another system \\cite{arxiv:1712.05832}, error-correction protocol nearly reaching break-even \\cite{arxiv:1805.09072}, and a teleported CNOT gate \\cite{arxiv:1810.04690}. A realization of the \"0-2-4\" encoding is the first to go beyond break-even error-correction and yields a logical lifetime that exceeds the cavity lifetime by \\(16\\%\\) \\cite{arxiv:2211.09319} (see also \\cite{arxiv:2211.09116})."],"notes":["The mean occupation number, or average Fock-state number in maximally-mixed state of the code, is \\((N+1)(S+1)(q-1)/2 \\), where \\(q\\) is the qudit dimension."],"relations":{"parents":[{"code_id":"bosonic_rotation","detail":"One can verify by direct calculation that the logical states are eigenstates of the discrete rotation operator. One has freedom in the exact form of the primitive state to choose; see Appendix B.2 of Ref. \\cite{arxiv:1901.08071}."}],"cousins":[{"code_id":"cat","detail":"For a fixed \\(S\\), binomial codes with \\(N \\to \\infty\\) coincide with cat codes as \\(\\alpha \\to \\infty\\) \\cite{arXiv:1602.00008}."},{"code_id":"number_phase","detail":"In the limit as \\(N,S \\to \\infty\\), phase measurement in the binomial code has vanishing variance, just like in a number-phase code \\cite{arxiv:1901.08071}."},{"code_id":"chuang-leung-yamamoto","detail":"Two-mode version of binomial codes correspond to two-mode \"0-2-4\" CLY codes (see Sec. IV.A of Ref. \\cite{arXiv:1602.00008})."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-03"},{"user_id":"ThomasWrona","date":"2022-05-18"},{"user_id":"VictorVAlbert","date":"2021-12-30"},{"user_id":"JosephTIosue","date":"2021-12-19"}]},"_zoodb":{"id":"binomial","source_file_path":"codes/quantum/oscillators/fock_state/rotation/binomial.yml","source_file_modification_token":1687727505572.2095}},"bosonic_rotation":{"code_id":"bosonic_rotation","physical":"oscillators","logical":"qudits","name":"Bosonic rotation code","introduced":"\\cite{arXiv:1901.08071}","description":"A single-mode Fock-state bosonic code whose codespace is preserved by a phase-space rotation by a multiple of \\(2\\pi/N\\) for some \\(N\\). The rotation symmetry ensures that encoded states have support only on every \\(N^{\\textrm{th}}\\) Fock state. For example, single-mode Fock-state codes for \\(N=2\\) encoding a qubit admit basis states that are, respectively, supported on Fock state sets \\(\\{|0\\rangle,|4\\rangle,|8\\rangle,\\cdots\\}\\) and \\(\\{|2\\rangle,|6\\rangle,|10\\rangle,\\cdots\\}\\).\n\nEncoding of a \\(q\\)-dimensional logical qudit admit a basis whose elements are eigenstates of the rotation operator \\(\\exp\\left(\\mathrm{i} 2\\pi \\hat{n}/qN \\right)\\), where \\(\\hat{n}\\) is the number operator diagonal in the Fock basis. Basis elements are of the form \\(\\sum_{j=0}^\\infty c_j |(kq+j)N \\rangle\\) for some coefficients \\(c_j\\) and \\(k\\). This is because the rotation acting on a general Fock-state superposition \\(\\sum_n a_n |n\\rangle\\) yields \\(\\sum_n a_n \\exp\\left(\\mathrm{i} 2\\pi n / qN \\right) |n\\rangle\\). In order for a codeword to be an eigenvector of this operation, \\(a_n\\) must be zero whenever \\(n \\neq (kq+j)N\\) for some \\(k\\).\n\nCodewords can be uniquely specified by choosing a \\emph{primitive} state \\(|\\Theta\\rangle\\). To ensure valid (orthogonal and nonzero) codewords, \\(|\\Theta\\rangle\\) must satisfy the following requirement: for each \\(j \\in \\mathbb{Z}_q\\), \\(|\\Theta\\rangle\\) must have support on the Fock state \\(|(k_j q+j)N\\rangle\\) for at least one \\(k_j \\in \\mathbb{N}_0\\). From such a primitive, the codewords \\(\\{|\\overline{j}\\rangle \\mid j \\in \\mathbb{Z}_q\\}\\) are constructed as\n\\begin{align}\n|\\overline{j}\\rangle \\propto \\sum_{m=0}^{2N-1} \\mathrm{e}^{2\\pi \\mathrm{i} m (\\hat n  / N + j) / q} |\\Theta\\rangle~.\n\\end{align}\n","protection":"Losses or gains less than \\(N\\) are detectable. Dephasing rotations \\(\\exp(\\mathrm{i}\\theta \\hat{n})\\) can be detected whenever \\(\\theta\\) is roughly less than \\(\\pi/N\\). To get precise bounds on \\(\\theta\\), one needs to analyze the particular bosonic rotation code.","features":{"general_gates":["The logical Pauli-\\(Z\\) gate can be the discrete rotation operator \\(\\mathrm{e}^{\\mathrm{i} \\pi \\hat n /N}\\), and the logical Pauli-\\(X\\) gate can be the (note: non-unitary) number-translation operator \\(\\sum_{n=0}^\\infty |n\\rangle\\bra{n+N}\\).","For qubit codes, a logical phase gate is \\(S = \\mathrm{e}^{\\pi \\mathrm{i} \\hat n^2 / 2N^2}\\).","The \\(T = \\mathrm{diag}(1,\\exp(\\mathrm{i}\\pi/4))\\) gate can be done via gate teleportation and a resource state \\(\\vert 0_N\\rangle + \\exp(\\mathrm{i}\\pi/4) \\vert 1_N \\rangle\\).","A controlled-rotation gate between an order \\(N\\) rotation code and an order \\(M\\) rotation code is \\(\\mathrm{CROT}_{NM} = \\mathrm{e}^{(2\\pi\\mathrm{i} / qNM) \\hat n \\otimes \\hat n}\\)."],"decoders":["One can distinguish (destructively) the codewords by performing a Fock-state number measurement. If a Fock state state \\(|n\\rangle\\) is measured, then one rounds to the nearest integer of the form \\((kq+j)/N\\), and deduces that the true state was \\(|\\overline{j}\\rangle\\).","One can distinguish states in the dual basis by performing phase estimation on \\(\\mathrm{e}^{\\mathrm{i} \\theta \\hat n}\\). One then rounds the resulting \\(\\theta\\) to the nearest number \\(2\\pi j / qN\\) in order to determine which dual basis state \\(j \\in \\mathbb Z_q\\) it came from.","Autonomous quantum error correction schemes for \\(S=1\\) codes \\cite{arxiv:2203.09234}."],"encoders":["The optimal way to prepare codewords depends on the exact rotation code in question \\cite{arXiv:1901.08071}."]},"relations":{"parents":[{"code_id":"fock_state","detail":"Single-mode Fock-state codes are typically rotationally invariant."},{"code_id":"single-mode"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-30"},{"user_id":"JosephTIosue","date":"2021-12-19"}]},"_zoodb":{"id":"bosonic_rotation","source_file_path":"codes/quantum/oscillators/fock_state/rotation/bosonic_rotation.yml","source_file_modification_token":1678631058735.4436}},"chebyshev":{"code_id":"chebyshev","name":"Chebyshev code","introduced":"\\cite{arxiv:1811.01450}","description":"Single-mode bosonic Fock-state code that can be used for error-corrected sensing of a signal Hamiltonian \\({\\hat n}^s\\), where \\({\\hat n}\\) is the occupation number operator. Codewords for the \\(s\\)th-order Chebyshev code are\n\\begin{align}\n\\begin{split}\n\\ket{\\overline 0} &=\\sum_{k \\text{~even}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2\\left( k\\pi/{2s}\\right) \\right\\rfloor},\\\\\n\\ket{\\overline 1} &= \\sum_{k \\text{~odd}}^{[0,s]} \\tilde{c}_k \\Ket{\\left\\lfloor M\\sin^2 \\left(k\\pi/{2s}\\right) \\right\\rfloor},\n\\end{split}\n\\end{align}\nwhere \\(\\tilde{c}_k>0\\) can be obtained by solving a system of order \\(O(s^2)\\) linear equations, and where \\(\\lfloor x \\rfloor\\) is the floor function. The code approaches optimality for sensing the signal Hamiltonian as \\(M\\) increases.\n","protection":"The \\(s\\)th-order code corrects errors from the set \\(\\{I,a,a^{\\dagger},{\\hat n},{\\hat n}^2,\\cdots,{\\hat n}^{s-1}\\}\\).","relations":{"parents":[{"code_id":"bosonic_rotation"},{"code_id":"single-mode"},{"code_id":"metopt"}],"cousins":[{"code_id":"binomial","detail":"Chebyshev codes resemble binomial codes, and a class of binomial codes have similar error-correcting properties \\cite{arxiv:1811.01450}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-27"}]},"_zoodb":{"id":"chebyshev","source_file_path":"codes/quantum/oscillators/fock_state/rotation/chebyshev.yml","source_file_modification_token":1678631058735.5032}},"number_phase":{"code_id":"number_phase","physical":"oscillators","logical":"qubits","name":"Number-phase code","introduced":"\\cite{arxiv:1901.08071}","description":"Bosonic rotation code consisting of superpositions of Pegg-Barnett phase states \\cite{doi:10.1088/0305-4470/19/18/030},\n\\begin{align}\n|\\phi\\rangle \\equiv \\frac{1}{\\sqrt{2\\pi}}\\sum_{n=0}^{\\infty} \\mathrm{e}^{\\mathrm{i} n \\phi} \\ket{n}.\n\\end{align}\nSince phase states and thus the ideal codewords are not normalizable, approximate versions need to be constructed. The codes' key feature is that, in the ideal case, phase measurement has zero uncertainty, making it a good canditate for a syndrome measurement.\n\nLogical states of an order-\\(N\\) number-phase qubit encoding are \\(|\\overline{0}\\rangle= \\sum_{m=0}^{2N-1} |\\phi = m\\pi/N\\rangle\\) and \\(|\\overline{1}\\rangle = \\sum_{m=0}^{2N-1} (-1)^m |\\phi=m\\pi/N\\rangle\\). By performing the summation over \\(m\\), one finds that \\(|\\overline{0}\\rangle\\) is supported on Fock states \\(|2kN\\rangle\\), while \\(|\\overline{1}\\rangle\\) is supported on states \\(|(2k+1)N\\rangle\\), for \\(k \\geq 0\\).\n","protection":"Number-phase codes of order \\(N\\) detect up to \\(N\\) photon loss or gain errors, and dephasing up to \\(\\theta = \\pi/N\\).","features":{"decoders":["Modular phase measurement done in the logical \\(X\\), or dual, basis has zero uncertainty in the case of ideal number phase codes. This is equivalent to a quantum measurement of the spectrum of the phase operator \\cite{doi:10.1103/PhysicsPhysiqueFizika.1.49}. Approximate number-phase codes are characterized by vanishing phase uncertainty. Such measurements can be utilized for Knill error correction (a.k.a. telecorrection \\cite{arxiv:quant-ph/0601066}), which is based on teleportation \\cite{arxiv:quant-ph/0410199,arXiv:quant-ph/0312190}. This type of error correction avoids the complicated correction procedures typical in Fock-state codes, but requires a supply of clean codewords \\cite{arxiv:1901.08071}. Performance of this method was analyzed in Ref. \\cite{arxiv:2108.01009}.","Number measurement can be done by extracting modular number information using a CROT gate \\(\\mathrm{e}^{(2\\pi \\mathrm{i} / NM) \\hat n \\otimes \\hat n}\\) and performing phase measurements \\cite{preset:Helstrom,doi:10.1007/978-88-7642-378-9} on an ancillary mode. See Section 4.B.1 of Ref. \\cite{arxiv:1901.08071}."],"fault_tolerance":["Fault-tolerant computation schemes with number-phase codes have been proposed based on concatenation with Bacon-Shor subsystem codes \\cite{arxiv:1901.08071}."]},"relations":{"parents":[{"code_id":"bosonic_rotation","detail":"Number-phase codes are bosonic rotation codes with the primitive state is a Pegg-Barnett phase state \\cite{doi:10.1088/0305-4470/19/18/030}."}],"cousins":[{"code_id":"rotor_gkp","detail":"Number-phase codes are a manifestation of planar-rotor GKP codes in an oscillator. Both codes protect against small shifts in angular degrees of freedom."},{"code_id":"oscillator_stabilizer","detail":"Number-phase codewords span the joint right eigenspace of the \\(N\\)th power of the Pegg-Barnett phase operator and the bosonic rotation operator \\cite{arxiv:1901.08071}. These operators no longer form a group since the phase operator is not unitary."},{"code_id":"gkp","detail":"Square-lattice GKP codes utilize translational symmetry in phase space, while number-phase codes utilize rotational symmetry. The two are related via a mapping \\cite{arxiv:2206.01751}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-08"},{"user_id":"VictorVAlbert","date":"2021-12-30"},{"user_id":"JosephTIosue","date":"2021-12-19"}]},"_zoodb":{"id":"number_phase","source_file_path":"codes/quantum/oscillators/fock_state/rotation/number_phase.yml","source_file_modification_token":1683723710997.474}},"hybrid_qudit_oscillator":{"code_id":"hybrid_qudit_oscillator","physical":"qudits","logical":"groups","name":"Hybrid qudit-oscillator code","description":"Encodes a \\(K\\)-dimensional logical Hilbert space into \\(n_1\\) modular qudits of dimension \\(q\\) and \\(n_2 \\neq 0\\) oscillators, i.e., the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{Z}_q^{n_1} \\times \\mathbb{R}^{n_2}\\).\n\nCodewords of a simple hybrid code \\cite{arxiv:1112.0825} are \\(|\\alpha\\rangle|+\\rangle\\) and \\(|-\\alpha\\rangle|V\\rangle\\), i.e., hyper-entangled states of the polarization \\(|\\pm\\rangle\\) and occupation-number degrees of freedom of a photon, with the latter being in a coherent state \\(|\\pm\\alpha\\rangle\\).\n","relations":{"parents":[{"code_id":"oscillators","detail":"The physical Hilbert space of a hybrid qubit-oscillator code contains at least one oscillator."}],"cousins":[{"code_id":"qudits_into_oscillators","detail":"Hybrid code with \\(n_1=0\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-11-03"}]},"_zoodb":{"id":"hybrid_qudit_oscillator","source_file_path":"codes/quantum/oscillators/hybrid_qudit_oscillator.yml","source_file_modification_token":1687728256188.1978}},"oscillators":{"code_id":"oscillators","physical":"oscillators","name":"Bosonic code","description":"Also called an \\textit{oscillator} or a \\textit{continuous-variable (CV)} code.\nEncodes logical Hilbert space, finite- or infinite-dimensional, into a physical Hilbert space that contains at least one \\textit{oscillator} (a.k.a. \\textit{bosonic mode} or \\textit{qumode}).\nStates of a single oscillator are elements of the Hilbert space of \\(\\ell^2\\)-normalizable functions on \\(\\mathbb{R}\\).\nIdeal codewords may not be normalizable because the space is infinite-dimensional, so approximate versions have to be constructed in practice.'\n","protection":"An error set relevant to \\hyperref[code:oscillator_stabilizer]{bosonic stabilizer} codes is the set of \\textit{displacement operators}, a bosonic analogue of the Pauli string basis for \\hyperref[code:qubits_into_qubits]{qubit} codes. For a single mode, its elements are products of exponentials of the mode's position and momentum operators, acting on the mode's position states \\(|y\\rangle\\) for \\(y\\in\\mathbb{R}\\) as\n\\begin{align}\n  e^{-iq\\hat{p}}\\left|y\\right\\rangle =\\left|y+q\\right\\rangle \\,\\,\\text{ and }\\,\\,e^{iq\\hat{x}}\\left|y\\right\\rangle =e^{iq y}\\left|y\\right\\rangle ~,\n\\end{align}\nwhere \\(q\\in\\mathbb{R}\\).\nFor multiple modes, error set elements are tensor products of elements of the single-oscillator error set, characterized by the vector of coefficients \\(\\xi\\in\\mathbb{R}^{2n}\\).\n\nThe displacement error set is a unitary basis for trace-class linear operators on the \\(n\\)-mode Hilbert space that is Dirac-orthonormal under the Hilbert-Schmidt inner product \\cite{doi:10.1103/PhysRev.177.1857}.\nThere are two definitions of code distance associated with displacements.\nThe definition inherited from qubit codes is the minimum weight of a displacement operator (i.e., number of nonzero entries in \\(\\xi\\)) that implements a nontrivial logical operation in the code. The second definition is the minimum Euclidean distance (i.e., \\(\\ell^2\\)-norm of \\(\\xi\\)) such that the corresponding displacement implements a nontrivial logical operation in the code.\n\nAn error set relevant to \\hyperref[code:fock_state]{Fock-state bosonic} codes is the set of loss operators associated with the \\textit{amplitude damping} (a.k.a. \\textit{photon loss} or \\textit{attenuation}) noise channel, a common form of physical noise in bosonic systems. For a single mode, loss operators are proportional to powers of the mode's annihilation operator \\(a=(\\hat{x}+i\\hat{p})/\\sqrt{2}\\), where \\(\\hat x\\) (\\(\\hat p\\)) is the mode's position (momentum) operator, and with the power signifying the number of particles lost during the error. For multiple modes, error set elements are tensor products of elements of the single-mode error set. A definition of distance associated with this error set is the minimum weight of a loss error that implements a nontrivial logical operation in the code.\n\nAn related error set is the set of powers of the Susskind–Glogower phase operator \\(\\frac{1}{\\sqrt{a a^\\dagger}} a\\) \\cite{doi:10.1103/PhysicsPhysiqueFizika.1.49} and its adjoint (a.k.a. phasors \\cite{doi:10.1016/0003-4916(91)90037-9}) along with Fock-space rotations generated by the occupation number operator \\(a^\\dagger a\\).\nThese can also be obtained from qudit Pauli matrices through a limiting procedure \\cite{arxiv:quant-ph/0109066} and allow one to expand trace-class operators despite not forming an orthonormal set \\cite{arxiv:2211.05714}. These operators are correspong to a polar-like decomposition of a single mode, complementing the cartesian-like decomposition in terms of position and momentum displacements.\n","features":{"rate":"The quantum capacity of the pure-loss channel \\cite{arxiv:quant-ph/0606132} and the dephasing noise channel \\cite{arxiv:2205.05736} are both known. The capacity of the displacement noise channel, the quantum analogue of AGWN, has been bounded using GKP codes \\cite{arxiv:quant-ph/0105058,arxiv:1801.07271}."},"notes":["Reviews on bosonic codes can be found in Refs. \\cite{arxiv:2211.05714,arxiv:2002.11008,arxiv:2008.13471,arxiv:2010.08699,arxiv:2103.09445,arXiv:2111.08894}.","For an introduction to continuous-variable quantum systems, see the books \\cite{doi:10.1142/p489,doi:10.1201/9781315118727}."],"relations":{"parents":[{"code_id":"group_quantum","detail":"Group quantum codes whose physical spaces are constructed using the group of the reals \\(\\mathbb{R}\\) under addition are bosonic codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-08"},{"user_id":"VictorVAlbert","date":"2021-11-24"}]},"_zoodb":{"id":"oscillators","source_file_path":"codes/quantum/oscillators/oscillators.yml","source_file_modification_token":1687727505572.492}},"oscillators_into_oscillators":{"code_id":"oscillators_into_oscillators","physical":"oscillators","logical":"oscillators","name":"Oscillator-into-oscillator code","introduced":"\\cite{arXiv:quant-ph/9711021,arXiv:quant-ph/9711049}","description":"Also called an \\textit{analog quantum code}. Encodes \\(k\\) bosonic modes into \\(n\\) bosonic modes.","relations":{"parents":[{"code_id":"oscillators","detail":"Oscillator-into-oscillator codes are bosonic codes with an infinite-dimensional logical subspace."},{"code_id":"block_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-10-30"}]},"_zoodb":{"id":"oscillators_into_oscillators","source_file_path":"codes/quantum/oscillators/oscillators_into_oscillators.yml","source_file_modification_token":1677058672663.99}},"qudits_into_oscillators":{"code_id":"qudits_into_oscillators","physical":"oscillators","logical":"qudits","name":"Qudit-into-oscillator code","description":"Encodes \\(K\\)-dimensional Hilbert space into \\(n\\) bosonic modes.","protection":"","features":{"decoders":["Given an encoding of a finite-dimensional code, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program \\cite{arXiv:quant-ph/0109155,arXiv:quant-ph/0307138} (see also Ref. \\cite{arXiv:0706.3400}). This approximate QEC technique can be adapted to bosonic codes as long as they are restricted to a finite-dimensional subspace of the oscillator Hilbert space \\cite{arXiv:1708.05010}."]},"relations":{"parents":[{"code_id":"oscillators","detail":"Qudit-into-oscillator codes are bosonic codes with a finite-dimensional logical subspace."}],"cousins":[{"code_id":"approximate_qecc","detail":"Approximate QEC techniques of finding the entanglement fidelity can be adapted to bosonic codes with a finite-dimensional codespace \\cite{arXiv:1708.05010}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-17"},{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"qudits_into_oscillators","source_file_path":"codes/quantum/oscillators/qudits_into_oscillators.yml","source_file_modification_token":1664458793869.77}},"single-mode":{"code_id":"single-mode","physical":"oscillators","logical":"qudits","name":"Single-mode bosonic code","description":"Encodes \\(K\\)-dimensional Hilbert space into a single bosonic mode. A trivial single-mode code encoding a qubit into the first two Fock states \\(\\{|0\\rangle,|1\\rangle\\}\\) is called the \\textit{single-rail} encoding \\cite{arXiv:quant-ph/0007106,arxiv:quant-ph/0205044}.","relations":{"parents":[{"code_id":"qudits_into_oscillators"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-10"}]},"_zoodb":{"id":"single-mode","source_file_path":"codes/quantum/oscillators/single-mode.yml","source_file_modification_token":1675174784446.869}},"analog_stabilizer":{"code_id":"analog_stabilizer","physical":"oscillators","logical":"oscillators","name":"Analog stabilizer code","description":"Also known as a \\textit{linear}, \\textit{symplectic}, or \\textit{Gaussian stabilizer code}.\nOscillator-into-oscillator stabilizer code encoding \\(k\\) logical modes into \\(n\\) physical modes. An \\(((n,k,d))_{\\mathbb{R}}\\) analog stabilizer code is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.\n\nAnalog stabilizer codes admit continuous stabilizer group of displacements.  This group can equivalently be defined in terms of its Lie algebra. The codespace is equivalently the common \\(0\\)-eigenvalue eigenspace of the Lie algebra generators, which are mutually commuting linear combinations of oscillator position and momentum operators called \\textit{nullifiers} \\cite{arxiv:0903.3233} or \\textit{annihilators}.\nAn analog stabilizer code admitting a set a set of nullifiers such that each nullifier consists of either position or momentum operators is called an \\textit{analog CSS code}.\n","protection":"Protect against erasures of at most \\(d-1\\) modes, or arbitrarily large dispalcements on those modes. If an error operator does not commute with a nullifier, then that error is detectable. Protection of logical modes against small displacements cannot be done using only Gaussian resources \\cite{arxiv:0811.3128,arxiv:1810.00047} (see also \\cite{arxiv:quant-ph/0204052,arxiv:quant-ph/0204085}). There are no such restrictions for non-Gaussian noise \\cite{arxiv:0811.3616}.","features":{"encoders":["Gaussian circuit applied to \\(k\\) modes storing logical information and \\(n-k\\) modes initialized in a position state."],"decoders":["Homodyne measurement of nullifiers yields real-valued syndromes, and recovery can be performed by displacements conditional on the syndromes."]},"realizations":["One-sided device-independent QKD \\cite{arxiv:2212.03935}."],"relations":{"parents":[{"code_id":"oscillator_stabilizer","detail":"Analog stabilizer codes are bosonic stabilizer codes with a continuous stabilizer group, corresponding to linear constraints on positions and momenta."},{"code_id":"oscillators_into_oscillators"}],"cousins":[{"code_id":"gkp-stabilizer","detail":"Analog stabilizer codes protect logical modes against arbitrarily large displacements on a few modes, while GKP-stabilizer codes protect a finite-dimensional logical space against sufficiently small displacements in any number of modes. Encoding in analog-stabilizer (GKP-stabilizer) codes can be done by a Gaussian operation acting on a tensor product of an arbitrary state in the first mode and position states (GKP states) on the remaining modes. Protection of logical modes against small displacements cannot be done using only Gaussian resources \\cite{arxiv:1810.00047,arxiv:quant-ph/0204052,arxiv:0811.3128}, so GKP-stabilizer codes can be thought of as analog stabilizer encodings utilizing non-Gaussian GKP resource states."},{"code_id":"qudit_stabilizer","detail":"Prime-qudit stabilizer codes can be converted into analog stabilizer codes whose distance is at least as large as that of the original code \\cite{arxiv:2303.17000}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-05"}]},"_zoodb":{"id":"analog_stabilizer","source_file_path":"codes/quantum/oscillators/stabilizer/hyperplane/analog_stabilizer.yml","source_file_modification_token":1681805027418.9595}},"analog_surface":{"code_id":"analog_surface","physical":"oscillators","logical":"oscillators","name":"Analog surface code","introduced":"\\cite{arXiv:0711.0820}","description":"Also called a \\textit{continuous-variable (CV) surface code}. An analog CSS version of the Kitaev surface code.\n","features":{"decoders":["Shift-based decoder \\cite{arxiv:1810.00047}."]},"notes":["See \\cite[Sec. III.C2]{arxiv:1302.3428} for an exposition."],"relations":{"parents":[{"code_id":"analog_stabilizer"}],"cousins":[{"code_id":"qudit_surface","detail":"The analog surface code realizes a straightforward extension of the modular-qudit surface code to infinite local dimension, \\(q\\to\\infty\\). There are two types of anyons, \\(e\\) and \\(m\\), with each type being valued in \\(U(1)\\) as opposed to \\(\\mathbb{Z}_q\\) for the qudit surface code."},{"code_id":"topological_abelian","detail":"The analog surface code realizes a straightforward extension of the modular-qudit surface code to infinite local dimension, \\(q\\to\\infty\\). There are two types of anyons, \\(e\\) and \\(m\\), with each type being valued in \\(U(1)\\) as opposed to \\(\\mathbb{Z}_q\\) for the qudit surface code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-10-11"}]},"_zoodb":{"id":"analog_surface","source_file_path":"codes/quantum/oscillators/stabilizer/hyperplane/analog_surface.yml","source_file_modification_token":1681484685078.3647}},"braunstein":{"code_id":"braunstein","physical":"oscillators","logical":"oscillators","name":"Braunstein five-mode code","introduced":"\\cite{arXiv:quant-ph/9711049}","description":"A \\([[5,1,3]]_{\\mathbb{R}}\\) analog stabilizer version of the five-qubit perfect code.\n","features":{"decoders":["Error correction can be done using linear-optical elements and feedback \\cite{doi:10.1038/27850}."]},"relations":{"parents":[{"code_id":"analog_stabilizer"},{"code_id":"quantum_cyclic"},{"code_id":"small_distance"}],"cousins":[{"code_id":"qudit_5_1_3","detail":"The Braunstein five-mode code is a bosonic analogue of the five-qudit code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-22"}]},"_zoodb":{"id":"braunstein","source_file_path":"codes/quantum/oscillators/stabilizer/hyperplane/braunstein.yml","source_file_modification_token":1681484685078.9429}},"ea_analog_stabilizer":{"code_id":"ea_analog_stabilizer","physical":"oscillators","logical":"oscillators","name":"EA analog stabilizer code","introduced":"\\cite{arxiv:0705.4314}","description":"Constructed using a variation of the analog stabilizer formalism designed to utilize pre-shared entanglement between sender and receiver.\n","relations":{"parents":[{"code_id":"analog_stabilizer","detail":"EA analog stabilizer codes utilize additional ancillary modes in a pre-shared entangled state, but reduce to ordinary analog stabilizer codes when said modes are interpreted as noiseless physical modes."},{"code_id":"eaqecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-12"}]},"_zoodb":{"id":"ea_analog_stabilizer","source_file_path":"codes/quantum/oscillators/stabilizer/hyperplane/ea_analog_stabilizer.yml","source_file_modification_token":1681484685079.0493}},"homological_cv":{"code_id":"homological_cv","physical":"oscillators","logical":"oscillators","name":"Homological bosonic code","introduced":"\\cite{arXiv:1601.02544}","description":"An \\([[n,1]]_{\\mathbb{R}}\\) \\hyperref[code:analog_stabilizer]{analog CSS code} defined using homological structres associated with an \\(n-1\\) simplex. Relevant to the study of spacetime replication of quantum information \\cite{arxiv:1210.0913}.\n\nStabilizer generators are defined by two orthogonal subspaces of the \\(C_1\\) in the chain complex. \\(C_X = \\partial_2 C_2\\) and \\(C_P = \\partial_1^T Q\\) for some \\(Q \\subset C_0\\). The standard approach would use \\(Q = C_0\\), which would mean the logical dimension would be the dimension of the 1st homology group \\(H^1\\). However, \\(H^1\\) is trivial for the \\(n-1\\) simplex, so one chooses \\(Q \\neq C_0\\) such that exactly one stabilizer is removed, yielding a stabilizer code instead of a single stabilized state.\n","protection":"Protects against certain types of erasure errors (depending on the specific dimension). Certain constructions also protect arbitrary sized errors on multiple photon states.","features":{"encoders":["Encoding depends on the specific dimension, but can generally be done using generalized conditional-rotation and Fourier-transform gates."],"decoders":["Decoding requires a different circuit for each possible erasure error, with no general circuit decoding any possible erasure error. Every circuit relies on a generalized conditional rotation, which Ref. \\cite{arXiv:1601.02544} calls the \\textit{QND Gate} and which is defined as \\(QND_c | x , y \\rangle = |x + c y, y \\rangle\\)."]},"notes":["Proposed experimental optical procedure for realizing the simplest non-trival code with 5 modes \\cite{arXiv:1601.02544}."],"relations":{"parents":[{"code_id":"analog_stabilizer"}],"cousins":[{"code_id":"generalized_homological_product_css","detail":"Homological CV codes utilize chain complexes in code construction, but the complexes have trivial homology."},{"code_id":"niset_andersen_cerf","detail":"The Niset-Andersen-Cerf code can be viewed as a scheme to replicate quantum information in multiple regions \\cite{arXiv:1601.02544}."},{"code_id":"spacetime","detail":"Homological CV codes have been considered in the context of spacetime replication of quantum data \\cite{arxiv:1210.0913,arXiv:1601.02544}, while STCs are designed to replicate classical data."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"},{"user_id":"VictorVAlbert","date":"2022-01-04"},{"user_id":"SiddharthTaneja","date":"2021-12-19"}]},"_zoodb":{"id":"homological_cv","source_file_path":"codes/quantum/oscillators/stabilizer/hyperplane/homological_cv.yml","source_file_modification_token":1681484685079.1318}},"lloyd_slotine":{"code_id":"lloyd_slotine","physical":"oscillators","logical":"oscillators","name":"Lloyd-Slotine nine-mode code","introduced":"\\cite{arXiv:quant-ph/9711021}","description":"A \\([[9,1,3]]_{\\mathbb{R}}\\) analog CSS version of Shor's nine-qubit code.\nThe nullifiers for this code are\n\\begin{align}\n\\begin{split}\n&\\hat{x}_1 - \\hat{x}_2~, \\hat{x}_2 - \\hat{x}_3~, \\hat{x}_4 - \\hat{x}_5~ , \\hat{x}_5 - \\hat{x}_6~ , \\hat{x}_7 - \\hat{x}_8, \\hat{x}_8 - \\hat{x}_9~,\\\\\n&(\\hat{p}_1 + \\hat{p}_2 + \\hat{p}_3) - (\\hat{p}_4 + \\hat{p}_5 + \\hat{p}_6)~,\\\\\n&(\\hat{p}_4 + \\hat{p}_5 + \\hat{p}_6) - (\\hat{p}_7 +\\hat{p}_8 + \\hat{p}_9)~.\n\\end{split}\n\\end{align}\nLogical mode operators are generated by\n\\begin{align}\n\\begin{split}\n\\bar q &=& \\hat{q}_1 + \\hat{q}_4 + \\hat{q}_7~, \\\\\n\\bar p &=& \\hat{p}_1 + \\hat{p}_2 + \\hat{p}_3~.\n\\end{split}\n\\end{align}\n","realizations":["Optical network by the Furusawa group \\cite{arXiv:0811.3734}."],"relations":{"parents":[{"code_id":"analog_stabilizer"},{"code_id":"small_distance"}],"cousins":[{"code_id":"shor_nine","detail":"The Lloyd-Slotine nine-mode code is a bosonic analogue of Shor's code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-22"}]},"_zoodb":{"id":"lloyd_slotine","source_file_path":"codes/quantum/oscillators/stabilizer/hyperplane/lloyd_slotine.yml","source_file_modification_token":1687727505572.6018}},"dfour_gkp":{"code_id":"dfour_gkp","physical":"oscillators","logical":"qudits","name":"\\(D_4\\) hyper-diamond GKP code","introduced":"\\cite{arxiv:2201.12337}","description":"Two-mode GKP qudit-into-oscillator code based on the \\(D_4\\) hyper-diamond lattice.\n","features":{"general_gates":["Logical Clifford operations are given by passive Gaussian unitaries. Non-Clifford gates can be done through Kerr-type unteractions."]},"relations":{"parents":[{"code_id":"multimodegkp"},{"code_id":"qudits_into_oscillators"}],"cousins":[{"code_id":"dfour"},{"code_id":"quantum_concatenated","detail":"The \\(D_4\\) hyper-diamond GKP code can be seen as a concatenation of a rotated square-lattice GKP code with a repetition code \\cite{arxiv:2201.12337}. This is related to the fact that the four-bit repetition code yields the \\(D_4\\) hyper-diamond lattice code via the mod-two lattice construction."},{"code_id":"quantum_repetition","detail":"The \\(D_4\\) hyper-diamond GKP code can be seen as a concatenation of a rotated square-lattice GKP code with a repetition code \\cite{arxiv:2201.12337}. This is related to the fact that the four-bit repetition code yields the \\(D_4\\) hyper-diamond lattice code via the mod-two lattice construction."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-25"}]},"_zoodb":{"id":"dfour_gkp","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/dfour_gkp.yml","source_file_modification_token":1681484685079.544}},"gkp-cluster-state":{"code_id":"gkp-cluster-state","physical":"oscillators","logical":"qudits","name":"GKP cluster-state code","introduced":"\\cite{arXiv:1310.7596}","description":"Multi-mode code encoding logical qubits into a cluster-state stabilizer code concatenated with a single-mode GKP code. Provides a way to perform a continuous-variable (CV) analogue of fault-tolerant MBQC.\n\nA cluster state of GKP qubits on a graph is made by applying two-mode \\(C_Z\\)-type gates \\(e^{\\pm i \\hat{x}\\otimes\\hat{x}}\\) to a tensor product of \\(|\\overline{+}\\rangle\\) logical GKP states on each vertex. Logical Clifford gates are performed on the cluster state using CV measurement-based computation \\cite{arxiv:quant-ph/0605198,arxiv:0903.3233}, i.e., via a combination of linear-optical gates and homodyne measurements on subsets of vertices. Magic-state distillation is required for universal computation. GKP error correction can be naturally combined with CV measurement-based protocols since the performance of both is quantified by a squeezing parameter.\n","features":{"general_gates":["Single-mode logical Clifford gates can be performed using Gaussian operations and measurements on a 1D GKP cluster state, while two-mode logical Clifford gates require a 2D cluster state. Magic-state distillation using photon-counting can be used for a non-Clifford logical \\(\\pi/8\\) gate."],"fault_tolerance":["First encoding demonstrating the possibility of fault-tolerant measurement-based computation with CV cluster states. A fault-tolerance threshold can be achieved by concatenating existing fault-tolerant schemes for qubit-based cluster-state encodings with the GKP code \\cite{arXiv:1310.7596}.","Hybrid cluster state consisting of GKP qubits at some modes and squeezed states at others has been proposed to work in a fault-tolerant scheme \\cite{arxiv:2010.02905}."]},"relations":{"parents":[{"code_id":"multimodegkp","detail":"The GKP cluster-state code is a concatenation of a cluster-state stabilizer code with a single-mode GKP code. A GKP-based cluster state is a multimode GKP codeword, although other codewords are not utilized in CV MBQC."},{"code_id":"qudits_into_oscillators"}],"cousins":[{"code_id":"quantum_concatenated"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-28"}]},"_zoodb":{"id":"gkp-cluster-state","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/gkp-cluster-state.yml","source_file_modification_token":1681484685079.6245}},"gkp-stabilizer":{"code_id":"gkp-stabilizer","physical":"oscillators","logical":"oscillators","name":"GKP-stabilizer code","introduced":"\\cite{arXiv:1903.12615}","description":"Multimode GKP code with an infinite-dimensional logical space. Can be obtained by considering an \\(n\\)-mode GKP code with a finite-dimensional logical space, removing stabilizers such that the logical space becomes infinite dimensional, and applying a Gaussian circuit.\n\nSimple GKP-stabilizer codes include GKP-repetition codes and GKP two-mode-squeezing (TMS) codes \\cite{arXiv:1903.12615}. Arbitrary GKP-stabilizer codes can be reduced to generalized GKP TMS codes, and the optimal code design problem can be efficiently solved \\cite{arxiv:2212.11970}.\n","protection":"GKP-stabilizer codes to protect one or more modes against displacement noise using GKP resource states\n","features":{"encoders":["Gaussian circuit applied to \\(k\\) modes storing logical information and \\(n-k\\) modes initialized in a fixed GKP state."],"threshold":["Thresholds against displacement noise cannot be obtained without ideal (i.e., non-normalizable) codewords \\cite{arxiv:2102.05545}."],"decoders":["Syndromes can be read off using ancilla modes, yielding partial information about noise in the logical modes that can then be used in an efficient ML decoding procedure \\cite{arxiv:2209.04573}."]},"notes":["Introduction to and examples of GKP-stabilizer codes \\cite{arxiv:2211.05714}."],"relations":{"parents":[{"code_id":"quantum_lattice","detail":"GKP-stabilizer codes are \\(n\\)-mode quantum lattice codes with less than \\(2n\\) stabilizers, i.e., constructed using a degenerate lattice (see Appx. A of Ref. \\cite{arXiv:2109.14645})."},{"code_id":"oscillators_into_oscillators"}],"cousins":[{"code_id":"quantum_concatenated","detail":"GKP-stabilizer oscillator-into-oscillator codes concantenated with GKP qubit-into-mode codes can outperform the more conventional concatenations of GKP codes with qubit stabilizer codes \\cite{arxiv:2209.04573}."},{"code_id":"dfour_gkp","detail":"\\(D_4\\) hyper-diamond GKP codes may be optimal for GKP stabilizer codes utilizing two ancilla modes \\cite{arxiv:2212.11970}."},{"code_id":"hexagonal_gkp","detail":"Hexagonal GKP codes may be optimal for GKP stabilizer codes utilizing one ancilla mode \\cite{arxiv:2212.11970}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-15"},{"user_id":"ArminGerami","date":"2022-12-15"},{"user_id":"VictorVAlbert","date":"2022-09-15"},{"user_id":"VictorVAlbert","date":"2022-03-24"}]},"_zoodb":{"id":"gkp-stabilizer","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/gkp-stabilizer.yml","source_file_modification_token":1681484685079.7075}},"gkp":{"code_id":"gkp","physical":"oscillators","logical":"qudits","name":"Square-lattice GKP code","introduced":"\\cite{arXiv:quant-ph/0008040}","description":"Single-mode GKP qudit-into-oscillator code based on the rectangular lattice.\nIts stabilizer generators are oscillator displacement operators \\(\\hat{S}_q(2\\alpha)=e^{-2i\\alpha \\hat{p}}\\) and \\(\\hat{S}_p(2\\beta)=e^{2i\\beta \\hat{x}}\\).\nTo ensure \\(\\hat{S}_q(2\\alpha)\\) and \\(\\hat{S}_p(2\\beta)\\) generate a stabilizer group that is Abelian, there is a constraint that \\(\\alpha\\beta=2q\\pi\\) where \\(q\\) is an integer denoting the logical dimension.\n\nCodewords can be expressed as equal weight superpositions of coherent states on a rectangular lattice in phase space with spatial period \\(2\\sqrt{\\pi}\\).\nThe exact GKP state is non-normalizable, so approximate constructs have to be considered.\n\nThe \\(q=1\\) trivial encoding is spanned by the \\textit{canonical GKP state} or \\textit{grid state},\n\\begin{align}\n  |GKP\\rangle=\\sum_{n\\in\\mathbb{Z}}|x=n\\sqrt{2\\pi}\\rangle~,\n\\end{align}\nwhere \\(|x\\rangle\\) are single-mode position states.\n","protection":"For stabilizer \\(\\hat{S}_q(2\\alpha),\\hat{S}_p(2\\beta)\\), code can correct displacement errors up to \\(\\alpha/2\\) in the \\(q\\)-direction and \\(\\beta/2\\) at \\(p\\)-direction. Approximately protects against photon loss errors \\cite{arxiv:1506.05033,arxiv:1708.05010}, outperforming most other codes designed to explicitly protect against loss \\cite{arxiv:1708.05010}. Very sensitive to dephasing errors \\cite{arxiv:2106.12989}. A biased-noise GKP error correcting code can be prepared by choosing \\(\\alpha\\neq \\beta\\).","features":{"encoders":["Preparation of approximate square-lattice GKP states is studied both theoretically and experimentally by putting the GKP lattice inside a Gaussian envelope \\cite{arxiv:1506.05033,arxiv:1709.08580,doi:10.1038/s41586-020-2603-3,arxiv:1910.03673}.","Dissipative stabilization of finite-energy square-lattice GKP states using stabilizers conjugated by a \\textit{cooling} (\\cite{arxiv:1310.7596}, Appx. B) or \\textit{damping} operator, i.e., a damped exponential of the total occupation number \\cite{arXiv:2009.07941,arxiv:2010.09681}.","Two Josephson junctions coupled by a gyrator \\cite{arxiv:2002.07718}.","Periodic driving (a.k.a. Floquet engineering) \\cite{arxiv:2303.03541}.","Approximate GKP states can be prepared using Gaussian operations and photon detectors \\cite{arxiv:1902.02323}."],"general_gates":["By applying square-lattice GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements \\cite{arxiv:1903.00012}."],"fault_tolerance":["Clifford gates can be realized by performing linear-optical operations, sympletic transformations and displacements, all of which are Gaussian operations. Pauli gates can be performed using displacement operators. Clifford gates are fault tolerant in the sense that they map bounded-size errors to bounded-size errors \\cite{arXiv:quant-ph/0008040}.","Error correction scheme is fault-tolerant to displacement noise as long as all input states have displacement errors less than \\(\\sqrt{\\pi}/6\\) \\cite{arxiv:quant-ph/0510107}."],"decoders":["Syndrome measurement can be done by applying a controlled-displacement controlled by an ancilla qubit. The syndrome information can be obtained by measuring the ancilla qubit after controlled-displacement opearation. See Section. 2D in \\cite{arxiv:2106.12989}.","Decoder \\cite{arxiv:2008.12791} based on Knill error correction (a.k.a. telecorrection \\cite{arxiv:quant-ph/0601066}), which is based on teleportation \\cite{arxiv:quant-ph/0410199,arXiv:quant-ph/0312190}.","Pauli \\(X\\),\\(Y\\) and \\(Z\\) measurements can be performed by measuring \\(-\\hat{p},\\hat{x}-\\hat{p}\\) and \\(\\hat{x}\\) repectively. If the measurement outcome is closed to an even multiple of \\(\\sqrt{\\pi}\\), then the outcome is +1. If the measurement outcome is closed to an odd multiple of \\(\\sqrt{\\pi}\\), then the outcome is -1. See Section. 2D in \\cite{arxiv:2106.12989}.","Reinforcement learning decoder that uses only one ancilla qubit \\cite{arxiv:2211.09116}."]},"notes":["Reviews on GKP codes presented in Refs. \\cite{arxiv:2002.11008,arXiv:2106.12989}."],"realizations":["Motional degree of freedom of a trapped ion: square-lattice GKP encoding realized with the help of post-selection \\cite{arxiv:1807.01033,arXiv:1907.06478}, followed by realization of reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ion electronic state \\cite{arxiv:2010.09681}.","Microwave cavity coupled to superconducting circuits: reduced form of square-lattice GKP error correction, where displacement error syndromes are measured to one bit of precision using an ancillary transmon \\cite{arxiv:1907.12487}. Subsequent paper \\cite{arxiv:2211.09116} uses reinforcement learning for error-correction cycle design and is the first to go beyond break-even error-correction, with the lifetime of a logical qubit exceeding the cavity lifetime by about a factor of two (see also \\cite{arxiv:2211.09319}).","Single-qubit \\(Z\\)-gate has been demonstrated in the single-photon subspace of an infinite-mode space \\cite{arxiv:1904.01351}, in which time and frequency become bosonic conjugate variables of a single effective bosonic mode.","In signal processing, GKP state position-state wavefunctions are related to Dirac combs \\cite{doi:10.1007/978-1-4612-2016-9}."],"relations":{"parents":[{"code_id":"multimodegkp"},{"code_id":"single-mode"}],"cousins":[{"code_id":"approximate_qecc","detail":"Square-lattice GKP codes approximately protect against photon loss \\cite{arxiv:1506.05033,arxiv:1708.05010,arXiv:1801.07271}."},{"code_id":"rotor","detail":"Because square-lattice GKP error states are parameterized by two modular (i.e., periodic) variables of position and momentum, measuring one of the GKP stabilizers constrains the oscillator Hilbert space into that of a rotor."},{"code_id":"hypercubic","detail":"GKP codewords, when written in terms of coherent states, form a square lattice in phase space."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-02"},{"user_id":"VictorVAlbert","date":"2022-03-22"},{"user_id":"VictorVAlbert","date":"2021-12-15"},{"user_id":"YijiaXu","date":"2021-12-14"}]},"_zoodb":{"id":"gkp","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/gkp.yml","source_file_modification_token":1687727505572.7197}},"hexagonal_gkp":{"code_id":"hexagonal_gkp","physical":"oscillators","logical":"qudits","name":"Hexagonal GKP code","introduced":"\\cite{arXiv:quant-ph/0008040}","description":"Single-mode GKP qudit-into-oscillator code based on the hexagonal lattice. Offers the best error correction against displacement noise in a single mode due to the optimal packing of the underlying lattice.\n","realizations":["Microwave cavity coupled to superconducting circuits: reduced form of GKP error correction, where displacement error syndromes are measured to one bit of precision using an ancillary transmon \\cite{arxiv:1907.12487}."],"notes":["Hexagonal GKP codes were obtained after iterative numerical optimization of encoding and recovery against photon loss, starting with Haar-random states \\cite{arXiv:1801.07271}."],"relations":{"parents":[{"code_id":"multimodegkp"},{"code_id":"single-mode"}],"cousins":[{"code_id":"hexagonal"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-25"}]},"_zoodb":{"id":"hexagonal_gkp","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/hexagonal_gkp.yml","source_file_modification_token":1681484685079.8716}},"multimodegkp":{"code_id":"multimodegkp","physical":"oscillators","name":"Gottesman-Kitaev-Preskill (GKP) code","short_name":"GKP","introduced":"\\cite{arXiv:quant-ph/0008040,arXiv:quant-ph/0105058}","description":"Quantum lattice code for a non-degenerate lattice, thereby admitting a finite-dimensional logical subspace.\nCodes on \\(n\\) modes can be constructed from lattices with \\(2n\\)-dimensional full-rank Gram matrices \\(A\\).\n\nThe centralizer for the stabilizer group within the displacement operators case can be identified with the symplectic dual lattice \\({\\mathcal{L}}^{\\perp}\\) (i.e. all points in \\(\\mathbb{R}^{2n}\\) that have integer symplectic inner product with all points in \\({\\mathcal{L}}\\) ), such that logical operations are identified with the dual quotients \\({\\mathcal{L}}^{\\perp}/{\\mathcal{L}}\\). The size of this dual quotient is the determinant of the Gram matrix, yielding the logical dimension \\(d=\\sqrt{\\| \\det{A}\\|}\\) \\cite{arXiv:quant-ph/0008040}.\n","protection":"The level of protection against displacement errors is quantified by the Euclidean code distance \\(\\Delta=\\min_{x\\in {\\mathcal{L}}^{\\perp}\\setminus {\\mathcal{L}}} \\|x\\|_2\\) \\cite{arXiv:2109.14645}.","features":{"rate":"Transmission schemes with multimode GKP codes achieve, up to a constant-factor offset, the capacity of displacement-noise and thermal-noise Gaussian loss channels \\cite{arXiv:quant-ph/0105058,arXiv:1708.07257,arXiv:1801.04731,arXiv:1801.07271}. Particular random lattice families of multimode GKP codes achieve the hashing bound of the displacement noise channel \\cite{arxiv:quant-ph/0105058}.","encoders":["GKP codes with fixed \\(n\\) and prime-dimensional logical Hilbert space are symplectically related to a disjoint product of single-mode GKP codes on \\(n\\) modes, such that encoding via Gaussian unitaries is possible.","Dissipative stabilization of finite-energy GKP states using stabilizers conjugated by \\textit{cooling} (\\cite{arxiv:1310.7596}, Appx. B) or \\textit{damping} operator, i.e., a damped exponential of the total occupation number \\cite{arXiv:2009.07941,arxiv:2201.12337}."],"general_gates":["By applying GKP error correction to Gaussian input states, universality can be achieved without non-Gaussian elements \\cite{arXiv:1903.00012}."],"fault_tolerance":["Logical Clifford operations are given by Gaussian unitaries, which map bounded-size errors to bounded-size errors \\cite{arXiv:quant-ph/0008040}."],"decoders":["The MLD decoder for Gaussian displacement errors is realized by evaluating a lattice theta function, and in general the decision can be approximated by either solving (approximating) the closest vector problem (CVP) or by using other effective iterative schemes when e.g. the lattice represents a concatenated GKP code \\cite{arXiv:1810.00047,arXiv:1908.03579,arXiv:2109.14645,arxiv:2111.07029}.","Closest lattice point decoding \\cite{arxiv:2303.04702}."]},"relations":{"parents":[{"code_id":"quantum_lattice","detail":"GKP codes are \\(n\\)-mode quantum lattice codes with \\(2n\\) stabilizers, i.e., constructed using a non-degenerate lattice."}],"cousins":[{"code_id":"approximate_qecc","detail":"Approximate error-correction offered by GKP codes yields achievable rates that are a constant away from the capacity of Guassian loss channels \\cite{arXiv:quant-ph/0105058,arXiv:1708.07257,arXiv:1801.04731,arXiv:1801.07271}."}]},"_meta":{"changelog":[{"user_id":"JonathanConrad","date":"2022-07-05"},{"user_id":"VictorVAlbert","date":"2022-07-05"},{"user_id":"VictorVAlbert","date":"2022-03-24"}]},"_zoodb":{"id":"multimodegkp","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/multimodegkp.yml","source_file_modification_token":1687727505572.948}},"ntru_gkp":{"code_id":"ntru_gkp","physical":"oscillators","logical":"qudits","name":"NTRU-GKP code","introduced":"\\cite{arxiv:2303.02432}","description":"Multi-mode GKP code whose underlying lattice is utilized in variations of the NTRU cryptosystem \\cite{doi:10.1007/BFb0054868}.\nRandomized constructions yield asymptotically good GKP code families.\n\nThe integer-valued \\(q\\)-symplectic Gram matrix for an \\(n\\)-mode \\(k\\)-qubit good NTRU-GKP code is\n\\begin{align}\n  A = \\sqrt{\\frac{2}{q}}\\begin{pmatrix}I & Q\\\\\n  0 & qI\n  \\end{pmatrix}~,\n\\end{align}\nwhere \\(Q\\) is a circulant matrix constructed from coefficients of a cyclic polynomial used in the NTRU cryptosystem, and \\(I\\) is the \\(n\\)-dimensional identity matrix \\cite[Prop. 2]{arxiv:2303.02432}.\n","features":{"decoders":["Efficient decoder against stochastic displacement noise because the decoding problem is equivalent to decrypting the NTRU cryptosystem."]},"realizations":["Public-key quantum communication protocol \\cite{arxiv:2303.02432}."],"relations":{"parents":[{"code_id":"multimodegkp"},{"code_id":"qudits_into_oscillators"}],"cousins":[{"code_id":"quantum_random","detail":"Several NTRU lattices come from randomized constructions, yielding asymptotically good GKP code families."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-27"}]},"_zoodb":{"id":"ntru_gkp","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/ntru_gkp.yml","source_file_modification_token":1681484685081.0203}},"quantum_lattice":{"code_id":"quantum_lattice","physical":"oscillators","name":"Quantum lattice code","description":"Bosonic stabilizer code on \\(n\\) bosonic modes whose stabilizer group is an infinite countable group of oscillator displacement operators which implement lattice translations in phase space.\n\nDisplacement operators on \\(n\\) modes can be written as\n\\begin{align}\nD(\\xi) = \\exp \\left\\{-i \\sqrt{2\\pi} {\\xi}^\\mathrm{T} J \\hat{q} \\right\\} , \\quad \\xi \\in \\mathbb{R}^{2n}~,\n\\end{align}\nwhere \\(\\hat{q}\\) is a \\(2n\\)-dimensional vector position and momentum operators of the modes, the symplectic form\n\\begin{align}\nJ = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix} \\otimes I_n = \\begin{pmatrix}\n0 &  I_n \\\\\n-I_n  & 0 \\end{pmatrix}~,\n\\end{align}\nand \\(I_n\\) is the identity matrix. A group generated by a set of independent displacement operators is given by a lattice \\({\\mathcal{L}}\\)\n\\begin{align}\n\\langle D(\\xi_1) ,\\dots,  D(\\xi_{m})  \\rangle = \\{ e^{ i \\phi_M (\\xi) } D(\\xi) ~\\vert~ \\xi \\in {\\mathcal{L}} \\}\n\\end{align}\nand becomes a valid stabilizer group when every symplectic inner product between lattice vectors yields an integer. In other words, the corresponding lattice is symplectically integral, corresponding to an integer-valued symplectic Gram matrix \\(A\\),\n\\begin{align}\nA_{ij}={\\xi}^T_i J \\xi_j \\in \\mathbb{Z}~.\n\\end{align}\nThe \\(m=2n\\) case yields multimode GKP codes encoding a finite-dimensional logical subspace, while removing some displacements yields GKP-stabilizer codes encoding an infinite-dimensional logical subspace. Codes defined on a hyper-rectangular lattice are \\textit{CSS GKP} codes, and more general lattices, obtained by Gaussian transformations, yield non-CSS codes.\n","notes":["Quantum lattice states have been introduced in quantum foundations research defining modular conjugate variables \\cite{doi:10.1007/BF00670008} and in coherent-state theory associated with the Heisenberg-Weyl group \\cite{manual:{Cartier, Pierre. \"Quantum mechanical commutation relations and theta functions.\" Proc. Sympos. Pure Math. Vol. 9. 1966.}}\\cite{doi:10.1007/BF01077648}\\cite[Sec. 1.5 and 3.2]{doi:10.1007/978-3-642-61629-7}. They are featured in the proof of hardness of LWE \\cite[pg. 12]{doi:10.1145/1568318.1568324}. The basis formed by quantum lattice states is known as the Zak basis, Weil-Brezin transform, or \\(kq\\) representation in condensed-matter physics \\cite{doi:10.1103/PhysRevLett.19.1385} and signal processing \\cite[Ch. 1]{doi:10.1007/978-1-4612-2016-9}\\cite[Eq. (1.112)]{doi:10.1515/9781400882427}."],"relations":{"parents":[{"code_id":"oscillator_stabilizer","detail":"Quantum lattice codes are bosonic stabilizer codes with a countably infinite stabilizer group, corresponding to modular constraints on positions and momenta."},{"code_id":"coherent_constellation","detail":"Quantum lattice codewords can be written as superpositions of coherent states lying on a lattice in phase space \\cite{arXiv:quant-ph/0008040,arxiv:1708.05010}."}],"cousins":[{"code_id":"points_into_lattices","detail":"Quantum lattice codes can be thought of as quantum lattice codes because they store information in quantum superpositions of points on a lattice in quantum phase space."},{"code_id":"css","detail":"Quantum lattice codes defined on rectangular lattices are CSS codes. There is no known relation to chain complexes for such codes. More general lattices, obtained from rectangular lattices by Gaussian transformations, yield non-CSS codes."}]},"_meta":{"changelog":[{"user_id":"JonathanConrad","date":"2022-07-05"},{"user_id":"VictorVAlbert","date":"2022-07-05"},{"user_id":"VictorVAlbert","date":"2022-03-24"}]},"_zoodb":{"id":"quantum_lattice","source_file_path":"codes/quantum/oscillators/stabilizer/lattice/quantum_lattice.yml","source_file_modification_token":1687727505573.1147}},"oscillator_stabilizer":{"code_id":"oscillator_stabilizer","physical":"oscillators","name":"Bosonic stabilizer code","introduced":"\\cite{arxiv:quant-ph/0405064}","description":"Also known as a \\textit{continuous-variable (CV) stabilizer code}. Bosonic code whose codespace is defined as the common \\(+1\\) eigenspace of a group of mutually commuting displacement operators.\nDisplacements form the stabilizers of the code, and have continuous eigenvalues, in contrast with the discrete set of eigenvalues of qubit stabilizers.\nAs a result, exact codewords are non-normalizable, so approximate constructions have to be considered.\n\nStabilizer codewords encoding a finite-dimensional codespace admit a discrete infinite stabilizer group and encode quantum information in a lattice.\nSuch \\hyperref[code:qudits_into_oscillators]{qudit-into-oscillator} stabilizer codes are \\hyperref[code:gkp]{GKP} and \\hyperref[code:multimodegkp]{multimode GKP} codes.\n\nStabilizer codewords encoding a logical oscillator (i.e., CV quantum information) admit either a discrete or a continuous stabilizer group.\nThe former, called GKP-stabilizer codes, are obtained from multimode GKP codes by removing stabilizer generators for some of the modes.\nThe latter encode information in hyperplanes and can be defined in terms of the continuous group's Lie algebra, i.e., as the common \\(0\\)-eigenvalue eigenspace of mutually commuting linear combinations of oscillator position and momentum operators called \\textit{nullifiers} \\cite{arxiv:0903.3233} or \\textit{annihilators}. An \\hyperref[code:oscillators_into_oscillators]{oscillator-into-oscillator} stabilizer code encoding \\(k\\) logical modes into \\(n\\) physical modes is denoted as \\([[n,k,d]]_{\\mathbb{R}}\\), where \\(d\\) is the code's distance.\n","protection":"Protective properties can be delineated in terms of the nullifiers or displacements, and the most natural noise model for such codes is displacement noise. If an error operator does not commute with a stabilizer group element, then that error is detectable. Oscillator-into-oscillator stabilizer codes protect against erasures of a subset of modes, while GKP codes protect against sufficiently small displacements in any number of modes.","relations":{"parents":[{"code_id":"oscillators"},{"code_id":"stabilizer"}],"cousins":[{"code_id":"css","detail":"An oscillator stabilizer code admitting a set of generators such that each generator consists of either position or momentum operators is a CSS code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-05"},{"user_id":"VictorVAlbert","date":"2022-03-24"}]},"_zoodb":{"id":"oscillator_stabilizer","source_file_path":"codes/quantum/oscillators/stabilizer/oscillator_stabilizer.yml","source_file_modification_token":1681484685081.1772}},"approximate_qecc":{"code_id":"approximate_qecc","name":"Approximate quantum error-correcting code (AQECC)","short_name":"AQECC","introduced":"\\cite{arxiv:quant-ph/9704002,doi:10.1070/RM1997v052n06ABEH002155,arXiv:quant-ph/0307138,arXiv:quant-ph/0503139,arXiv:0907.4207,arXiv:0907.5391,arxiv:1706.09434}","description":"Encodes quantum information so that it is possible to approximately recover that information from noise up to an error bound in recovery.","protection":"\\subsection{Universal subspace approximate error correction}\nUniversal subspace approximate error correction is a type of approximate error correction that quantifies protection of information stored in subspaces of a logical space.\n\nGiven a subspace of a Hilbert space \\(\\mathsf{S}\\) of dimension \\(d\\), noise channel \\(\\mathcal{N}\\), and encoding \\(\\mathcal{E}\\), we define the subspace as an \\textit{\\(\\alpha\\)-dit} with error \\(\\epsilon\\) if, for all subspaces \\(\\tilde{\\mathsf{S}}\\) of dimension less than or equal to \\(d^{\\alpha}+1\\),\nthere exists some channel \\(\\tilde{\\mathcal{D}}\\) such that\n\\begin{align}||(\\tilde{\\mathcal{D}}\\circ \\mathcal{N}\\circ \\mathcal{E})|\\psi\\rangle-|\\psi\\rangle||_1\\leq \\epsilon\\end{align}\nforall \\(|\\psi\\rangle\\in \\tilde{\\mathsf{S}}\\)~\\cite{arXiv:1706.09434}.\nSee Ref. \\cite{arxiv:1610.06169} for bounds on approximate code length, size, and distance.\n","features":{"encoders":["Given a decoder, an encoding that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program \\cite{arXiv:quant-ph/0109155,arXiv:quant-ph/0307138} (see also Ref. \\cite{arXiv:0706.3400}).","Variational quantum circuit encoder \\cite{arxiv:2204.03560}."],"decoders":["Given an encoding, a decoder that yields the optimal entanglement fidelity can be obtained by solving a semi-definite program \\cite{arXiv:quant-ph/0109155,arXiv:quant-ph/0307138} (see also Ref. \\cite{arXiv:0706.3400}).","The \\textit{Petz recovery map} (a.k.a. the \\textit{transpose map}) \\cite{doi:10.1007/BF01212345,doi:10.1093/qmath/39.1.97}, a quantum channel determined by the codespace and noise channel, recovers information perfectly for strictly correctable noise and yields an infidelity of recovery that is at most twice away from the infidelity of the best possible recovery \\cite{arXiv:quant-ph/0004088}. The infidelity of a modified Petz recovery map can be bounded using relative entropies between uncorrupted and corrupted code states on countably infinite Hilbert spaces \\cite{arxiv:1509.07127}."]},"notes":["See review \\cite{arxiv:2208.00365}."],"relations":{"parents":[{"code_id":"qecc"},{"code_id":"approximate_oaecc"}]},"_meta":{"changelog":[{"user_id":"M10T","date":"2023-06-28"},{"user_id":"M10T","date":"2023-06-22"},{"user_id":"M10T","date":"2023-06-20"},{"user_id":"VictorVAlbert","date":"2022-08-12"},{"user_id":"PhilippeFaist","date":"2022-07-15"},{"user_id":"VictorVAlbert","date":"2021-12-05"},{"user_id":"ManasiShingane","date":"2021-12-05"}]},"_zoodb":{"id":"approximate_qecc","source_file_path":"codes/quantum/properties/approximate_qecc.yml","source_file_modification_token":1689550329218.4448}},"block_quantum":{"code_id":"block_quantum","name":"Block quantum code","description":"A code constructed in a physical space consisting of a tensor product of \\(n\\) identical subsystems, e.g., qubits, modular qudits, Galois qudits, or oscillators.\n","protection":"Block codes protect from errors acting on a few of the \\(n\\) subsystems. A block code with \\textit{distance} \\(d\\) detects errors acting on up to \\(d-1\\) subsystems, and corrects erasure errors on up to \\(d-1\\) subsystems.\n","features":{"transversal_gates":"\\textit{Transversal gates} are logical gates on block codes that can be realized as tensor products of unitary operations acting on subsets of subsystems whose size is independent of \\(n\\). When the subsets are of size one and the single-subsystem unitaries are identical, then the gates are sometimes called \\textit{strongly transversal}."},"relations":{"parents":[{"code_id":"qecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-14"}]},"_zoodb":{"id":"block_quantum","source_file_path":"codes/quantum/properties/block/block_quantum.yml","source_file_modification_token":1677058672665.3267}},"covariant":{"code_id":"covariant","name":"Covariant code","introduced":"\\cite{arxiv:1709.04471}","description":"A block code on \\(n\\) subsystems that admits a group \\(G\\) of transversal gates. The group has to be finite for finite-dimensional codes due to the Eastin-Knill theorem. Continuous-\\(G\\) covariant codes, necessarily infinite-dimensional, are relevant to error correction of quantum reference frames \\cite{arxiv:1709.04471} and error-corrected parameter estimation.\n\nDenoting the code's encoding map as \\(U\\), covariance is equivalent to\n\\begin{align}\n  \\left(\\bigotimes_{j=1}^{n}V_{j}\\left(g\\right)\\right)U=UV_{L}\\left(g\\right)\\quad\\quad\\forall g\\in G\\,,\n\\end{align}\nwhere \\(V_j(g)\\) is a unitary representation of \\(g\\) acting on the \\(j\\) subsystem, and \\(V_L\\) is a unitary representation acting on the unencoded logical information.\nIn this way, covariant encoding maps are equivariant (i.e., commute) with group actions on the logical and physical spaces.\n\nAlmost always, the physical representation is defined to be the transversal one (with respect to some tensor-product decomposition), but can reduce to any representation when the code is a subspace of a larger space that is not expressed as a tensor product (\\(n=1\\)). More generally, a code is sometimes said to be \\textit{time-covariant} if it admits a continuous-parameter \\(U(1)\\) family of gates, not necessarily transversal \\cite{arxiv:2207.13707}.\n","protection":"Finite-dimensional codes correcting a single-subsystem erasure and admitting a continuous-parameter family of transversal gates (assuming \\(n>1\\)) cannot exist in finite\ndimensions due to the Eastin-Knill theorem. As a result, there is generally a tradeoff between covariance and error correction.\n\nExact error-correcting \\(G\\)-covariant codes can exist in infinite dimensions, but their codewords are non-normalizable, meaning that approximate constructions have to be considered that are only approximately error correcting.\nOn the other hand, there exist exact error-correcting codes in finite dimensions that are approximately covariant \\cite{arxiv:2111.06360,arxiv:2111.06355}.\nVarious bounds quantify the covariance-performance tradeoff \\cite{arxiv:1902.07714,arxiv:2005.11918,arxiv:2004.11893,arxiv:2111.06360,arxiv:2111.06355}.\n","features":{"transversal_gates":"\\(G\\)-covariant codes defined on a tensor product space consisting of \\(n\\) subsystems are equivalent to codes with a transversal gate set realizing \\(G\\)."},"relations":{"parents":[{"code_id":"block_quantum","detail":"Covariant codes for \\(n>1\\) are block quantum codes."}],"cousins":[{"code_id":"approximate_qecc","detail":"Normalizable constructions of infinite-dimensional \\(G\\)-covariant codes for continuous \\(G\\) are approximately error-correcting."},{"code_id":"quantum_reed_muller","detail":"Quantum RM codes are approximately covariant and nearly saturate certain covariance-performance bounds \\cite{arxiv:2111.06360}."},{"code_id":"eth","detail":"ETH codes consisting of Dicke states are approximately \\(U(1)\\)-covariant and nearly saturate certain covariance-performance bounds \\cite{arxiv:1902.07714,arxiv:2111.06360}."},{"code_id":"quantum_random","detail":"Random \\(U(d)\\)-covariant almost exactly error-correcting codes exist \\cite{arxiv:1902.07714,arxiv:2112.01498}."},{"code_id":"group_gkp","detail":"Group-GKP codes corresponding to the \\(G^{k_1} \\subseteq G^{k_2} \\subset G^{n}\\) group construction admit \\(X\\)-type transversal Pauli gates that represent the group \\(G\\), and are thus \\(G\\)-covariant \\cite{arxiv:1902.07714}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-30"},{"user_id":"JackDavis","date":"2022-04-02"}]},"_zoodb":{"id":"covariant","source_file_path":"codes/quantum/properties/block/covariant/covariant.yml","source_file_modification_token":1680994436848.067}},"g_covariant_erasure":{"code_id":"g_covariant_erasure","name":"\\(G\\)-covariant erasure code","introduced":"\\cite{arxiv:1709.04471}","description":"A \\(G\\)-covariant block code that serves as a proof-of-principle construction to demonstrate the existence of\n\\hyperref[code:covariant]{\\(G\\)-covariant codes} where \\(G\\) is a finite\ngroup, and the physical space is finite-dimensional.\nThis construction can be done for any erasure-correcting code.\n\nConsider a finite group \\(G\\) acting on a finite set\n\\(A\\) as a subgroup of the symmetric group on \\(|A|\\) elements, \\(G \\subset S_{|A|}\\).\nLet \\(U_0: \\mathsf{H}_{\\text{logical}} \\rightarrow \\mathsf{H}_{\\text{physical}}\n= \\mathsf{H}^{\\otimes n}\\) be any QECC, possibly non-covariant.  Define the covariant\nencoder \\(U \\equiv U_0^{\\otimes |A|}: \\mathsf{H}_{\\text{logical}}^{\\otimes |A|}\n\\rightarrow \\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\) on \\(|A|\\).  Then, the group acts on codewords by index\npermutation:\n\\begin{align}\nV(g) | \\phi_{a_1} \\rangle | \\phi_{a_2} \\rangle \\cdots | \\phi_{a_{|A|}} \\rangle = | \\phi_{g^{-1} a_1} \\rangle | \\phi_{g^{-1} a_2} \\rangle \\cdots | \\phi_{g^{-1} a_{|A|}} \\rangle~,\n\\end{align}\nwhere \\(V(g)\\) is the unitary representation of \\(g \\in G\\) acting on the physical space. The action of \\(V(g)\\) is transversal with respect to the partition \\(\\mathsf{H}_{\\text{physical}}^{\\otimes |A|}\\).\n","protection":"Depends on the base encoding \\(U_0\\).\n","relations":{"parents":[{"code_id":"covariant","detail":"In a proof of principle demonstration, error-correcting codes that are finite-\\(G\\) covariant can be constructed from a base encoding \\(U_0\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-27"},{"user_id":"JackDavis","date":"2022-04-02"}]},"_zoodb":{"id":"g_covariant_erasure","source_file_path":"codes/quantum/properties/block/covariant/g_covariant-erasure.yml","source_file_modification_token":1678726895516.4592}},"metopt":{"code_id":"metopt","name":"Error-corrected sensing code","introduced":"\\cite{arxiv:1704.06280,arxiv:1706.02445}","description":"Code that can be obtained via an optimization procedure that ensures correction against a set \\(\\cal{E}\\) of errors as well as guaranteeting optimal precision in locally estimating a parameter using a noiseless ancilla. For tensor-product spaces consisting of \\(n\\) subsystems (e.g., qubits, modular qudits, or Galois qudits), the procedure can yield a code whose parameter estimation precision satisfies \\textit{Heisenberg scaling}, i.e., scales quadratically with the number \\(n\\) of subsystems.\n\nThe conditions required for a code are that it corrects errors in the set \\(\\cal{E}\\) and admits a continuous-parameter \\(U(1)\\) group of logical gates generated by some \\textit{signal Hamiltonian} \\(H\\) (with the time of evolution by \\(H\\) the parameter that is to be estimated).\nThis means that \\(H\\) cannot itself be a detectable error, i.e., \\(H\\) cannot be expressed as a linear combination of the errors, a condition known as the \\textit{Hamiltonian-not-in-Kraus-span} condition \\cite{arxiv:2003.10559} (alternatively, Hamiltonian-not-in-Lindblad-span for Markovian noise \\cite{arxiv:1706.02445}). If these conditions are satisfied, a semidefinite-program based optimization procedure yields a metrologically optimal code.\nThe procedure has been generalized to more general groups, corresponding to multiparameter estimation \\cite{arxiv:1901.00896}. If these conditions are not satisfied, Heisenberg scaling is not achievable, but metrologically optimal codes can still be obtained via another semidefinite-program based optimization procedure \\cite{arxiv:1910.08472,arxiv:2003.10559}.\n\nMetrologically optimal QECCs require error-free ancillas for optimal local parameter estimation using an entangling gate. In this sense, such codes can be thought of as being entanglement-assisted.\n\\textit{Ancilla-free} versions exist in the case when the noise commutes with the signal Hamiltonian \\cite{arxiv:1811.01450,arxiv:2303.00881}.\n","relations":{"parents":[{"code_id":"qecc_finite","detail":"Semidefinite-program optimization procedure for finding a metrologically optimal code holds for finite-dimensional spaces."}],"cousins":[{"code_id":"eaqecc","detail":"Metrologically optimal codes can be thought of as being entanglement-assisted because they require error-free ancillas for optimal local parameter estimation, and the estimation procedure uses an entangling gate."},{"code_id":"hamiltonian","detail":"Metrologically optimal codes admit a \\(U(1)\\) set of gates generated by a signal Hamiltonian \\(H\\), meaning that there exists a basis of codewords that are eigenstates of the \\(H\\)."}]},"_meta":{"changelog":[{"user_id":"SisiZhou","date":"2022-07-28"},{"user_id":"VictorVAlbert","date":"2022-07-28"}]},"_zoodb":{"id":"metopt","source_file_path":"codes/quantum/properties/block/covariant/metopt.yml","source_file_modification_token":1678631058736.7446}},"nonabelian_covariant_erasure":{"code_id":"nonabelian_covariant_erasure","name":"\\(U(d)\\)-covariant approximate erasure code","introduced":"\\cite{arxiv:2007.09154}","description":"Covariant code whose construction takes in an arbitrary erasure-correcting code to yield an approximate QECC that is also covariant with respect to the unitary group.\n","relations":{"parents":[{"code_id":"covariant"},{"code_id":"approximate_qecc"}],"cousins":[{"code_id":"stab_5_1_3","detail":"The five-qubit code can be used to construct an approximate code that is also covariant with respect to the unitary group."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-26"}]},"_zoodb":{"id":"nonabelian_covariant_erasure","source_file_path":"codes/quantum/properties/block/covariant/nonabelian_covariant_erasure.yml","source_file_modification_token":1678726895516.5852}},"w_state":{"code_id":"w_state","logical":"qudits","physical":"qudits","name":"W-state code","introduced":"\\cite{arXiv:1902.07714}","description":"Encodes a quantum state of a \\(d_L\\)-dimensional Hilbert space into\n\\(n\\) physical quantum systems, each associated with a Hilbert space\nof dimension \\(d_L+1\\).  The encoding resembles the structure of the\nW state~\\cite{arXiv:quant-ph/0005115}:\n\\begin{align}\n  \\ket\\psi\n  \\to \\frac{1}{\\sqrt{n}}\\bigl(\\ket{\\psi\\perp\\perp\\ldots}\n  + \\ket{\\perp\\psi\\perp\\ldots} + \\cdots\n  + \\ket{\\perp\\perp\\ldots\\psi}\\bigr)\\ ,\n\\end{align}\nwhere on each physical system, \\(\\ket\\perp\\) denotes the \\((d_L+1)\\)-th basis state\nand \\(\\ket\\psi\\) is encoded using the first \\(d_L\\) basis states.\n\nThis code enables universal quantum computation with transversal gates.  Indeed,\nto apply any logical unitary \\(U\\) it suffices to apply \\(U\\) on each physical system,\nwhere the unitary is taken to act nontrivially only on the \\(d_L\\) first basis states\nof each system.  Universal computation with transversal gates does not violate the\nEastin-Knill theorem because this code is an approximate error-correcting\ncode~\\cite{arXiv:1709.04471,arXiv:1902.07714} rather than an exact error-correcting\ncode.","protection":"The W state code is an approximate error-correcting code.  Intuitively, if a\nsubsystem is lost to the environment, the environment only gains access to\n\\(\\ket\\psi\\) with probability of order \\(1/n\\).  Under a single located erasure,\nthe worst-cast entanglement infidelity of the W state code can be upper bound as\n\\begin{align}\n  \\epsilon_{\\mathrm{worst}} \\leq \\frac{\\sqrt{2} + d_L}{\\sqrt{n}}\\ .\n\\end{align}\n\nIn contrast to the \\ref{code:eth}, the W state code does not saturate the scaling\n\\(1/n\\) in worst-case entanglement infidelity which is known to be\noptimal for covariant approximate error-correcting codes~\\cite{arXiv:1902.07714}.","features":{"transversal_gates":"All logical gates can be implemented transversally. The logical unitary \\(U_L\\) can be\nperformed with the physical unitary \\(U_L\\otimes U_L\\otimes\\cdots\\otimes U_L\\), where on\nthe physical space \\(U_L\\) is taken to act trivially on \\(\\ket\\perp\\), i.e.,\n\\( U_L\\ket\\perp = \\ket\\perp\\)."},"relations":{"parents":[{"code_id":"covariant","detail":"The W-state code approximately protects against a single erasure while allowing for a universal transversal set of gates."},{"code_id":"approximate_qecc","detail":"The W-state code approximately protects against a single erasure while allowing for a universal transversal set of gates."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-18"},{"user_id":"PhilippeFaist","date":"2022-08-18"}]},"_zoodb":{"id":"w_state","source_file_path":"codes/quantum/properties/block/covariant/w_state.yml","source_file_modification_token":1678726895516.684}},"quantum_mds":{"code_id":"quantum_mds","name":"Quantum maximum-distance-separable (MDS) code","short_name":"Quantum MDS","description":"An \\(((n,q^k,d))\\) code constructed out of \\(q\\)-dimensional qudits is an MDS code if parameters \\(n\\), \\(k\\), \\(d\\), and \\(q\\) are such that the quantum Singleton bound\n\\begin{align}\n2(d-1) \\leq n-k\n\\end{align}\nbecomes an equality.\n","protection":"Given \\(n\\) and \\(k\\), MDS codes have the highest distance possible of all codes and so have the best possible error correction properties.","notes":["See Ref. \\cite{doi:10.1017/CBO9781139034807.014} for an overview of quantum MDS codes."],"relations":{"parents":[{"code_id":"block_quantum"},{"code_id":"qecc_finite"}],"cousins":[{"code_id":"mds"},{"code_id":"q-ary_cyclic","detail":"Quantum MDS codes can be constructed from \\(q\\)-ary cyclic codes using the Hermitian construction \\cite{doi:10.1109/TIT.2011.2159039}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"},{"user_id":"VictorVAlbert","date":"2022-01-10"},{"user_id":"QingfengKeeWang","date":"2021-12-20"}]},"_zoodb":{"id":"quantum_mds","source_file_path":"codes/quantum/properties/block/quantum_mds.yml","source_file_modification_token":1681484685082.3093}},"quantum_perfect":{"code_id":"quantum_perfect","name":"Perfect quantum code","description":"A non-degenerate code constructed out of \\(q\\)-dimensional qudits and having parameters \\(((n,K,2t+1))\\) is perfect if \\(n\\), \\(K\\), \\(t\\), and \\(q\\) are such that the quantum Hamming bound\n\\begin{align}\n\\sum_{j=0}^{t}(q^2-1)^{j}{n \\choose j}\\leq q^{n}/K\n\\end{align}\nbecomes an equality.\nFor example, for a qubit \\(q=2\\) code with one logical qubit (\\(K=2\\)) and \\(t=1\\), the bound becomes \\(3n+1 \\leq 2^{n-1}\\).\nThe bound can be saturated only at certain \\(n\\).\n\nFor qubit codes with \\(K=2^k\\), one can work out an asymptotic Hamming bound in the large-\\(n,k,t\\) limit,\n\\begin{align}\n\\frac{k}{n}\\leq 1-\\frac{t}{n}\\log_{2}3-h(t/n),\n\\end{align}\nwhere \\(h\\) is the binary entropy function.\n\nA quantum Hamming-like bound exists for degenerate qubit stabilizer codes \\cite{arxiv:2306.00048}.\n","protection":"Perfect codes have been classified. For qubits (\\(q=2\\)), the only codes are the stabilizer code family \\([[(4^r-1)/3, (4^r-1)/3 - 2r, 3]]\\) for \\(r \\geq 2\\) \\cite{arxiv:quant-ph/9607027,arxiv:quant-ph/9608006}. For qudits, the family is parameterized by \\(K=q^{n-2r}\\) for \\(n=\\frac{q^{2r}-1}{q^{2}-1}\\) and \\(r \\geq 2\\); all codes correct a single error (\\(t=1\\)) \\cite{arxiv:0907.0049,doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T}. The trivial code (\\(k=n\\)) is also perfect.\n","features":{"rate":"\\(k/n\\to 1\\) asymptotically with \\(n\\)."},"notes":["Codes that are not non-degenerate can in principle violate the quantum Hamming bound. It was shown that qubit stabilizer codes up to distance \\(d\\leq 85\\) must obey the bound \\cite{arxiv:2208.11800}."],"relations":{"parents":[{"code_id":"block_quantum"},{"code_id":"qecc_finite"}],"cousins":[{"code_id":"perfect","detail":"A classical (quantum) perfect code saturates the classical (quantum) Hamming bound."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-26"},{"user_id":"MazinKarjikar","date":"2022-06-03"},{"user_id":"VictorVAlbert","date":"2021-12-03"}]},"_zoodb":{"id":"quantum_perfect","source_file_path":"codes/quantum/properties/block/quantum_perfect.yml","source_file_modification_token":1687727505573.3423}},"single_shot":{"code_id":"single_shot","name":"Single-shot code","introduced":"\\cite{arxiv:1404.5504}","description":"A block quantum code admitting a fault-tolerant error-correcting protocol against noisy syndrome measurements that requires a number of error-correcting rounds that is independent of the number of subsystems \\(n\\).\n","relations":{"parents":[{"code_id":"block_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-02"}]},"_zoodb":{"id":"single_shot","source_file_path":"codes/quantum/properties/block/single_shot.yml","source_file_modification_token":1683723710997.7427}},"small_distance":{"code_id":"small_distance","name":"Small-distance block quantum code","description":"A block code on \\(n\\) subsystems that either detects or corrects errors on only a single subsystem. These two cases correspond to distance \\(d=2\\) or \\(d=3\\) block quantum codes, respectively.\n\nAll single error-correcting qubit stabilizer codes have been classified \\cite{arxiv:0901.1968}. See Ref. \\cite{arxiv:quant-ph/9704043} for single error-detecting qubit stabilizer codes.\n","relations":{"parents":[{"code_id":"block_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-01"}]},"_zoodb":{"id":"small_distance","source_file_path":"codes/quantum/properties/block/small_distance.yml","source_file_modification_token":1679678315321.4504}},"permutation_invariant":{"code_id":"permutation_invariant","name":"Permutation-invariant code","introduced":"\\cite{arXiv:quant-ph/0304153}","description":"Block quantum code such that any permutation of the subsystems leaves any codeword invariant. In other words, the automorphism group of the code contains the symmetric group \\(S_n\\).","protection":"Depends on the family. The GNU permutation-invariant family (parameterized by \\(t\\)) protects against arbitrary weight \\(t\\) qubit errors and approximately corrects spontaneous decay errors \\cite{arXiv:1302.3247,doi:10.1103/PhysRevA.93.042340}. Other related codes protect against amplitude damping \\cite{doi:10.1109/TIT.2019.2956142} while admitting a constant number of excitations, and against deletion errors \\cite{arxiv:2102.02494,arXiv:2102.03015}.","features":{"encoders":["With quantum harmonic oscillators (superconducting charge qubits in a ultrastrong coupling regime) in \\(O(N)\\) as in \\cite{doi:10.1103/PhysRevA.99.012335}. Can be done in \\(O(N^2)\\) steps using quantum circuits \\cite{arXiv:1904.07358}, or using geometric phase gates in \\(O(N)\\) \\cite{arxiv:1908.01120}."],"decoders":["For a family of codes, using projection, probability amplitude rebalancing, and gate teleportation can be done in \\(O(N^2)\\) \\cite{arXiv:2102.02494}."]},"notes":["Can be constructed using real polynomials for high-dimensional qudit spaces \\cite{doi:10.1016/j.laa.2017.06.031}."],"relations":{"parents":[{"code_id":"quantum_cyclic","detail":"The cyclic group of these codes is a subgroup of the \\(S_n\\) symmetric group used in permutation invariant codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-26"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"BenjaminQuiring","date":"2021-12-16"}]},"_zoodb":{"id":"permutation_invariant","source_file_path":"codes/quantum/properties/block/symmetric/permutation_invariant.yml","source_file_modification_token":1681805027419.0771}},"quantum_cyclic":{"code_id":"quantum_cyclic","name":"Cyclic quantum code","introduced":"\\cite{arXiv:1007.1697}","description":"A block quantum code such that cyclic permutations of the subsystems leave the codespace invariant. In other words, the automorphism group of the code contains the cyclic group \\(\\mathbb{Z}_n\\).","protection":"Cyclic symmetry guarantees that if a single subsystem is protected against some noise, then all other subsystems are also.","features":{"decoders":["Adapted from the Berlekamp decoding algorithm for classical BCH codes \\cite{arXiv:1007.1697}."]},"notes":["Many examples have been found by computer algebra programs. Ref. \\cite{arXiv:1007.1697} give examples of \\([[17,1,7]]\\) and \\([[17,9,3]]\\) quantum cyclic codes."],"relations":{"parents":[{"code_id":"quantum_quasi_cyclic"}],"cousins":[{"code_id":"cyclic"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"NolanCoble","date":"2021-12-15"}]},"_zoodb":{"id":"quantum_cyclic","source_file_path":"codes/quantum/properties/block/symmetric/quantum_cyclic.yml","source_file_modification_token":1681805027419.2808}},"quantum_quasi_cyclic":{"code_id":"quantum_quasi_cyclic","name":"Quasi-cyclic quantum code","introduced":"\\cite{arXiv:quant-ph/0701020}","description":"A block code on \\(n\\) subsystems such that cyclic shifts of the subsystems by \\(\\ell\\geq 1\\) leave the codespace invariant.","relations":{"parents":[{"code_id":"block_quantum"}],"cousins":[{"code_id":"quasi_cyclic"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-10-19"}]},"_zoodb":{"id":"quantum_quasi_cyclic","source_file_path":"codes/quantum/properties/block/symmetric/quantum_quasi_cyclic.yml","source_file_modification_token":1687727505573.462}},"holographic":{"code_id":"holographic","name":"Holographic code","introduced":"\\cite{arxiv:1503.06237}","description":"Block quantum code whose encoding isometry serves to model aspects of the AdS/CFT holographic duality.\nEncoding map models radial time evolution for a fixed time slice in Anti de Sitter (AdS) space, mapping operators in the bulk of AdS, represented by logical qudits, onto operators on the boundary of the corresponding Conformal Field Theory (CFT), represented by physical qudits.\nEncoding can often be represented by a tensor network associated with a tiling of hyperbolic space. See Defn 4.3 of Ref. \\cite{arxiv:2108.11402} for a technical formulation.\n\nTypically, the encoding isometry \\(U\\) obeys the \\textit{entanglement-wedge reconstruction condition}, which states that for any boundary region \\(R\\), any bulk operator \\(O\\) localized to the entanglement wedge of \\(R\\) must be implementable by some boundary operator \\(\\tilde{O}\\) localized to \\(R\\). Formally, \\(UO = \\tilde{O}U\\) and \\([\\tilde{O},UU^\\dagger] = 0\\). The entanglement wedge is the space enclosed within the Ryu–Takayanagi surface in the bulk (minimal surface) with boundary \\(R\\).\n","protection":"Protects against erasure errors on the boundary. Error-correction properties are often stated in the Heisenberg picture, i.e., in terms of which logical operators can be \\textit{reconstructed} after erasures. Specifically, bulk operators outside the entanglement wedges of the erased boundary operators can be reconstructed using the remaining boundary operators. However, the protection can be nontrivial, and may only apply to a subalgebra of bulk operators \\cite{arxiv:1411.7041,arXiv:1612.00017}.","features":{"transversal_gates":"There exist holographic approximate codes with arbitrary transversal gate sets for any compact Lie group \\cite{arxiv:2108.11402}. However, for sufficiently localized logical subsystems of holographic stabilizer codes, the set of transversally implementable logical operations is contained in the Clifford group \\cite{arXiv:2103.13404}.","code_capacity_threshold":["The ideal holographic code (perfect representation of AdS/CFT) should be able to protect a central bulk operator against erasures of half of the physical qubits on the boundary, in line with AdS-Rindler reconstruction \\cite{arxiv:1503.06237}.","Holographic codes are argued to have a \\textit{algebraic threshold}, for which the error rate scales polynomially (as opposed to exponentially) in the thermodynamic limit \\cite{arxiv:2202.04710}. Such a threshold is governed by the underlying conformal field theory describing the boundary."]},"notes":["All Boundary global symmetries must be dual to bulk gauge symmetries, and vice versa \\cite{arxiv:1810.05338}."],"relations":{"parents":[{"code_id":"quantum_lego","detail":"Quantum Lego codes codes whose encoders are tensor networks discretizing hyperbolic space can be thought of as holographic codes. More generally, tensor-network codes are types of LEGO codes made from stabilizer codes where logical and physical legs are pre-assigned and logical legs are not contracted. In other words, logical legs resulting from the conversion of codes to tensors must remain logical in the final tensor network, and the same for physical. Contracting logical legs is another word for gluing two logical legs together."}],"cousins":[{"code_id":"approximate_qecc","detail":"Universal subspace approximate error correction is used to model black holes \\cite{arxiv:1807.06041}."},{"code_id":"approximate_oaecc","detail":"Properties of holographic codes are often quantified in the Heisenberg picture, i.e., in terms of operator algebras \\cite{arxiv:1411.7041,arXiv:1612.00017}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-08"},{"user_id":"JoelRajakumar","date":"2021-12-20"}]},"_zoodb":{"id":"holographic","source_file_path":"codes/quantum/properties/block/tensor_network/holographic.yml","source_file_modification_token":1689550329218.7285}},"quantum_lego":{"code_id":"quantum_lego","name":"Quantum Lego code","introduced":"\\cite{arxiv:2109.08158}","description":"Block quantum code constructed using a tensor-network-based graphical framework from \\textit{quantum lego blocks}, which are smaller quantum codes over qubits or qudits. The class of codes constructed using the framework depends on the choice of atomic lego blocks.\n\nThe individual lego blocks and resulting quantum lego codes can be stabilizer or non-stabilizer. However, both the logical and physical degrees of freedom must have the same local dimension.\n\nFor example, any stabilizer code can be built out of atomic blocks like the 2-site repetition code, single-site trivial stabilizer codes, and tensor products of the \\(|0\\rangle\\) state.\nSpecifically, the \\hyperref[code:happy]{HaPPY} holographic code is a quantum Lego code whose atomic Lego block is the \\hyperref[code:stab_5_1_3]{five-qubit perfect} qubit code.\n\nMany known codes can be created using this code''s methods in order to further their understanding, including a 6 qubit implementaion of the generalized Bacon-Shor code, the Toric code, and the \\([[7,1,3]]\\) Steane code. For example, a simple \\( [[4,2,2]] \\) stabilizer code can be written as a rank 6 tensor. Attaching two of these via gluing together one logical leg from each can produce a \\( [[6,4,2]] \\) stabilizer code.\nCode optimization in this framework can be done using reinforcement learning \\cite{arxiv:2305.06378}.\n\nTo construct a Lego code, the encoding map \\(V\\) for each code that is to be used in the construction is converted to a tensor by decomposing it using the formula\n\\begin{align}\nV = \\sum_{i_j} V_{i_1 \\ldots i_{n+k}} | i_{k+1} \\ldots i_{k+n} \\rangle \\langle i_1 \\ldots i_k |~.\n\\end{align}\nWe then look at the codes graphically, treating each \\(i_j\\) as an edge dangling out of the tensor vertex \\(V_{i_1 \\ldots i_{n+k}}\\). These edges are either connected to another tensor vertex's edges or left dangling. If the block codes are stabilizer, then each local tensor has unitary product stabilizers (UPS). The goal is to push each UPS through the tensor network until each dangling edge has only trivial support. Otherwise, a matching value is pushed through the edge and the process is repeated on the next tensor. If a UPS can be pushed through the whole network, then a UPS for the larger network has been found. The dangling legs (edges) and UPS of the whole network can then be converted to physical/logical elements and stabilizers/logical operators for a new quantum code.\n","features":{"encoders":["Unitary-circuit encoding exists for a restricted class of tensor networks contractible via isometries \\cite{arxiv:2109.08158}."],"decoders":["The decoder is created by creating a decoding quantum circuit with dangling legs replaced with input/output wires, and tensors converted to unitary gates. Maximum likelihood decoding can be used when the tensors are stabilizer codes.","Tensor-network decoder when the tensor network is contractible via stabilizer isometries \\cite{arxiv:2009.10329}.","Tensor-network-based decoder when the encoding unitary is known \\cite{arxiv:1312.4578}."]},"relations":{"parents":[{"code_id":"block_quantum"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-25"},{"user_id":"ThomasWrona","date":"2022-05-18"}]},"_zoodb":{"id":"quantum_lego","source_file_path":"codes/quantum/properties/block/tensor_network/quantum_lego.yml","source_file_modification_token":1683978912608.5593}},"fracton":{"code_id":"fracton","name":"Fracton code","description":"A code whose codewords make up the ground-state space of a fracton-phase Hamiltonian.","protection":"","relations":{"parents":[{"code_id":"qldpc","detail":"Fracton codes admit geometrically local stabilizer generators on a cubic lattice."}],"cousins":[{"code_id":"topological","detail":"Fracton phases can be understood as topological defect networks, meaning that they can be described in the language of topological quantum field theory with defects \\cite{arXiv:2002.05166,arxiv:2112.14717}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-05"}]},"_zoodb":{"id":"fracton","source_file_path":"codes/quantum/properties/block/topological/fracton.yml","source_file_modification_token":1687727505573.5674}},"topological":{"code_id":"topological","name":"Topological code","introduced":"\\cite{arxiv:quant-ph/9707021}","description":"A code whose codewords form the ground-state or low-energy subspace of a code Hamiltonian realizing a topological phase.\nA topological phase may be \\textit{bosonic} or \\textit{fermionic}, i.e., constructed out of underlying subsystems whose operators commute or anti-commute with each other, respectively.\nUnless otherwise noted, the phases discussed are bosonic.\n\n\\subsection{2D topological codes}\n\nThe physical Hilbert space of 2D topological codes consists of \\(n\\) subsystems which lie on edges, vertices, or faces of a tesselation of a 2D surface \\(\\Sigma^2\\).\n\nFor subsystems with finite local dimension, topological phases are defined by their \\textit{anyons} \\cite{doi:10.1007/BF02727953,doi:10.1063/1.524510,doi:10.1103/PhysRevLett.49.957,doi:10.1063/1.2810672}, which are local bulk excitations of the code Hamiltonian defined on a lattice; see Refs. \\cite{doi:10.1007/BF01877742,doi:10.1007/BF01646454,arxiv:1804.03203} for more rigorous formulations.\n\nAnyons are created in pairs by local operators, and two anyons lie in the same \\textit{superselection sector} if a  local operator can convert one anyon into the other.\nEach superselection sector is assumed to be labeled by one anyon type, and local operators cannot change superselection sectors.\n\nAnyons can braid with themselves, with their \\textit{exchange statistics} (a.k.a. \\textit{topological spin}) defined by phases \\(\\theta(a)\\in U(1)\\) obtained by exchanging two anyons of each type \\(a\\).\nThey can also braid with each other, a process defined by \\textit{braiding relations} \\(B(a,b)\\) for an anyon pair \\(a,b\\).\nAn anyon theory is called \\textit{non-modular} or \\textit{pre-modular} if there exists an anyon \\(a\\) that braids trivially with all anyons.\n\nAnyons \\(a\\) and \\(b\\) can also fuse with each other, meaning that one considers both anyons as one anyon \\(ab\\) and decomposes \\(ab\\) into the anyons representing each superselection sector according to the anyons' \\textit{fusion rules}.\nFor example, two anyons \\(a,b\\) may fuse to the trivial (i.e., vacuum) anyon \\(1\\), \\(ab=1\\), meaning that the composite excitation \\(ab\\) is indistinguishable from the case of no excitation.\n\nThe exchange statistics and fusion rules of anyons cannot be arbitrary and have to satisfy certain consistency relations.\nAdmissible exchange and fusion data are characterized by a \\textit{unitary braided fusion category}.\n\nEach anyon \\(a\\) has a \\textit{quantum dimension} \\(d_a\\) associated with it.\nThe quantum dimensions add up to the \\textit{total quantum dimension} \\(D\\),\n\\begin{align}\n  \\sum_{a}d_{a}^{2}=D^{2}~.\n\\end{align}\nThese \"dimensions\" do not correspond to dimensions of vector spaces and may not be integer-valued.\n\nAn anyon theory that does not admit gapped boundaries (when put on a manifold with boundaries) is called \\textit{chiral}; otherwise, it is \\textit{non-chiral} or \\textit{gapped}.\nChiral topological phases admit a nonzero value of the \\textit{chiral central charge} \\(c_{-}\\).\nA generalization \\cite{arxiv:quant-ph/9707021} of the Gauss-Milgram sum rule for an anyon theory \\(A\\) admitting \\(|A|\\) anyon types,\n\\begin{align}\n  \\frac{1}{\\sqrt{|A|}}\\sum_{a\\in A}d_{a}^{2}\\theta_{a}=De^{i\\frac{2\\pi}{8}c_{-}}~,\n\\end{align}\nrelates the chiral central charge (modulo 8) to the exchange statistics and quantum dimensions.\n","features":{"rate":"The logical dimension \\(K\\) of 2D topological codes described by unitary modular fusion categories depends on the type of manifold \\(\\Sigma^2\\) that is tesselated to form the many-body system. For closed orientable manifolds \\cite{doi:10.1007/bf01217730,doi:10.1007/BF01238857}, \\begin{align} K=\\sum_{a\\in A}\\left(d_{a}/D\\right)^{\\chi(\\Sigma^{2})}~, \\end{align} and a generalization of the formula to the non-orientable case can be found in Ref. \\cite{arxiv:1612.07792}.","encoders":["The unitary circuit depth required to initialize in a general topologically ordered state using geometrically local gates on an \\(L\\times L\\) lattice is \\(\\Omega(L)\\) \\cite{arXiv:quant-ph/0603121}, irrespective of whether the ground state admits Abelian or nonabelian anyonic excitations. However, only a finite-depth circuit and one round of measurements is required for nonabelian topological orders with a Lagrangian subgroup \\cite{arxiv:2209.03964}."]},"notes":["Ref. \\cite[Appx. F]{arxiv:cond-mat/0506438}\\cite{doi:10.7907/5NDZ-W890,arxiv:0707.1889,doi:10.1017/9781009212717} for introductions to topological phases."],"relations":{"parents":[{"code_id":"block_quantum","detail":"Topological codes are block codes because an infinite family of tensor-product Hilbert spaces is required to formally define a phase of matter."}],"cousins":[{"code_id":"hamiltonian","detail":"Codespace if a topological code is typically the ground-state or low-energy subspace of a geometrically local Hamiltonian admitting a topological phase. Logical qubits can also be created via lattice defects or by appropriately scheduling measurements of gauge generators (see Floquet codes)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-15"},{"user_id":"VictorVAlbert","date":"2022-06-05"},{"user_id":"VictorVAlbert","date":"2022-01-05"}]},"_zoodb":{"id":"topological","source_file_path":"codes/quantum/properties/block/topological/topological.yml","source_file_modification_token":1684508734552.277}},"dynamic_gen":{"code_id":"dynamic_gen","name":"Dynamically-generated QECC","short_name":"Dynamically-generated","introduced":"\\cite{arXiv:0708.4025}","description":"Block quantum code whose natural definition is in terms of a many-body scaling limit of a local dynamical process. Such processes, which are often non-deterministic, update the code structure and can include random unitary evolution or non-commuting projective measurements.","relations":{"parents":[{"code_id":"block_quantum"}]},"_meta":{"changelog":[{"user_id":"MichaelGullans","date":"2021-11-30"},{"user_id":"VictorVAlbert","date":"2021-11-30"}]},"_zoodb":{"id":"dynamic_gen","source_file_path":"codes/quantum/properties/dynamic_gen/dynamic_gen.yml","source_file_modification_token":1679678315322.0674}},"monitored_random_circuits":{"code_id":"monitored_random_circuits","name":"Monitored random-circuit code","introduced":"\\cite{doi:10.1103/PhysRevX.9.031009,doi:10.1103/PhysRevB.98.205136,arXiv:1808.05949}","description":"Error-correcting code arising from a monitored random circuit. Such a circuit is described by a series of intermittant random local projective Pauli measurements with random unitary time-evolution operators.\nAn important sub-family consists of \\textit{Clifford monitored random circuits}, where unitaries are sampled from the Clifford group \\cite{arxiv:1901.08092}.\nWhen the rate of projective measurements is independently controlled by a probability parameter \\(p\\), there can exist two stable phases, one described by volume-law entanglement entropy and the other by area-law entanglement entropy.\nThe phases and their transition can be understood from the perspective of quantum error correction, information scrambling, and channel capacities \\cite{arXiv:1903.05124,arXiv:1905.05195}.\n\nMonitored random circuits have a finite information capacity that decays exponentially with respect to system size \\cite{arXiv:1905.05195}. When \\( p = 0 \\), the random circuit achieves channel capacity, meaning that it stores the most amount of information possible.\nThis notion quantifies the recoverability of information and the reversability of the system under the monitored random dynamics. In the volume-law phase (\\( p < p_c \\) for some critical probability \\(p_c\\)), the channel capacity remains non-zero, and the monitored channel projects an initial state into a random error-correcting code \\cite{arXiv:1905.05195}.\nWith appropriately chosen evolution operators and measurements, the code is a stabilizer code whose parameters depend on time, \\( [[n,k(t),d(t)]] \\).\nA similar notion applies to Haar random circuits with measurements \\cite{arXiv:1911.00008}.\n","protection":"When in the volume-law phase, protects against random projective measurements at a rate \\( p < p_c \\). While the true code distance is not known, it is conjectured to be proportional to the contiguous distance. As first described in Ref. \\cite{arXiv:1905.05195}, the  contiguous distance for these circuits is defined with respect to all partitions of the system.","features":{"rate":"Rate can be finite \\cite{arXiv:1905.05195}, depending on the family of random codes generated by the circuit.","encoders":["The dynamics of the monitored random circuit can be recast in the language of stabilizer codes \\cite{arXiv:1905.05195}. The stabilizer group of the error-correcting code resulting from a monitored Clifford circuit either grows or shrinks with each time step, depending on which projective measurements were performed during the time step.","One can construct optimal single-copy encoding operations for strong purification transitions \\cite{arXiv:1905.05195}"],"decoders":["The recovery operation is the reverse unitary transformation with access to the measurement record (for dynamically generated codes with a strong purification transition) \\cite{arXiv:1905.05195}"],"threshold":["Above the critical measurement rate \\( p_c\\), the natural error correction properties of the circuit can no longer protect the information. This can be interpreted as the code threshold.","These dynamically generated codes saturate the trade off between density of encoded information and the error rate threshold \\cite{arXiv:1905.05195}"]},"realizations":["Measurement induced quantum phases have been realized in a trapped-ion processor \\cite{arXiv:2106.05881}."],"notes":["Connections to information scrambling in black hole physics, as introduced in Section 11 of \\cite{arXiv:1903.05124}. In particular, monitored random circuits can be viewed as the Hayden-Preskill recovery problem \\cite{doi:10.1103/PhysRevD.100.086001} running backwards in time. In this setting, the volume-law entanglement phase of the monitored circuit describes the phase when information can be recovered from an old black hole (ie, a black hole that is maximally entangled with the early universe).","Mapping monitored random circuits to statistical mechanics models can help estimate thresholds and code distances for these systems \\cite{arXiv:2007.03822}."],"relations":{"parents":[{"code_id":"random_circuit","detail":"Monitored random circuits are random circuits where projective measurements are interspersed throughout the circuit and measurement results are recorded."}],"cousins":[{"code_id":"topological","detail":"Topological order can be generated in 2D monitored random circuits \\cite{arXiv:2011.06595}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-29"},{"user_id":"ElizabethRBennewitz","date":"2021-12-15"}]},"_zoodb":{"id":"monitored_random_circuits","source_file_path":"codes/quantum/properties/dynamic_gen/monitored_random_circuits.yml","source_file_modification_token":1679678315322.154}},"random_circuit":{"code_id":"random_circuit","name":"Random-circuit code","introduced":"\\cite{arxiv:quant-ph/9910081}","description":"Code whose encoding is naturally constructed by randomly sampling from a large set of (not necessarily unitary) quantum circuits.","protection":"A useful proxy and upper bound to the code distance \\(d\\) is the \\textit{contiguous code distance}: the contiguous length (with periodic boundary conditions) of the shortest logical operator \\cite{arxiv:0810.1983,arxiv:1905.05195}.","notes":["See Refs. \\cite{arxiv:2111.08018,arxiv:2207.14280} for reviews on random-circuit codes."],"relations":{"parents":[{"code_id":"dynamic_gen"},{"code_id":"quantum_random"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-11-30"}]},"_zoodb":{"id":"random_circuit","source_file_path":"codes/quantum/properties/dynamic_gen/random_circuit.yml","source_file_modification_token":1679678315322.2578}},"commuting_projector":{"code_id":"commuting_projector","name":"Commuting-projector code","description":"Hamiltonian-based code whose Hamiltonian terms can be expressed as projectors (i.e., having eigenvalues 0 or 1) that commute with each other.\n","relations":{"parents":[{"code_id":"hamiltonian"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-15"}]},"_zoodb":{"id":"commuting_projector","source_file_path":"codes/quantum/properties/hamiltonian/commuting_projector.yml","source_file_modification_token":1684508734552.3752}},"constant_excitation":{"code_id":"constant_excitation","name":"Constant-excitation (CE) code","introduced":"\\cite{arXiv:quant-ph/9603022,arXiv:quant-ph/9705044,arxiv:quant-ph/9809081}","description":"Code whose codewords lie in an excited-state eigenspace of a Hamiltonian governing the total energy or total number of excitations of the underlying quantum system.\nFor qubit codes, such a Hamiltonian is often the \\textit{total spin Hamiltonian}, \\(H=\\sum_i Z_i\\). For spin-\\(S\\) codes, this generalizes to \\(H=\\sum_i J_z^{(i)}\\), where \\(J_z\\) is the spin-\\(S\\) \\(Z\\)-operator.\nFor bosonic codes, such as Fock-state codes, codewords are often in an eigenspace with eigenvalue \\(N>0\\) of the \\textit{total excitation} or \\textit{energy Hamiltonian}, \\(H=\\sum_i \\hat{n}_i\\).\n\nOne of the first such codes \\cite{arXiv:quant-ph/9603022} is a \\(((8,1,3))\\) qubit code, with codewords\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&= |00001111\\rangle + |11101000\\rangle − |10010110\\rangle − |01110001\\rangle\\\\\n                    & +|11010100\\rangle + |00110011\\rangle + |01001101\\rangle + |10101010\\rangle\\\\\n|\\overline{1}\\rangle&= X^{\\otimes 8} |\\overline{0}\\rangle~.\n\\end{split}\n\\end{align}\nEach logical state is a superposition of computational basis states with four excitations.\n","features":{"rate":"Fock-state CE codes can be used in a protocol that achieves the two-way quantum capacity of the pure-loss Gaussian channel \\cite{arxiv:2203.13924}."},"relations":{"parents":[{"code_id":"hamiltonian","detail":"Constant-excitation codes are associated with a Hamiltonian governing the total excitations of the system."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-01"}]},"_zoodb":{"id":"constant_excitation","source_file_path":"codes/quantum/properties/hamiltonian/constant_excitation.yml","source_file_modification_token":1679678315322.3713}},"hamiltonian":{"code_id":"hamiltonian","name":"Hamiltonian-based code","description":"Encoding corresponds to a set of energy eigenstates of a quantum-mechanical Hamiltonian.\nThe codespace is typically a set of low-energy eigenstates or ground states, but can include subspaces of arbitrarily high energy.\n\nFor block quantum codes, the Hamiltonian can be \\textit{local}, i.e., consisting of operators acting on a number of subsystems that is independent of the total number of subsystems (e.g., \\hyperref[code:qldpc]{QLDPC codes}).\nWhen the physical space is endowed with a geometry, the Hamiltonian is typically \\textit{geometrically local}, consisting of operators acting on subsystems that occupy a region whose size is independent of the number of subsystems (e.g., \\hyperref[code:topological]{topological codes}).\n\nGround states of infinite families geometrically local block-code Hamiltonians can sometimes be said to be a particular phase of (quantum) matter.\nA phase is a \"region in some parameter space in which the ... states possess properties that can be distinguished from those in other phases\" \\cite{doi:10.1063/PT.3.1641}.\nFor a large collection of similar subsystems, a phase is a region in some parameter space in which the thermal equilibrium states possess some properties in common that can be distinguished from those in other phases.\n","protection":"Often determined from the underlying physical properties of the Hamiltonian.","features":{"encoders":["Lindbladian-based dissipative encoding can be constructed for a codespace that is the ground-state subspace of a frustration-free Hamiltonian \\cite{arXiv:0809.0613,arXiv:1112.4860,arxiv:0803.1447,arxiv:1802.00010}."]},"relations":{"parents":[{"code_id":"qecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-15"}]},"_zoodb":{"id":"hamiltonian","source_file_path":"codes/quantum/properties/hamiltonian/hamiltonian.yml","source_file_modification_token":1684508734552.552}},"qltc":{"code_id":"qltc","name":"Quantum locally testable code (QLTC)","short_name":"QLTC","introduced":"\\cite{arxiv:1310.5664}","description":"A local commuting-projector Hamiltonian-based block quantum code which has a nonzero average-energy penalty for creating large errors. Informally, QLTC error states that are far away from the codespace have to be excited states of many of the code's local projectors.\n\nThe average-energy penalty is quantified by the code's \\textit{soundness} \\(R\\). Typically, one looks at how \\(R\\) scales with increasing code size for infinite families of codes, defining QLTC families as those for which the soundness is asymptotically constant. QLTC families that also have asymptotically constant distance, rate, and weight of local projectors are called \\(c^3\\)\\textit{-QLTCs}; none have been found so far.\n\nMore technically, a QLTC is a code \\(\\mathsf{C}\\) defined as the ground-state space of a commuting-projector Hamiltonian \\(H\\) consisting of a sum of \\(r\\) local projectors, each of which acts on exactly \\(u\\) qubits (for some constant \\(u\\)). Such a code is a \\((u,R)\\)-QLTC with soundness function \\(R(\\delta)\\in[0,1]\\) if\n\\begin{align}\n\\label{eq:qltc}\n  \\forall \\delta > 0,|\\psi\\rangle~:~\\text{dist}(|\\psi\\rangle,C) \\geq \\delta n \\Rightarrow \\frac{1}{r}\\langle\\psi|H|\\psi\\rangle\\geq R(\\delta)~,\n\\end{align}\nwhere \\(\\text{dist}(|\\psi\\rangle,\\mathsf{C})\\) is a particular distance function between the state \\(|\\psi\\rangle\\) and the codespace \\(\\mathsf{C}\\) \\cite[Def. 13]{arxiv:1310.5664}. The locality parameter \\(u\\) is called the \\textit{query complexity} of the code.\n\nA qubit, modular-qudit, or Galois-qudit stabilizer code that is locally testable is called a \\textit{stabilizer locally testable code (SLTC)}. In other words, the code admits a set of \\(r\\) \\(u\\)-local stabilizer generators \\(S_i\\) whose corresponding code Hamiltonian \\(H=\\frac{1}{2}\\sum_{i=1}^r I-S_i\\) satisfies the requirement of being QLTC.\n\nFor example, the \\([[n=2L^2,k=2,d=L]]\\) toric code on an \\(L\\times L\\) lattice is \\textit{not} a QLTC because of the following argument. Let \\(|\\psi\\rangle\\) be a ground state that is excited by \\(L/3\\) Pauli strings, each of length \\(L/2\\). In order to fit on the lattice, such strings can, e.g., be horizontal and aligned next to each other in the vertical direction. The distance function \\(\\text{dist}(|\\psi\\rangle,\\mathsf{C})\\) is the weight of the smallest Pauli string that multiplies \\(|\\psi\\rangle\\) to yield a state in the codespace. In this case, that weight is the same as the weight of the perturbing string, i.e., \\(L^2/6\\), requiring \\(\\delta = 1/12\\) to satisfy \\eqref{eq:qltc}. There are \\(2L/3\\) violated Hamiltonian terms because each of the \\(L/3\\) strings violates only two stabilizer generators. However, there are \\(r = 2(L^2-1)\\) stabilizer generators, so the implication of \\eqref{eq:qltc} is not satisfied for nonzero soundness as \\(L\\to\\infty\\) because \\(\\frac{1}{r}\\langle\\psi|H|\\psi\\rangle = \\frac{2L/3}{2(L^2-1)}\\to 0\\).\n","notes":["It was shown in Ref. \\cite{doi:10.1109/FOCS.2017.46} that existence of a QLTC with constant parameters would implies resolution of the \\textit{No low-energy trivial states} (NLTS) conjecture \\cite{arxiv:1301.1363}. QLTCs are believed to also be useful for solving the quantum PCP conjecture \\cite{arXiv:1309.7495}."],"relations":{"parents":[{"code_id":"block_quantum"},{"code_id":"commuting_projector","detail":"Quantum LTC codespaces are ground-state spaces of \\(u\\)-local commuting-projector Hamiltonians."}],"cousins":[{"code_id":"qldpc","detail":"Stabilizer LTCs are QLDPC. More general QLTCs are not defined using Pauli strings, but the codespace is the ground-state subspace of a local Hamiltonian. In this sense, QLTCs are QLDPC codes."},{"code_id":"self_correct","detail":"The notion of an energy barrier in a self-correcting memory is intimately related to the soundness of a QLTC."},{"code_id":"qubit_css","detail":"A qubit CSS code defined by \\(H_{Z}\\) and \\(H_{X}\\) is glocally testable with some soundness iff the constituent codes \\(\\ker H_{Z}\\) and \\(\\ker H_{X}\\) are locally testable with the same soundness \\cite[Fact 17]{arxiv:1510.02082}."},{"code_id":"distance_balanced","detail":"Distance balancing is useful for constructing QLTCs. Scaling of the soundness of a given code family is proven in \\cite[Lemma 7]{arxiv:1611.03790} for the original distance balancing scheme and in \\cite[Thm. 1.1]{arxiv:2305.00689} for the generalized scheme \\cite{arxiv:2004.07935}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-10"},{"user_id":"VictorVAlbert","date":"2022-09-28"}]},"_zoodb":{"id":"qltc","source_file_path":"codes/quantum/properties/hamiltonian/qltc.yml","source_file_modification_token":1684508734552.7266}},"self_correct":{"code_id":"self_correct","name":"Self-correcting quantum code","introduced":"\\cite{arXiv:quant-ph/0110143,arXiv:0811.0033}","description":"Also called a \\textit{self-correcting quantum memory} or \\textit{thermally stable encoding}. A block quantum code that forms the ground-state subspace of an \\(n\\)-body geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after interaction with a sufficiently cold thermal environment.\nTypically, one also requires a decoder whose decoding time scales polynomially with \\(n\\) and a finite energy density.\nThe original criteria for a self-correcting quantum memory, informally known as the \\textit{Caltech rules} \\cite{arxiv:1411.7046,arxiv:1501.04112}, also required finite-spin Hamiltonians.\n\nThe effect of a Markovian thermal environment consists of a Lindbladian in Davies form admitting a Gibbs steady state at some temperature \\(T\\) \\cite{arxiv:1411.6643}.\nTo test whether a system is self-correcting, an initial codeword \\(\\rho(0)\\) is evolved under the Davies Lindbladian and the code Hamiltonian (or, if we are to allow extra passive protection, the code Lindbladian) to the state \\(\\rho(t)\\) at time \\(t\\), after which it is decoded via decoding map \\(\\cal{D}\\).\nThe memory time \\(\\tau\\) is defined to be\n\\begin{align}\n  \\tau=\\sup\\left\\{ t>0\\,|\\left\\Vert {\\cal D}(\\rho(t))-\\rho(0)\\right\\Vert _{1}<\\epsilon\\right\\}\n\\end{align}\nfor some fixed \\(\\epsilon\\).\nFor a self-correcting memory, there exists a critical temperature \\(T_\\star>0\\) such that \\(\\tau\\to\\infty\\) (typically, exponentially with \\(n\\)) as \\(n\\to\\infty\\) for any temperature \\(T<T_{\\star}\\) and any codeword \\(\\rho(0)\\).\nA memory is \\textit{partially self-correcting} if \\(\\tau\\) scales polynomially with \\(n\\) up to some cutoff \\(n_{max}\\).\nA self-correcting memory is typically associated with a (stable) phase of quantum matter.\n","protection":"Self-correcting classical memories exist in two and higher dimensions, with the canonical example being the classical Ising model. In that model, a classical bit is stored in the overall magnetization. The magnetization is thermally stable due to the fact that there is an \\(n\\)-dependent (i.e., \\textit{macroscopic}) energy cost of flipping a contiguous region of physical bits \\cite{doi:10.1017/S0305004100019174,arxiv:1411.6643}. This cost scales with the surface area of the region, and the surface area is \\(n\\)-dependent for dimensions greater than one.\n\nSelf-correcting quantum memories currently exist in four and higher dimensions, with their existence in three dimensions being an open question. For similar reasons as the classical Ising model, the four-dimensional toric code is a self-correcting quantum memory due to an order \\(O(n)\\) energy cost of creating a logical error \\cite{arXiv:quant-ph/0110143,arXiv:0811.0033}. On the other hand, the 2D toric code is not thermally stable \\cite{arxiv:quant-ph/0702102,arxiv:0709.2717,arxiv:0810.4584,arxiv:0911.3843} because its string-like logical operators anti-commite with stabilizer generators supported only at their ends, and thus have a constant energy cost of creation.\nThere is a general upper bound on the relaxation rate of a qubit stabilizer or qubit subsystem stabilizer quantum memory interacting with a Markovian environment \\cite{arxiv:0907.2807}.\n\nAn \\(n\\)-dependent energy barrier to creating all logical errors is likely necessary for a thermally stable memory, having been shown as such for a large class of 2D topological phases \\cite{arXiv:1412.2858,arXiv:1601.01324,arxiv:2107.01628}. Two-dimensional stabilizer codes \\cite{arXiv:0810.1983} and encodings of frustration-free code Hamiltonians \\cite{arXiv:1209.5750} admit only constant-energy excitations, and so do not have admit such a barrier. No-go theorems for 3D models are much more restrictive, and there exist several candidates for self-correction as well as several partially self-correcting memories (see cousins below).\n","relations":{"parents":[{"code_id":"symmetry_protected_self_correct","detail":"A self-correcting quantum memory does not require symmetry for self correction."}],"cousins":[{"code_id":"translationally_invariant_stabilizer","detail":"3D translationally-invariant qubit stabilizer code families with constant \\(k\\) support logical string operators and thus cannot be self-correcting \\cite{arXiv:1103.1885}. For non-constant \\(k\\), such families can support at most a logarithmic energy barrier \\cite{arXiv:1101.1962}."},{"code_id":"higher_dimensional_surface","detail":"The 4D toric code is a self-correcting quantum memory \\cite{arXiv:quant-ph/0110143,arXiv:0811.0033}."},{"code_id":"3d_surface","detail":"The 3D welded solid code is partially self-correcting with a power-law energy barrier \\cite{arxiv:1406.4227}. The 3D toric code is a classical self-correcting memory, whose protected bit admits a membrane-like logical operator \\cite{arxiv:1501.04112}, but it is not a quantum self-correcting memory \\cite{arxiv:2305.06389}."},{"code_id":"color","detail":"The 6D color code is a self-correcting quantum memory \\cite{arXiv:0907.5228}."},{"code_id":"haah_cubic","detail":"Cubic code 1 is partially self-correcting with a logarithmic energy barrier \\cite{arXiv:1112.3252}."},{"code_id":"quantum_repetition","detail":"The bit-flip repetition code associated with the 2D classical Ising model is a self-correcting classical memory \\cite[Sec. V.A]{arxiv:1411.6643}."},{"code_id":"repetition","detail":"The repetition code associated with the 2D classical Ising model is a self-correcting classical memory \\cite[Sec. V.A]{arxiv:1411.6643}."},{"code_id":"bacon_shor","detail":"3D Bacon-Shor codes were conjectured to be self-correcting \\cite{arxiv:quant-ph/0506023}, but there remain issues to be resolved in order to validate this conjecture (see \\cite[Sec. IX.B]{arxiv:1411.6643})."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-28"},{"user_id":"VictorVAlbert","date":"2022-05-18"},{"user_id":"YiTingRickTu","date":"2022-05-02"}]},"_zoodb":{"id":"self_correct","source_file_path":"codes/quantum/properties/hamiltonian/self_correct.yml","source_file_modification_token":1684671427306.6565}},"symmetry_protected_self_correct":{"code_id":"symmetry_protected_self_correct","name":"Symmetry-protected self-correcting quantum code","introduced":"\\cite{arXiv:1805.01474}","description":"Also called a \\textit{symmetry-protected self-correcting memory}. An restricted notion of thermal stability against symmetric perturbations, i.e., perturbations that commute with a set of operators forming a group \\(G\\) called the \\textit{symmetry group}.\n\nGiven a symmetry group \\(G\\) and its unitary representation \\(S\\) on the \\(n\\)-site physical Hilbert space (in this case, a lattice), an operator \\(O\\) is \\(G\\)\\textit{-symmetric} (a.k.a. respects the \\(G\\) symmetry) if \\([S(g),O]=0\\) for all \\(g\\in G\\). A symmetry-protected self-correcting memory is a ground-state encoding of an \\(n\\)-body \\(G\\)-symmetric geometrically local Hamiltonian whose logical information is recoverable for arbitrary long times in the \\(n\\to\\infty\\) limit after a \\(G\\)-symmetric interaction with a thermal environment at sufficiently low temperature.\n\nTensor-product symmetries of the form \\(S(g)=u(g)^{\\otimes n}\\), where \\(u\\) is a unitary representation of \\(G\\ni g\\) on a site, cannot support symmetry-protected self-correction. One can instead use \\textit{one-form symmetries}, i.e., symmetries generated by operators of the form\n\\begin{align}\n  S_{\\mathcal{M}}(g)=\\bigotimes_{\\text{sites}\\in\\mathcal{M}}u(g),\n\\end{align}\nwhere \\(\\mathcal{M}\\) runs over all closed codimension-one submanifolds of the lattice. Recent work further relaxed the requirement so that symmetries need only be enforced on the system's boundaries \\cite{arxiv:2206.05294}.\n","protection":"The code is intended to be used as a self-correcting quantum memory when the symmetry is enforced, and protection is characterized by the scaling of the memory time \\(\\tau\\) in the system size.\n\nAnother characterization of the protection property is the symmetric version of the energy barrier \\(\\Delta\\), defined as follows.\nFor a given logical operator and a given decomposition into a product of local operators, we consider the maximal energy attained when implementing this logical operator stepwise with this decomposition. Then, \\(\\Delta\\) is defined by minimizing this quantity over all logical operators and over those decompositions for which each local operator respects the symmetry. For some models \\cite{arXiv:1805.01474}, the linear growth of \\(\\Delta\\) with system size \\(n\\) implies the exponential growth of \\(\\tau\\) below a critical temperature.\n","relations":{"parents":[{"code_id":"hamiltonian"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-18"},{"user_id":"YiTingRickTu","date":"2022-05-02"}]},"_zoodb":{"id":"symmetry_protected_self_correct","source_file_path":"codes/quantum/properties/hamiltonian/symmetry_protected_self_correct.yml","source_file_modification_token":1684508734553.1477}},"metrological":{"code_id":"metrological","logical":"qubits","name":"Metrological code","introduced":"\\cite{arxiv:2207.13707}","description":"Two-dimensional subspace of a Hilbert space whose basis states satisfy only a part of the \\term{Knill-Laflamme conditions}. The satisfied part of the conditions ensures that the code can be used for local parameter estimation.\n\nLetting \\(\\Pi = U U^\\dagger\\) be the codespace projector for encoding isometry \\(U\\) and projecting a pair of errors \\(E_i,E_j\\) from an error set \\(\\cal E\\) into the two-dimensional codespace yields\n\\begin{align}\n  \\Pi E_{i}^{^{\\dagger}}E_{j}\\Pi=c_{ij}\\,\\Pi+x_{ij}\\overline{X}+y_{ij}\\overline{Y}+z_{ij}\\overline{Z}\n\\end{align}\nwith error-matrix element \\(c_{ij}\\) and logical-error coefficients\n\\begin{align}\n  \\left\\{ x,y,z\\right\\} _{ij}={\\textstyle \\frac{1}{2}}\\text{Tr}\\left(\\left\\{ \\overline{X},\\overline{Y},\\overline{Z}\\right\\} E_{i}^{^{\\dagger}}E_{j}\\right)~.\n\\end{align}\nIf all three logical-error coefficients are zero, then the \\term{Knill-Laflamme conditions} are satisfied, and the code is a \\hyperref[code:qecc]{QECC}. If only one of the three coefficients is zero, then the code is the more general metrological code.\n","protection":"Physical noise can cause logical errors along one of the three axes, i.e., either logical-\\(X\\), \\(Y\\), or \\(Z\\), depending on what basis is used. Codes protect against logical errors along the remaining two axes.\n\nA metrological block quantum code has distance \\(d\\) if the above conditions are satisfied for an error set \\(\\cal E\\) consisting of errors supported on \\(d-1\\) subsystems of less.\n","relations":{"parents":[{"code_id":"quantum_into_quantum"}],"cousins":[{"code_id":"metopt","detail":"Error-corrected sensing codes are required to satisfy the \\term{Knill-Laflamme conditions}, while metrological codes need only satisfy the conditions partially."},{"code_id":"covariant","detail":"Any time-covariant QECC, i.e., a code admitting a continuous-parameter \\(U(1)\\) family of gates, is automatically a metrological code."},{"code_id":"qubit_stabilizer","detail":"A joint \\(+1\\) and \\(-1\\) eigenstate of a set of stabilizer can form a metrological stabilizer code \\cite{arxiv:2207.13707}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-30"}]},"_zoodb":{"id":"metrological","source_file_path":"codes/quantum/properties/metrological.yml","source_file_modification_token":1681805027419.3809}},"qecc":{"code_id":"qecc","name":"Quantum error-correcting code (QECC)","short_name":"QECC","description":"Encodes quantum information in a (\\textit{logical}) subspace of a\n(\\textit{physical}) Hilbert space such that it is possible to recover said\ninformation from errors that act as linear maps on the physical space. The\nlogical subspace is spanned by a basis comprised of \\textit{code basis states}\nor \\textit{codewords}. Codewords may not be normalizable if the physical\nHilbert space in infinite, so approximate versions have to be constructed in\npractice.\n","protection":"Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a quantum code\n\\((U,\\cal{E})\\) is a partial isometry\n\\(U:\\mathsf{H}_{\\text{logical}}\\to\\mathsf{H}_{\\text{physical}}\\) with a set of\ncorrectable errors \\(\\cal{E}\\) with the following property: there exists a\nquantum operation \\(\\cal{D}\\) such that for all \\(E\\in\\cal{E}\\) and states\n\\(|\\psi\\rangle\\in\\mathsf{H}_{\\text{logical}}\\),\n\\begin{align}\n  {\\cal D} (EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})\n  = c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\n\\end{align}\nfor some constant \\(c\\).\n\nEquivalently, correction capability is determined by the \\term{Knill-Laflamme conditions}, which may admit infinite terms due to non-normalizability of ideal code states in the case of codes with infinite-dimenional physical spaces. A code that satisfies these conditions approximately, i.e., up to some small quantifiable error, is called an \\hyperref[code:approximate_qecc]{approximate code}. These conditions can also be formulated in terms of a dual Heisenberg picture, where correctability is checked for some algebra of observables \\cite{arxiv:0811.0421}.\n","features":{"rate":"The quantum channel capacity, i.e., the regularized coherent information, is the highest rate of quantum information transmission through a quantum channel with arbitrarily small error rate \\cite{arxiv:quant-ph/9604015,preset:ShorMSRI,arXiv:quant-ph/0304127}. See \\cite[Ch. 24]{arxiv:1106.1445} for definitions and a history."},"notes":["See Refs. \\cite{doi:10.1017/CBO9780511976667,preset:PreskillNotes,preset:GottesmanBook,arxiv:1302.3428,arxiv:1907.11157} for introductions to quantum error correction.","Quantum error correction was initially claimed not to be theoretically possible \\cite{arxiv:hep-th/9406058,doi:10.1098/rsta.1995.0106}."],"relations":{"parents":[{"code_id":"quantum_into_quantum"},{"code_id":"oaecc"}],"cousins":[{"code_id":"ecc","detail":"Error-correction conditions can similarly be formulated for classical codes \\cite[Sec. 3]{arxiv:2109.08691}, although they are not as widely as used as those for quantum codes."},{"code_id":"metrological","detail":"Metrological codes are logical-qubit codes that satisfy the \\term{Knill-Laflamme conditions} conditions only partially, and codes that satisfy them fully are QECCs."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-30"},{"user_id":"PhilippeFaist","date":"2022-07-15"},{"user_id":"VictorVAlbert","date":"2022-01-03"}]},"_zoodb":{"id":"qecc","source_file_path":"codes/quantum/properties/qecc.yml","source_file_modification_token":1680994436848.7297}},"qecc_finite":{"code_id":"qecc_finite","name":"Finite-dimensional quantum error-correcting code","short_name":"Finite QECC","description":"Encodes quantum information in a \\(K\\)-dimensional (\\textit{logical}) subspace of an \\(N\\)-dimensional (\\textit{physical}) Hilbert space such that it is possible to recover said information from errors. The logical subspace is spanned by a basis comprised of \\textit{code basis states} or \\textit{codewords}.","protection":"Denoting Hilbert spaces by the letter \\(\\mathsf{H}\\), a finite-dimensional quantum code \\((U,\\cal{E})\\) is a partial isometry \\(U:\\mathsf{H}_{K}\\to\\mathsf{H}_{N}\\) with a set of correctable errors \\({\\cal{E}}:\\mathsf{H}_N\\to\\mathsf{H}_M\\) with the following property: there exists a quantum operation \\({\\cal{D}}:\\mathsf{H}_M\\to \\mathsf{H}_K\\) such that for all \\(E\\in\\cal{E}\\) and states \\(|\\psi\\rangle\\in\\mathsf{H}_{K}\\),\n\\begin{align}\n{\\cal D}(EU|\\psi\\rangle\\langle\\psi|U^{\\dagger}E^{\\dagger})=c(E,|\\psi\\rangle)|\\psi\\rangle\\langle\\psi|\\end{align}\nfor some constant \\(c\\) \\cite{preset:GottesmanBook}. A code is said to \\textit{protect against} or \\textit{correct} the errors \\(\\mathcal{E}\\).\n\n\\subsection{Knill-Laflamme error correction conditions}\n\nEquivalently, correction capability is determined by of the quantum\nerror-correction conditions, which may admit infinite\nterms due to non-normalizability of ideal code states. A code that satisfies\nthese conditions approximately, i.e., up to some small quantifiable error, is\ncalled an \\hyperref[code:approximate_qecc]{approximate code}.\n\n\\begin{defterm}{Knill-Laflamme conditions}\nIn a finite-dimensional Hilbert space, there are necessary and sufficient\nconditions for a code to successfully\ncorrect a set of errors.  These are called the Knill-Laflamme \\emph{error-correction conditions}~\\cite{doi:10.1103/PhysRevA.55.900,arXiv:quant-ph/9604024,preset:PreskillNotes}\\cite[Thm. 10.1]{doi:10.1017/CBO9780511976667}.\nA code defined by a partial isometry \\(U\\) with code space projector \\(\\Pi = U U^\\dagger\\)\ncan correct a set of errors \\(\\{ E_j \\}\\) if and only if\n\\begin{align}\n  \\Pi E_i^\\dagger E_j \\Pi = c_{ij}\\, \\Pi\\qquad\\text{for all \\(i,j\\),}\n\\end{align}\nwhere \\(c_{ij}\\) can be arbitrary numbers.\n\\end{defterm}\n\nA code is \\textit{degenerate} with respect to a noise model if different errors map code states to the same error subspace. For a linearly independent error set \\(\\cal{E}\\), degeneracy is equivalent to \\(\\text{rank}(c_{ij}) < |\\cal{E}|\\).\n\nDetermining protection and bounds on code parameters can also be done using Shor-Laflamme \\textit{quantum weight enumerators} \\cite{arxiv:quant-ph/9610040} and Rains \\textit{shadow enumerators} \\cite{arxiv:quant-ph/9611001} (see also \\cite{arXiv:quant-ph/0406063}).\n\n\\subsection{Correctability of quantum channels}\n\nWe define that some quantum channel \\(\\mathcal{N}\\) is exactly correctable if\nthere exists some recovery channel \\(\\mathcal{R}\\) such that \\(\\mathcal{R}\\mathcal{N}=\\mathrm{id}\\).\n\nGiven some noise channel \\(\\mathcal{N}\\), a necessary and sufficient condition for exact correctibility\nis that complementary channel \\(\\mathcal{N}^C(\\rho)=\\rho_0\\mathrm{Tr}(\\rho)\\). This can be used to derive the Knill-Laflamme conditions~\\cite{arXiv:0907.5391}.\n","features":{"general_gates":["Universal gate set cannot be transversal for any code that detects single-qubit errors due to Eastin-Knill theorem \\cite{arXiv:0811.4262}."],"decoders":["The operation \\(\\cal{D}\\) in the definition of this code is called the decoder. However, the term \\textit{decoder} can sometimes be used for the inverse of an encoder, which does not correct errors.","Quantum machine-learning based decoders such as quantum convolutional neural networks \\cite{arXiv:1810.03787} and quantum autoencoders \\cite{arxiv:2202.00555}."]},"relations":{"parents":[{"code_id":"qecc"}],"cousins":[{"code_id":"ecc_finite"}]},"_meta":{"changelog":[{"user_id":"M10T","date":"2023-06-28"},{"user_id":"VictorVAlbert","date":"2022-07-15"},{"user_id":"VictorVAlbert","date":"2022-03-18"},{"user_id":"VictorVAlbert","date":"2021-12-09"}]},"_zoodb":{"id":"qecc_finite","source_file_path":"codes/quantum/properties/qecc_finite.yml","source_file_modification_token":1689550329218.966}},"quantum_concatenated":{"code_id":"quantum_concatenated","name":"Concatenated quantum code","description":"A combination of two codes, an inner code \\(C\\) and an outer code \\(C^\\prime\\), where the physical subspace used for the outer code consists of the logical subspace of the inner code. In other words, first one encodes in the outer code \\(C^\\prime\\), and then one encodes each of the physical registers of \\(C^\\prime\\) in an inner code \\(C\\).","features":{"threshold":["The first method to achieve a fault-tolerant computational threshold uses concatenated stabilizer codes \\cite{arxiv:quant-ph/9702058,arxiv:quant-ph/9906129,arXiv:quant-ph/9705031,arXiv:quant-ph/0504218}. Such methods require constant-space and polylogarithmic time overhead, but concatentions using quantum Hamming codes improve this to quasi-polylogarithmic time \\cite{arxiv:2207.08826}."]},"notes":["Concatenated codes can achieve the Gilbert-Varshamov bound \\cite{arxiv:1004.1127}."],"relations":{"parents":[{"code_id":"qecc"}],"cousins":[{"code_id":"quantum_lego","detail":"Concatenations of block quantum codes can be expressed as quantum Lego codes."},{"code_id":"holographic","detail":"A holographic code whose encoding circuit is arranged in a tree geometry reduces to a concatenated code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-15"}]},"_zoodb":{"id":"quantum_concatenated","source_file_path":"codes/quantum/properties/quantum_concatenated.yml","source_file_modification_token":1679678315323.396}},"quantum_random":{"code_id":"quantum_random","name":"Random quantum code","description":"Quantum code whose construction is non-deterministic in some way, i.e., codes that utilize an elements of randomness somewhere in their construction. Members of this class range from fully non-deterministic codes (e.g., random-circuit codes), to codes whose multi-step construction is deterministic with the exception of a single step (e.g., expander lifter-product codes).","relations":{"parents":[{"code_id":"qecc"}],"cousins":[{"code_id":"random"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-28"}]},"_zoodb":{"id":"quantum_random","source_file_path":"codes/quantum/properties/quantum_random.yml","source_file_modification_token":1679678315323.475}},"css":{"code_id":"css","name":"Calderbank-Shor-Steane (CSS) stabilizer code","short_name":"CSS","description":"A stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type operators.\nThe two sets of stabilizer generators can often, but not always, be related to parts of a chain complex over the appropriate ring or field.\n","relations":{"parents":[{"code_id":"stabilizer"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-11"}]},"_zoodb":{"id":"css","source_file_path":"codes/quantum/properties/stabilizer/css.yml","source_file_modification_token":1681484685082.6123}},"generalized_homological_product":{"code_id":"generalized_homological_product","name":"Generalized homological-product code","description":"Stabilizer code whose properties are determined from an underlying chain complex, which often consists of some type of product of other chain complexes.\nThe \\ref{topic:CSS-to-homology-correspondence} yields an interpretation of codes in terms of manifolds, thus allowing for the use of various products from topology in constructing codes.\n\nThe codes participating in the product can be quantum, classical, or mixed.\nHomology can be used to design codes for qubits, modular qudits, Galois qudits, as well as rotors; most codes are CSS codes.\nHowever, products can be of more than two underlying codes, in which case the output code need not be CSS (e.g., for \\hyperref[code:xyz_product]{XYZ-product codes}).\n\nThe simplest product is a tensor product, with more general products imposing equivalence or symmetry relations on the outputs of the tensor product.\nA product of two codes can be interpreted as a fiber bundle, with one element of the product being the base and the other being the fiber.\n","relations":{"parents":[{"code_id":"qldpc","detail":"Homological products are a primary tool for generating QLDPC codes with favorable parameters. Typically, whenever the input codes are LDPC or QLDPC, the resulting code will be QLDPC with non geometrically local stabilizer generators."}]},"_meta":{"changelog":[{"user_id":"NikolasBreuckmann","date":"2022-01-20"},{"user_id":"VictorVAlbert","date":"2022-01-20"}]},"_zoodb":{"id":"generalized_homological_product","source_file_path":"codes/quantum/properties/stabilizer/qldpc/generalized_homological_product.yml","source_file_modification_token":1681484685082.7043}},"generalized_homological_product_css":{"code_id":"generalized_homological_product_css","name":"Generalized homological-product CSS code","description":"CSS code whose properties are determined from an underlying chain complex, which often consists of some type of product of other chain complexes.\n","relations":{"parents":[{"code_id":"css"},{"code_id":"generalized_homological_product","detail":"The notion of homological products arises from interpreting CSS codes in terms of chain complexes over manifolds, but some products no longer yield CSS codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"}]},"_zoodb":{"id":"generalized_homological_product_css","source_file_path":"codes/quantum/properties/stabilizer/qldpc/generalized_homological_product_css.yml","source_file_modification_token":1681484685082.7595}},"good_qldpc":{"code_id":"good_qldpc","name":"Good QLDPC code","description":"Also called \\textit{asymptotically good QLDPC codes}. A family of QLDPC codes \\([[n_i,k_i,d_i]]\\) whose asymptotic rate \\(\\lim_{i\\to\\infty} k_i/n_i\\) and asymptotic distance \\(\\lim_{i\\to\\infty} d_i/n_i\\) are both positive.\n\nThe first good QLDPC codes are families constructed by applying the CSS construction to classical Tanner codes on expander graphs \\cite{doi:10.1090/S0273-0979-06-01126-8}.\nThe three constructions are closely related, assigning qubits and check operators to vertices, edges, and faces of a particular graph called the left-right Cayley complex.\n  \\begin{table}\n    \\begin{cells}\n    \\celldata<c H, c H, c H, c H>{Code & vertices & edges & faces}\n    \\celldata<c, c, c, c>{\n    \\hyperref[code:expander_lifted_product]{expander lifted-product} & qubits & \\(X,Z\\) checks & qubits\n        \\\\\n    \\hyperref[code:quantum_tanner]{quantum Tanner} & \\(X,Z\\) checks &  & qubits\n        \\\\\n    \\hyperref[code:dhlv]{Dinur-Hsieh-Lin-Vidick} & \\(X\\) checks & qubits & \\(Z\\) checks\n    }\n    \\end{cells}\n    \\caption{Assignment of qubits and checks for three asymptotically good QLDPC codes.}\n    \\label{table:good-qldpc-codes}\n  \\end{table}\n","relations":{"parents":[{"code_id":"qldpc"}],"cousins":[{"code_id":"topological","detail":"Chain complexes describing some good QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality \\cite{arXiv:2012.02249}. Applying this procedure to good QLDPC codes yiels geometrically local \\([[n,n^{1-2/D},n^{1-1/D}]]\\) codes in \\(D\\) spatial dimensions, up to corrections poly-logarithmic in \\(n\\) \\cite{arxiv:2303.06755}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-24"}]},"_zoodb":{"id":"good_qldpc","source_file_path":"codes/quantum/properties/stabilizer/qldpc/good_qldpc.yml","source_file_modification_token":1683723710998.11}},"qldpc":{"code_id":"qldpc","name":"Quantum low-density parity-check (QLDPC) code","short_name":"QLDPC","introduced":"\\cite{arXiv:quant-ph/0304161}","description":"Also called a \\textit{sparse quantum code}.\nMember of a family of \\([[n,k,d]]\\) modular-qudit or Galois-qudit stabilizer codes for which the number of sites participating in each stabilizer generator and the number of stabilizer generators that each site participates in are both bounded by a constant as \\(n\\to\\infty\\).\nA \\textit{geometrically local stabilizer code} is a QLDPC code where the sites involved in any syndrome bit are contained in a fixed volume that does not scale with \\(n\\).\nAs opposed to general stabilizer codes, syndrome extraction of the constant-weight check operators of a QLDPC codes can be done using a constant-depth circuit.\n\nNotable \\([[n,k,d]]\\) QLDPC codes are summarized in \\ref{table:qldpc-codes}, demonstrating the steady improvement in code parameters that culminated in the first asymptotically good QLDPC codes.\n  \\begin{table}\n    \\begin{cells}\n    \\celldata<c H, c H, c H>{\\(k\\) & \\(d\\) & Code}\n    \\celldata<c, c, c>{\n    \\(2\\) & \\(\\sqrt{n}\\) & \\hyperref[code:surface]{Kitaev toric}\n        \\\\\n    \\(2\\) & \\(\\sqrt{n\\sqrt{\\log n}}\\) & \\hyperref[code:freedman_meyer_luo]{Freedman-Meyer-Luo}\n        \\\\\n    \\(\\Theta(n)\\) & \\(\\sqrt{n}\\) & \\hyperref[code:hypergraph_product]{hypergraph product}\n        \\\\\n    \\(\\sqrt{n}/\\log n\\) & \\(\\sqrt{n} \\log n\\) & \\hyperref[code:ramanujan_tensor_product]{high-dimensional expander (HDX)}\n        \\\\\n    \\(\\sqrt{n}\\) & \\(\\sqrt{n} \\log^c n\\) & \\hyperref[code:iterated_ramanujan]{tensor-product HDX}\n        \\\\\n    \\(n^{3/5}/\\text{polylog}(n)\\) & \\(n^{3/5}/\\text{polylog}(n)\\) & \\hyperref[code:fiber_bundle]{fiber-bundle}\n        \\\\\n    \\(\\log n\\) & \\(n/\\log n\\) & \\hyperref[code:lifted_product]{lifted-product (LP)}\n        \\\\\n    \\(\\Theta(n)\\) & \\(\\Theta(n)\\) & \\hyperref[code:expander_lifted_product]{expander LP}\n        \\\\\n    \\(\\Theta(n)\\) & \\(\\Theta(n)\\) & \\hyperref[code:quantum_tanner]{quantum Tanner}\n        \\\\\n    \\(\\Theta(n)\\) & \\(\\Theta(n)\\) & \\hyperref[code:dhlv]{Dinur-Hsieh-Lin-Vidick}\n    }\n    \\end{cells}\n    \\caption{Notable QLDPC codes; \\(c\\) is a positive integer.}\n    \\label{table:qldpc-codes}\n  \\end{table}\n\nStrictly speaking, the term \\textit{parity check} describes only bitwise qubit error syndromes. Nevertheless, qudit stabilizer codes satisfying the above criteria are also called QLDPC codes.\n","protection":"Detects errors on \\(d-1\\) sites, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) sites.\nCode distance may not be a reliable marker of code performance.\nQLDPC codes with generator weights bounded by some constant can correct many stochastic errors far beyond the distance, which may not scale as favorably.\nTogether with more accurate, faster, and easier-to-parallelize measurements than those of general stabilizer codes, this property makes QLDPC codes interesting in practice.\n","features":{"rate":"Asymptotic scaling of \\(k\\) and \\(d\\) with \\(n\\) depends heavily on the code construction.\n\nGeometrically local qubit codes are limited by the \\textit{Bravyi-Poulin-Terhal (BPT) bound} \\cite{arxiv:0909.5200} (see also \\cite{arxiv:0810.1983,arxiv:1008.1029}), which states that \\(d \\leq O(n^{1-1/D})\\) and \\(k d^{2/D-1} = O(n)\\) for \\(D\\)-dimensional lattice geometries.\nCodes on a \\(D\\)-dimensional Riemannian manifold with diameter \\(L\\) satisfy \\(k = O(L^{D-2})\\) \\cite{arxiv:2009.13551}.\n\nFor general graphs, distance is limited by graphs' connectivity, and a constant relative minimum distance can be achieved only for graphs that contain expanders \\cite{arXiv:2106.00765}.\nConversely, a code with parameters \\(k\\) and \\(d\\) requires a graph with \\(\\Omega(d)\\) edges of length \\(\\Omega(d/n^{1/D})\\) \\cite{arXiv:2109.10982}.\n","general_gates":["Logical gates implemented via constant-depth quantum circuits of \\(D\\)-dimensional geometrically qubit codes lie in the \\(D\\)th level of the Clifford hierarchy \\cite{arxiv:1206.1609}."],"decoders":["Belief-propagation (BP) decoder \\cite{arxiv:0801.1241} and neural BP decoder \\cite{arxiv:2212.10245} for qubit codes. Partially and fully decoupled BP decoders, which uses the decoupling representation, yield improvements against depolarizing noise \\cite{arxiv:2305.17505}.","Non-binary decoding algorithm for CSS-type QLDPC codes \\cite{doi:10.1109/ACCESS.2015.2503267}.","BP-OSD decoder adds a post-processing step based on ordered statistics decoding (OSD) to the belief propogation (BP) decoder \\cite{arxiv:1904.02703}.","2D geometrically local syndrome extraction circuits with bounded depth using order \\(O(n^2)\\) ancilla qubits \\cite{arxiv:2109.14599}.","Soft (i.e., analog) syndrome iterative belief propagation for CSS-type QLDPC codes, utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) \\cite{arxiv:2205.02341}.","Message-passing decoder utilizing stabilizer inactivation (MP-SI) for CSS-type QLDPC qubit codes \\cite{arxiv:2205.06125}.","Extension of the union-find decoder for qubit QLDPC codes, as well as a related heuristic decoder \\cite{arxiv:2209.01180}."],"fault_tolerance":["Lattice surgery techniques with ancilla qubits \\cite{arxiv:2110.10794}.","Fault-tolerance with constant overhead can be performed on certain QLDPC codes \\cite{arXiv:1310.2984}, e.g., quantum expander codes \\cite{arXiv:1808.03821}.","GHz state distillation for Steane error correction \\cite{arxiv:2210.14143}."],"code_capacity_threshold":["Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model \\cite{arxiv:quant-ph/0110143,arXiv:1208.2317,arXiv:1311.7688}.","Bounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights \\cite{arxiv:1412.6172}."],"threshold":["QLDPC codes with a constant encoding rate can reduce the overhead of fault-tolerant quantum computation to be constant \\cite{arXiv:1310.2984}."]},"notes":["Links to code tables of notable QLDPC codes \\cite{arXiv:2103.06309}.","Reviews of QLDPC codes provided in Refs. \\cite{doi:10.1109/ACCESS.2015.2503267,arxiv:2103.06309}."],"relations":{"parents":[{"code_id":"stabilizer"},{"code_id":"block_quantum"}],"cousins":[{"code_id":"ldpc"},{"code_id":"topological","detail":"Topological codes are not generally defined using Pauli strings. However, for appropriate tesselations, the codespace is the ground-state subspace of a geometrically local Hamiltonian. In this sense, topological codes are QLDPC codes. On the other hand, chain complexes describing some QLDPC codes can be 'lifted' into higher-dimensional manifolds admitting some notion of geometric locality \\cite{arXiv:2012.02249}. This opens up the possibility that some QLDPC codes, despite not being \\textit{geometrically} local, can in fact be associated with a geometrically local theory described by a category."},{"code_id":"dynamic_gen","detail":"QLDPC codes can arise from a dynamical process \\cite{arxiv:2004.09560}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-10-02"},{"user_id":"EugeneTang","date":"2022-10-02"},{"user_id":"VictorVAlbert","date":"2022-09-16"},{"user_id":"VictorVAlbert","date":"2022-05-13"},{"user_id":"VictorVAlbert","date":"2022-01-24"},{"user_id":"XiaozhenFu","date":"2021-12-12"}]},"_zoodb":{"id":"qldpc","source_file_path":"codes/quantum/properties/stabilizer/qldpc/qldpc.yml","source_file_modification_token":1687727505573.7388}},"translationally_invariant_stabilizer":{"code_id":"translationally_invariant_stabilizer","name":"Translationally invariant stabilizer code","introduced":"\\cite{arXiv:1101.1962,arXiv:1204.1063,doi:10.7907/GCYW-ZE58}","description":"A geometrically local qubit, modular-qudit, or Galois-qudit stabilizer code with qudits organized on a lattice modeled by the additive group \\(\\mathbb{Z}^D\\) for spatial dimension \\(D\\) such that each lattice point, referred to as a site,\ncontains \\(m\\) qudits of dimension \\(q\\).\nThe stabilizer group of the translationally invariant code is generated by site-local Pauli operators and their translations.\nBoundary conditions have to be imposed on the lattice in order to obtain finite-dimensional codes.\nInfinite dimensional formulations are also possible, with the 1D lattice version reducing to quantum convolutional codes.\n\n\\begin{defterm}{Pauli-to-polynomial mapping}\n\\label{topic:quantum-polynomial-mapping}\nA single-qudit Pauli operator can be specified by the lattice coordinate of the site and the symplectic vector\nrepresentation of the Pauli operator within the site.\nIn an extension of the sympletic representation, each lattice coordinate can be represented by a Laurent monomial of \\(D\\) formal variables. For example, when \\(D=2\\) and \\(m=1\\), the product of an \\(X\\) acting on the qubit at lattice coordinate \\((-1,2)\\) and a \\(Z\\) acting on the qubit at \\((1,0)\\) can be represented by the vector \\( (x^{-1} y^2 | x) \\). The multiplicative group of finitely supported Pauli operators modulo phase factors on the lattice of dimension \\(D\\) with \\(m\\) prime-dimensional qubits per site is isomorphic to the additive group of Laurent polynomial column vectors of length \\(2m\\) in \\(D\\) formal variables (see Ref. \\cite{arXiv:1607.01387} and Sec. IV of Ref. \\cite{arXiv:1812.01625}).\n\\end{defterm}\n\nTranslationally-invariant prime-qudit (\\(q=p\\)) stabilizer codes have been classified in dimensions \\(D\\in\\{1,2\\}\\), up to equivalence under local constant-depth Clifford circuits. Any 1D (2D) code can be converted to several copies of the 1D repetition code (prime-qudit 2D surface code) along with some trivial codes \\cite{arXiv:1607.01387} (\\cite{arXiv:1812.11193}). Three-dimensional qubit codes can be characterized by four\ncoarse classes \\cite{arXiv:1908.08049}:\n\n1. \\textit{Abelian topological phase}: Excitations are mobile in all 3 dimensions, as is typical in a topological code. Such codes are conjectured to be equivalent to a \\(\\mathbb{Z}_2\\) gauge theory, i.e., multiple copies of the 3D surface code or its variant where the charge excitation is a fermion.\n\n2. \\textit{Foliated type-I fracton phase}: Excitations are mobile in less than 3 dimensions, but codes can be grown by \\textit{foliation}, i.e., stacking copies of the 2D surface code.\n\n3. \\textit{Fractal type-I fracton phase}: Excitations are mobile in less than 3 dimensions, and codes are not foliated.\n\n4. \\textit{Type-II fracton phase}: Excitations are not mobile in any dimension and there are no string operators.\n","features":{"decoders":["Clustering decoder \\cite{doi:10.7907/AHMQ-EG82,arXiv:1112.3252}."]},"relations":{"parents":[{"code_id":"qldpc","detail":"Translationally-invariant stabilizer codes are geometrically local."},{"code_id":"quantum_quasi_cyclic","detail":"Translationally-invariant stabilizer codes are invariant under translations by a unit cell."}],"cousins":[{"code_id":"qudit_stabilizer","detail":"Modular-qudit stabilizer codes can be thought of as translationally-invariant stabilizer codes for dimension \\(D = 0\\), with the lattice consisting of a single site."},{"code_id":"surface","detail":"Translation-invariant 2D qubit topological stabilizer codes are equivalent to several copies of the Kitaev surface code via a local constant-depth Clifford circuit \\cite{arXiv:1103.4606,arXiv:1107.2707,arXiv:1607.01387}."},{"code_id":"quantum_double_abelian","detail":"Translation-invariant 2D prime-qudit topological stabilizer codes are equivalent to several copies of the prime-qudit surface code via a local constant-depth Clifford circuit \\cite{arxiv:1812.11193}."},{"code_id":"tqd_abelian","detail":"Translationally-invariant stabilizer codes can realize 2D modular gapped abelian topological orders \\cite{arxiv:2211.03798}. Conversely, abelian TQD codes need not be translationally invariant, and can realize multiple topological phases on one lattice."},{"code_id":"fracton","detail":"Translationally-invariant stabilizer codes can realize fracton orders. Conversely, fracton codes need not be translationally invariant, and can realize multiple phases on one lattice."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-15"},{"user_id":"TonyLau","date":"2022-04-02"}]},"_zoodb":{"id":"translationally_invariant_stabilizer","source_file_path":"codes/quantum/properties/stabilizer/qldpc/translationally_invariant_stabilizer.yml","source_file_modification_token":1687727505573.8706}},"stabilizer":{"code_id":"stabilizer","name":"Stabilizer code","description":"A code whose logical subspace is the joint eigenspace (usually with eigenvalue \\(+1\\)) of a set of commuting unitary operators forming the code's stabilizer group.\nThey can be block codes defined of tensor-product spaces of qubits or qudits, or non-block codes defined on single sufficiently large Hilbert spaces such as bosonic modes or group spaces.\n\nThe coding theory motivation for stabilizer codes came from linear binary codes, whose codewords form a closed subspace in the space of binary strings.\nStabilizer codes extend this property, in various ways, to quantum error correction.\nThe stabilizer formalism is applicable to almost all quantum-code kingdoms; see \\href{https://errorcorrectionzoo.org/list/stabilizer}{list of stabilizer codes} for a list of all stabilizer codes in the zoo.\n\nStabilizer codes were originally defined for qubits, where the relevant commuting operators are tensor products of Pauli matrices.\nThe Pauli stabilizer structure is useful in providing standardized encoding, gates, decoding, and performance bounds.\nElements of this structure remain in qudit extensions, in particular for prime-dimensional modular qudits and Galois qudits.\nOther qubit-based extensions, such as \\hyperref[code:xs_stabilizer]{XS} and \\hyperref[code:xp_stabilizer]{XP} stabilizer codes, relax the mutual commutation property.\nStill other extensions defined for Galois qudits include \\hyperref[code:non_stabilizer]{non-stabilizer codes}.\n","relations":{"parents":[{"code_id":"commuting_projector","detail":"Codespace is the ground-state space of the \\textit{code Hamiltonian}, which consists of an equal linear combination of stabilizer generators and which can be made into a commuting-projector Hamiltonian."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-19"}]},"_zoodb":{"id":"stabilizer","source_file_path":"codes/quantum/properties/stabilizer/stabilizer.yml","source_file_modification_token":1684508734557.0989}},"quantum_into_quantum":{"code_id":"quantum_into_quantum","name":"Quantum code","description":"Code designed for transmission of quantum information through a quantum channel for the purposes of robust storage, communication, or sensing. Transmission can be performed with side information or entanglement.\n","relations":{"parents":[{"code_id":"eacq"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-08"}]},"_zoodb":{"id":"quantum_into_quantum","source_file_path":"codes/quantum/quantum_into_quantum.yml","source_file_modification_token":1668026466467.804}},"crystalline_dynamic_gen":{"code_id":"crystalline_dynamic_gen","physical":"qubits","logical":"qubits","name":"Crystalline-circuit qubit code","introduced":"\\cite{arxiv:2210.10808}","description":"Code dynamically generated by unitary Clifford circuits defined on a lattice with some crystalline symmetry. A notable example is the circuit defined on a rotated square lattice with vertices corresponding to iSWAP gates and edges decorated by \\(R_X[\\pi/2]\\), a single-qubit rotation by \\(\\pi/2\\) around the \\(X\\)-axis. This circuit is invariant under space-time translations by a unit cell \\((T, a)\\) and all transformations of the square lattice point group \\(D_4\\).\n\nThe input state to the circuit is taken to be a product stabilizer state with finite entropy density. If the input is translation-invariant, then this periodicity is preserved by the circuit at all later times, so the code is a quantum quasi-cyclic code with unit cell \\(a\\). The initial product state recurs after a time \\(\\tau(n)\\) that is linear in \\(n\\) for \\(n=a 2^k\\), but is thought to be exponential for generic \\(n\\).\n","protection":"The code protects against Pauli errors. The circuit composed of iSWAP and \\(R_X[\\pi/2]\\) gates on the square lattice is a “good scrambler” with non-fractal operator spreading and thus behaves like a random circuit in that regard, motivating the use of contiguous code distance as a proxy for code distance.\n\nFor the \\(D_4\\) example above, the unit cell \\(a=2\\), and the initial product group is chosen to have code rate \\(1/2\\). The parameters of the code are \\([[n, n/2, d(t)]]\\), and the contiguous code distance \\cite{arxiv:0810.1983} grows linearly before saturating at \\(O(n)\\).\n\nSelecting the code defined by the stabilizer group at the time when the contiguous distance is maximized and subjecting it to random erasures, an optimal threshold of \\(1/4\\) is achieved for a subset of system sizes \\cite{arxiv:1703.01517,arxiv:2010.09775}. The subthreshold scaling is competitive with random codes, which obey the random matrix theory ansatz \\cite{arxiv:2010.09775}.\n","features":{"encoders":["Clifford quantum cellular automaton (CQCA) that preserves crystalline symmetry."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"dynamic_gen"},{"code_id":"translationally_invariant_stabilizer"}],"cousins":[{"code_id":"random_circuit","detail":"Crystalline-circuit codes can be thought of as random-circuit codes with symmetries."},{"code_id":"monitored_random_circuits","detail":"Projective measurements can be included in crystalline-circuit codes in a spacetime translation-invariant fashion, turning such codes into \\textit{monitored crystalline-circuit codes}. However, the unit cell of measurements must be large enough to avoid purification."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-10-19"},{"user_id":"GraceSommers","date":"2022-10-19"}]},"_zoodb":{"id":"crystalline_dynamic_gen","source_file_path":"codes/quantum/qubits/dynamic_gen/crystalline_dynamic_gen.yml","source_file_modification_token":1679678315323.8308}},"floquet":{"code_id":"floquet","physical":"qubits","logical":"qubits","name":"Hasting-Haah Floquet code","short_name":"Floquet","introduced":"\\cite{arXiv:2107.02194}","description":"Dynamically-generated stabilizer-based code whose logical qubits are generated through a particular sequence of check-operator measurements such that the number of logical qubits is larger than when the code is viewed as a static subsystem stabilizer code.\n\nAfter each measurement in the sequence, the codespace is a joint \\(+1\\) eigenspace of an \\textit{instantaneous stabilizer group (ISG)}, i.e., a particular stabilizer group corresponding to the measurement. The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured in the next step in the sequence.\nAs opposed to subsystem codes, only specific measurement sequences maintain the codespace.\n\nA measurement can be interpreted as causing anyon \\hyperref[topic:code-switching]{condensation}, thereby mapping the topoligical phase of a given code state into another condensed phase.\nIn this way, measurements cycle logical quantum information between various \\hyperref[topic:code-switching]{condensed phases} of a parent topological phase \\cite{arxiv:2212.00042}.\n","protection":"Protects against single-qubit Pauli noise and check operator measurement errors.","features":{"fault_tolerance":["Floquet codes on tri-colorable lattices can be made fault-tolerant in the presence of dead qubits \\cite{arxiv:2307.03715}."]},"relations":{"parents":[{"code_id":"crystalline_dynamic_gen","detail":"Floquet codes are crystalline-circuit codes with non-commuting measurements in 2D."}],"cousins":[{"code_id":"subsystem_stabilizer","detail":"This code can be viewed as a subsystem stabilizer code, albeit one with less logical qubits."},{"code_id":"monitored_random_circuits","detail":"Both Floquet and monitored random circuit codes can have an instantaneous stabilizer group which evolves through unitary evolution and measurements. However, Floquet codewords are generated via a specific sequence of measurements, while random-circuit codes maintain a stabilizer group after any measurement. Floquet codes have the additional capability of detecting errors induced during the measurement process; see Appx. A of Ref. \\cite{arxiv:2107.02194}."},{"code_id":"majorana_stab","detail":"Floquet codes are viable candidates for storage in Majorana-qubit devices \\cite{arxiv:2202.11829}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-12"},{"user_id":"VictorVAlbert","date":"2022-01-01"}]},"_zoodb":{"id":"floquet","source_file_path":"codes/quantum/qubits/dynamic_gen/floquet/floquet.yml","source_file_modification_token":1689550329219.0967}},"floquet_color":{"code_id":"floquet_color","physical":"qubits","logical":"qubits","name":"Floquet color code","introduced":"\\cite{doi:10.26081/K6F65V,arxiv:2210.02468,arxiv:2212.00042}","description":"Also called the \\textit{CSS Floquet code}.\nFloquet code on a trivalent lattice whose parent topological phase is the \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) 2D color-code phase and whose measurements cycle logical quantum information between the three \\(\\mathbb{Z}_2\\) surface-code \\hyperref[topic:code-switching]{condensed phases} of the parent phase.\nThe code's ISG is the stabilizer group of one of the three surface codes.\n","features":{"fault_tolerance":["Fault-tolerant measurement-based computation can be realized using the foliated Floquet color code \\cite{arxiv:2212.06775}."]},"realizations":["Plaquette stabilizer measurement realized on the IBM Falcon superconducting-qubit device \\cite{arxiv:2210.13154}"],"relations":{"parents":[{"code_id":"floquet"}],"cousins":[{"code_id":"color","detail":"The parent topological phase of the Floquet color code is the \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) 2D color-code phase."},{"code_id":"surface","detail":"The ISG of the Floquet color code is the stabilizer group of one of three realizations of the \\(\\mathbb{Z}_2\\) 2D surface code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-10-25"}]},"_zoodb":{"id":"floquet_color","source_file_path":"codes/quantum/qubits/dynamic_gen/floquet/floquet_color.yml","source_file_modification_token":1687727505574.111}},"honeycomb":{"code_id":"honeycomb","physical":"qubits","logical":"qubits","name":"Honeycomb Floquet code","introduced":"\\cite{arXiv:2107.02194}","description":"Floquet code based on the Kitaev honeycomb model \\cite{arXiv:cond-mat/0506438} whose logical qubits are generated through a particular sequence of measurements.\n\nThe code is defined on a hexagonal (honeycomb) lattice with a physical qubit located at each vertex. Edges are labeled \\(x\\), \\(y\\), and \\(z\\), such that one edge of each label meet at every vertex. Check operators are defined as \\(XX\\) acting on any two qubits joined by an \\(x\\) edge, and similarly for \\(y\\) and \\(z\\). The hexagonal lattice is 3-colorable, so the hexagons may be labeled 0, 1, 2 such that no two neighboring hexagons have the same label.\n\nThe code-generating measurement pattern consists of measuring the check operators located on all of the \\(r\\)-labeled edges in round \\(r\\) mod 3. The code space is the \\(+1\\) eigenspace of the instantaneous stabilizer group (ISG). The ISG specifies the state of the system as a Pauli stabilizer state at a particular round of measurement, and it evolves into a (potentially) different ISG depending on the check operators measured.\n\nA CSS version of the code has been proposed which loosens the restriction of which sequences to use \\cite{arxiv:2210.02468}.\n","protection":"Protective features similar to the surface code: on a torus geometry, the code protects two logical qubits with a code distance proportional to the linear size of the torus. Properties of the code with open boundaries are discussed in Refs. \\cite{arXiv:2110.09545,arXiv:2110.05348}, and various other generalizations have been proposed \\cite{arxiv:2203.11137}.","features":{"encoders":["Initialization can be performed by preparing each pair of qubits  on an edge in some particular state independently specified by the effective-one-qubit operators (two-qubit Pauli strings centered on an edge) and then beginning the check measurement sequence. This is analogous to projecting a state into the code space by measuring stabilizers."],"general_gates":["There are two types of logical operators, \\textit{inner} and \\textit{outer}. An inner logical operator is the product of check operators on a homologically nontrivial cycle. They belong to the stabilizer group as a subsystem code. Outer logical operators have an interpretation in terms of magnetic and electric operators of an embedded surface code, and they do not belong to the stabilizer group of the associated subsystem code."],"decoders":["The ISG has a static subgroup for all time steps \\(r\\geq 3\\) – that is, a subgroup which remains a subgroup of the ISG for all future times – given by so-called \\textit{plaquette stabilizers}. These are stabilizers consisting of products of check operators around homologically trivial paths. The syndrome bits correspond to the eigenvalues of the plaquette stabilizers. Because of the structure of the check operators, only one-third of all plaquettes are measured each round. The syndrome bits must therefore be represented by a lattice in spacetime, to reflect when and where the outcome was obtained."],"fault_tolerance":["One can run a fault-tolerant decoding algorithm by (1) bipartitioning the syndrome lattice into two graphs which are congruent to the Cayley graph of the free abelian group with three generators (up to boundary conditions) and (2) performing a matching algorithm to deduce errors."],"threshold":["\\(0.2\\%-0.3\\%\\) in a controlled-not circuit model with a correlated minimum-weight perfect-matching decoder \\cite{arXiv:2108.10457}.","\\(1.5\\%<p<2.0\\%\\) in a circuit model with native two-body measurements and a correlated minimum-weight perfect-matching decoder \\cite{arXiv:2108.10457}. Here, \\(p\\) is the collective error rate of the two-body measurement gate, including both measurement and correlated data depolarization error processes.","Against circuit-level noise: within \\(0.2\\% − 0.3\\%\\) for SD6 (standard depolarizing 6-step cycle), \\(0.1\\% − 0.15\\%\\) for SI1000 (superconducting-inspired 1000 ns cycle), and \\(1.5\\% − 2.0\\%\\) for EM3 (entangling-measurement 3-step cycle) \\cite{arxiv:2202.11845,arxiv:2202.11829}."]},"realizations":["Plaquette stabilizer measurement realized on the IBM Falcon superconducting-qubit device \\cite{arxiv:2210.13154}"],"relations":{"parents":[{"code_id":"floquet","detail":"The honeycomb Floquet code is the first 2D Floquet code."},{"code_id":"qudit_znone","detail":"The dynamically generated logical qubit of the honeycomb Floquet code is generated by appropriately scheduling measurements of the gauge generators of the \\(\\mathbb{Z}_{q=2}^{(1)}\\) subsystem stabilizer code corresponding to the Kitaev honeycomb model."}],"cousins":[{"code_id":"surface","detail":"Measurement of each check operator of the honeycomb Floquet code involves two qubits and projects the state of the two qubits to a two-dimensional subspace, which we regard as an effective qubit. These effective qubits form a surface code on a hexagonal superlattice. Electric and magnetic operators on the embedded surface code correspond to outer logical operators of the Floquet code. In fact, outer logical operators transition back and forth from magnetic to electric surface code operators under the measurement dynamics. Inspired by this code, stabilizer measurement circuits consisting of two-body measurements have been designed for the surface code \\cite{arxiv:2007.00307,arxiv:2206.12780}."},{"code_id":"subsystem_color","detail":"Both honeycomb and subsystem color codes are generated via periodic sequences of measurements. However, any measurement sequence can be performed on the color code without destroying the logical qubits, while honeycomb codes can be maintained only with specific sequences. Honeycomb codes require a shorter measurement cycle and use fewer qubits at the given code distance \\cite{arXiv:2107.02194}."},{"code_id":"majorana_stab","detail":"The Honeycomb code admits a convenient representation in terms of Majorana fermions. This leads to a possible physical realization of the code in terms of tetrons \\cite{arXiv:1610.05289}, where each physical qubit is composed of four Majorana modes."},{"code_id":"qldpc","detail":"The Floquet check operators are weight-two, and each qubit participates in one check each round."},{"code_id":"kitaev_honeycomb","detail":"The Kitaev honeycomb model has a Hamiltonian which is the sum of checks of the honeycomb Floquet code \\cite{arxiv:2107.02194}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-28"},{"user_id":"VictorVAlbert","date":"2022-03-02"},{"user_id":"ChrisFechisin","date":"2021-12-13"}]},"_zoodb":{"id":"honeycomb","source_file_path":"codes/quantum/qubits/dynamic_gen/floquet/honeycomb.yml","source_file_modification_token":1681805027419.517}},"haar_random":{"code_id":"haar_random","physical":"qubits","logical":"qubits","name":"Haar-random qubit code","introduced":"\\cite{preset:ShorMSRI,arXiv:quant-ph/0702005,arXiv:quant-ph/0304127,arXiv:0712.2558}","description":"Haar-random codewords are generated in a process involving averaging over unitary operations distributed accoding to the Haar measure. Haar-random codes are used to prove statements about the capacity of a quantum channel to transmit quantum information \\cite{arXiv:1106.1445}, but encoding and decoding in such \\(n\\)-qubit codes quickly becomes impractical as \\(n\\to\\infty\\).\n\nThere are different approaches to create Haar-random codewords. In the construction of Ref. \\cite{arXiv:quant-ph/0702005}, codewords are produced by performing a unitarily covariant projective measurement on a \\textit{typical} subspace of a tensor-power state. Reference \\cite{arXiv:quant-ph/0702005} showed that the capacity of a noisy quantum channel can be achieved by encoding in such Haar-random codes. In particular, Haar-random codes achieve perfect transmission in the \\(n\\to\\infty\\)) limit by proving that the encoded information becomes decoupled from the environment. This is a necessary and sufficient condition for successful decoding since measurements of the environment should never reveal the encoded information \\cite{arxiv:quant-ph/9604022}.\n\nIntuitively, coupling with the environment can be decreased by projecting the system onto a random codespace. The more qubits that are randomly discarded, the more the codespace is decoupled from the environment. One may ask what is the least amount of qubits that can be discarded, i.e. the largest remaining codespace, that still achieves decoupling. It can be shown through the decoupling inequality \\cite{arXiv:quant-ph/0512247} that the largest possible dimension of the random codespace that achieves arbitrarily large decoupling is exponential in the coherent information of the channel. Therefore, there exist codes that can transmit information with rate equal to the coherent information. Furthermore, these codes can be constructed with high probability by performing a Haar-random isometry embedding a \\(k\\)-dimensional logical subspace into an \\(n\\)-dimensional physical space, where \\(k/n\\) is equal to the coherent information. Such an isometry can be produced by QR decomposition of a Gaussian random matrix \\cite{doi:10.1137/0717034}.\n","protection":"Random code achieve the capacity of any noisy quantum channel.","features":{"rate":"The rate of the code is equal to the coherent information of the channel (i.e. the quantum channel capacity)."},"relations":{"parents":[{"code_id":"qubits_into_qubits"},{"code_id":"random_circuit"}],"cousins":[{"code_id":"t-designs","detail":"Approximating the random projections through \\(t\\)-designs is necessary in order to make the protocol practical. Replacing with random Clifford gates is especially convenient since the Clifford group forms a unitary 2-design and produces stabilizer codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-04"},{"user_id":"JonNelson","date":"2021-12-15"}]},"_zoodb":{"id":"haar_random","source_file_path":"codes/quantum/qubits/dynamic_gen/random/haar_random.yml","source_file_modification_token":1679678315324.1943}},"nonlocal_lowdepth":{"code_id":"nonlocal_lowdepth","physical":"qubits","logical":"qubits","name":"Low-depth random Clifford-circuit qubit code","introduced":"\\cite{arXiv:1312.7646}","description":"An \\([[n,k]]\\) qubit stabilizer code whose encoder is an \\(n\\)-qubit unitary transformation that takes a \\(k\\)-qubit state as input (with \\(k\\leq n\\), and the remaining \\(n-k\\) qubits initialized to \\(|0\\rangle^{\\otimes n-k}\\) ) to give a corresponding state in the codespace as the output. An \\(n\\)-qubit quantum circuit with random two-qubit Clifford gates can act as an encoder into a code with distance \\(d\\) with high probability, with a size (i.e. number of gates in the circuit) at most \\(O(n^2 log n)\\)). Noting that two gates acting on disjoint qubits could in fact be executed simultaneously, this is equivalent to the depth (number of time steps in the circuit) being at most \\(O(log^3 n)\\).","protection":"Creates a random \\([[n,k,d]]\\) stabilizer code that detects errors on \\(d-1\\) qubits, and corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.","relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"random_circuit"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-20"},{"user_id":"SrilekhaGandhari","date":"2021-12-14"}]},"_zoodb":{"id":"nonlocal_lowdepth","source_file_path":"codes/quantum/qubits/dynamic_gen/random/nonlocal_lowdepth.yml","source_file_modification_token":1679678315324.2585}},"t-designs":{"code_id":"t-designs","physical":"qubits","logical":"qubits","name":"Local Haar-random circuit qubit code","introduced":"\\cite{doi:10.1007/s00220-016-2706-8}","description":"An \\(n\\)-qubit code whose codewords are a pair of approximately locally indistinguishable states produced by starting with any two orthogonal \\(n\\)-qubit states and acting with a random unitary circuit of depth polynomial in \\(n\\). Two states are \\textit{locally indistinguishable} if they cannot be distinguished by local measurements. A single layer of the encoding circuit is composed of about \\(n/2\\) two-qubit nearest-neighbor gates run in parallel, with each gate drawn randomly from the Haar distribution on two-qubit unitaries.\n\nThe above circuit elements act on nearest-neighbor qubits arranged in a line, i.e., a one-dimensional geometry (\\(D=1\\), while codes for higher-dimensional geometries require \\(O(n^{1/D})\\)-depth circuits \\cite{doi:10.1007/s00220-016-2706-8}. Follow-up work \\cite{arxiv:2010.09775} revealed that optimal code properties require only \\(O(\\sqrt{n})\\)-depth circuits for that case, and \\(O(\\sqrt{n})\\)-depth circuits for a two-dimensional square-lattice geometry.\nThis result has in turn to other types of Pauli noise \\cite{arxiv:2212.05071}, with the previous result holding for erasure noise only. \n","protection":"In a 1D geometry, the code approximately detects any error with support on a segment of length \\(\\leq n/4\\), with deviations exponentially suppressed in \\(n\\).","features":{"encoders":["Random local circuit of depth proportional to \\(n^{\\alpha}\\), with \\(\\alpha\\) depending on system geometry."]},"relations":{"parents":[{"code_id":"qubits_into_qubits"},{"code_id":"random_circuit"}],"cousins":[{"code_id":"topological","detail":"Local Haar-random codewords, like topological codewords, are locally indistinguishable \\cite{doi:10.1007/s00220-016-2706-8}."},{"code_id":"approximate_qecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-14"},{"user_id":"JonathanKunjummen","date":"2021-12-07"}]},"_zoodb":{"id":"t-designs","source_file_path":"codes/quantum/qubits/dynamic_gen/random/t-designs.yml","source_file_modification_token":1679678315324.3289}},"spacetime_circuit":{"code_id":"spacetime_circuit","physical":"qubits","logical":"qubits","name":"Spacetime circuit code","introduced":"\\cite{doi:10.1109/TIT.2017.2663199,arXiv:2210.15844,arXiv:2304.05943}","description":"Qubit stabilizer code used to correct faults in Clifford circuits, i.e., circuits up made of Clifford gates and Pauli measurements.\nThe code utilizes redundancy in the measurement outcomes of a circuit to correct circuit faults.\n\nThe set of measurement outcomes of a circuit can be made into a classical binary linear code called the \\textit{outcome code} \\cite[Corr. 2]{arXiv:2304.05943}.\nThe spacetime circuit code is defined such that its error syndromes can be used to obtain the parity checks of the outcome code.\n\nMore technically, given an \\([m,k]\\) outcome code associated with an \\(n\\)-qubit circuit of depth \\(\\Delta\\) with \\(m\\) measurements and \\(2^k\\) outcomes, the corresponding spacetime circuit code is an \\([[ n (\\Delta + 1), n (\\Delta + 1) - (m - k) ]]\\) code \\cite[Thm. 2]{arXiv:2304.05943}.\n\nThe spacetime circuit code is the stabilizer code corresponding to the subsystem codes of earlier works \\cite{doi:10.1109/TIT.2017.2663199,arXiv:2210.15844}, which dealt with specific families of Clifford circuits.\nThe general case was developed in Ref. \\cite{arXiv:2304.05943}.\n","features":{"decoders":["Efficient decoders can be constructed for some circuits \\cite{arXiv:2304.05943}."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"dynamic_gen"}],"cousins":[{"code_id":"qubit_stabilizer","detail":"Spacetime circuit codes are useful for constructing fault-tolerant syndrome extraction circuits for qubit stabilizer codes."},{"code_id":"binary_linear","detail":"The set of measurement outcomes of a Clifford circuit can be made into a classical binary linear code. Error syndromes of the spacetime circuit code can be used to obtain the parity checks of the outcome code."},{"code_id":"surface","detail":"Stabilizer generators of a spacetime code are called \\textit{detectors} in Refs. \\cite{arxiv:2103.02202,arxiv:2304.05943}."},{"code_id":"floquet","detail":"Spacetime circuit codes are useful for constructing fault-tolerant encoding and syndrome extraction circuits for Floquet codes."},{"code_id":"subsystem_stabilizer","detail":"Spacetime circuit codes can be upgraded to subsystem codes by \\hyperref[topic:gauging-out]{gauging} a subgroup of the logical Pauli group which causes trivial faults in the corresponding Clifford circuit."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-11"}]},"_zoodb":{"id":"spacetime_circuit","source_file_path":"codes/quantum/qubits/dynamic_gen/spacetime_circuit.yml","source_file_modification_token":1683978912609.0415}},"fermions":{"code_id":"fermions","physical":"qubits","logical":"qubits","name":"Fermionic code","description":"Finite-dimensional quantum error-correcting code encoding a logical Hilbert space into a physical Fock space of fermionic modes. Codes are typically described using Majorana operators, which are linear combinations of fermionic creation and annihilation operators \\cite{arXiv:quant-ph/0003137}.","features":{"general_gates":["Clifford operations on fermionic codes can often be formulated using linear optics \\cite{arxiv:quant-ph/0108033,arxiv:quant-ph/0108010,arxiv:quant-ph/0404180}."]},"notes":["See Ref. \\cite{arxiv:1404.0897} for an introduction into Majorana-based qubits."],"relations":{"parents":[{"code_id":"qubits_into_qubits","detail":"The Majorana operator algebra is isomorphic to the qubit Pauli-operator algebra via the Jordan-Wigner transformation \\cite{arXiv:cond-mat/0010440}. However, Majorana codes and the noise they are designed for are based on a different notion of locality."}],"cousins":[{"code_id":"oscillators","detail":"Bosonic (fermionic) codes are associated with bosonic (fermionic) degrees of freedom."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"},{"user_id":"VictorVAlbert","date":"2021-12-01"}]},"_zoodb":{"id":"fermions","source_file_path":"codes/quantum/qubits/fermions/fermions.yml","source_file_modification_token":1671665864794.1816}},"kitaev_chain":{"code_id":"kitaev_chain","physical":"qubits","logical":"qubits","name":"Kitaev chain code","introduced":"\\cite{arXiv:cond-mat/0010440}","description":"An \\([[n,1,1]]_{f}\\) Majorana stabilizer code forming the ground-state of the Kitaev Majorana chain (a.k.a. Kitaev Majorana wire) in its fermionic topological phase, which is equivalent to the 1D quantum Ising model in the symmetry-breaking phase via the Jordan-Wigner transformation.\nThe code is usually defined using the algebra of two anti-commuting Majorana operators called \\textit{Majorana zero modes (MZMs)} or \\textit{Majorana edge modes (MEMs)}.\n\nCodewords have different values of the fermionic parity.\nAs a result, this code is considered unphysical because, in the fermionic context, fermion parity conservation prevents one from realizing coherent superpositions between them.\nHowever, controlling the MZMs associated with this code is an important step to realizing its parent the tetron code, whose codewords have the same parity.\n","protection":"In the fermionic context, code states are insensitive to any local Majorana operator product that respects fermion parity symmetry.\nHowever, the distance is one because the code does not protect against single Majorana operators, which do not commute with the parity symmetry.\n","realizations":["Photonic systems: braiding of defects has been simulated in a device that has a different notion of locality than a bona-fide fermionic system \\cite{arxiv:1411.7751}.","Superconducting circuits: initialization \\cite{arxiv:2206.00563}, braiding \\cite{arxiv:2203.15083} and detection \\cite{arxiv:2203.15083,arxiv:2204.11372} of defects has been simulated in devices that have a different notion of locality than a bona-fide fermionic system."],"notes":["See notes \\cite{arxiv:0904.2771} for a description of this code."],"relations":{"parents":[{"code_id":"mbq","detail":"Kitaev chain codewords can be obtained by restricting to only one Kitaev chain out of the two chains that define the tetron Majorana code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-07"}]},"_zoodb":{"id":"kitaev_chain","source_file_path":"codes/quantum/qubits/fermions/kitaev_chain.yml","source_file_modification_token":1680994436849.1177}},"majorana_stab":{"code_id":"majorana_stab","physical":"qubits","logical":"qubits","name":"Majorana stabilizer code","introduced":"\\cite{arXiv:1004.3791}","description":"A stabilizer code whose stabilizers are products of an even number of Majorana fermion operators, analogous to Pauli strings for a traditional stabilizer code and referred to as \\textit{Majorana stabilizers}.\nThe codespace is the mutual \\(+1\\) eigenspace of all Majorana stabilizers.\nIn such systems, Majorana fermions may either be considered individually or paired into creation and annihilation operators for fermionic modes.\nCodes can be denoted as \\([[n,k,d]]_{f}\\) \\cite{arXiv:1703.00459}, where \\(n\\) is the number of fermionic modes.\n\nIn some cases, Majorana-based stabilizer codes are designed to protect against fermionic noise \\cite{arXiv:cond-mat/0010440} and are thus useful for physical platforms based on fermions.\nIn other cases, Majorana-based frameworks are helpful for understanding conventional qubit stabilizer codes designed for qubit-based platforms.\n","protection":"Detects products of Majorana operators with weight up to \\(d-1\\). Physically, protects against dephasing errors caused by coupling of fermion density to the environment and bit-flip errors caused by quasiparticle poisoning processes.","features":{"general_gates":["Some gates can be implemented through braiding of the computational anyons. Circuit-based gates can be converted into braid patterns via quantum compiling algorithms \\cite{arxiv:2008.10790}."]},"relations":{"parents":[{"code_id":"fermions"},{"code_id":"qubit_stabilizer","detail":"The Majorana stabilizer code is a stabilizer code whose stabilizers are composed of Majorana fermion operators.\nIn addition, any \\([[n,k,d]]\\) stabilizer code can be mapped into a \\([[2n,k,2d]]_{f}\\) Majorana stabilizer code \\cite{arXiv:cond-mat/0506438,arXiv:1004.3791}.\n"}],"cousins":[{"code_id":"dual","detail":"Classical self-orthogonal codes can be used to construct Majorana stabilizer codes \\cite{arXiv:1703.00459}. The direct relationship between the two codes follows from expressing the Majorana strings as binary vectors – akin to the \\hyperref[topic:binary-symplectic-representation]{binary symplectic representation} – and observing that the binary stabilizer matrix \\(S\\) for such a Majorana stabilizer code satisfies \\(S\\cdot S^T=0\\) because it has commuting stabilizers, which is precisely the condition \\(G\\cdot G^T=0\\) on the generator matrix \\(G\\) of a self-orthogonal classical code. A self-orthogonal classical code \\(C\\) with parameters \\([2N,k,d]\\) yields a Majorana stabilizer code with parameters \\([[N,N-k,d^\\perp]]_f\\), where \\(d^\\perp\\) is the code distance of the dual code \\(C^\\perp\\)."},{"code_id":"qubit_css","detail":"When constructing a Majorana stabilizer code from a self-orthogonal classical code with an odd number of bits and generator matrix \\(G\\), a more complex procedure must be applied to ensure that the fermion code has an even number of Majorana zero modes, and thus a physical Hilbert space \\cite{arXiv:1004.3791,arXiv:1703.00459}. Rather than taking \\(G\\) to be the stabilizer matrix as in the even case, we take \\(G\\oplus G\\). This is a concatenation of classical codes as in the CSS construction and it yields a mapping \\([2N-1,k,d]\\rightarrow [[2N-1,2N-1-k,d^\\perp]]_f\\). This procedure may be further generalized by concatenating two different self-orthogonal classical codes with an odd number of bits, as is often done in the CSS construction."},{"code_id":"binary_cyclic","detail":"Cyclic binary linear codes can be used to construct translation-invariant Majorana stabilizer codes, provided that they are also self-orthogonal \\cite{arXiv:1703.00459}."},{"code_id":"reed_muller","detail":"Majorana stabilizer codes can be constructed by self-orthogonal RM codes \\cite{arXiv:1703.00459}. These codes have the additional property that the global fermion parity is fixed in the codespace. In this family of codes, logical measurements are reduced to parity measurements of some subset of Majorana fermions in the code."},{"code_id":"stabilizer","detail":"Majorana stabilizer codes are useful for Majorana-based architectures, where the degrees of freedom are electrons, and the notion of locality is different than all other code kingdoms."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-04"},{"user_id":"VictorVAlbert","date":"2021-12-02"},{"user_id":"ChrisFechisin","date":"2021-11-23"}]},"_zoodb":{"id":"majorana_stab","source_file_path":"codes/quantum/qubits/fermions/majorana_stab.yml","source_file_modification_token":1687727505574.2249}},"mbq":{"code_id":"mbq","physical":"qubits","logical":"qubits","name":"Tetron Majorana code","short_name":"Tetron","introduced":"\\cite{arXiv:cond-mat/0010440,arXiv:1609.01697,arxiv:1610.05289}","description":"Also called a \\textit{Majorana box qubit} or \\textit{Majorana qubit}.\nAn \\([[n,2,2]]_{f}\\) Majorana stabilizer code forming the even-fermion-parity ground-state subspace of two parallel Kitaev Majorana chains in their fermionic topological phase.\nAn extension using three Kitaev chains and housing two logical qubits of the same parity is called the \\textit{hexon Majorana code}.\n","protection":"Single Majorana operators are detectable because they map the even-parity codespace into an odd-parity error space.\n","features":{"general_gates":["Braiding and fusion of MZMs, which act as Ising anyons \\cite{arxiv:1006.4395,arxiv:1511.05153}."],"decoders":["Qubit readout can be done by charge sensing \\cite{arxiv:1511.05153,arXiv:1609.01697,arxiv:1610.05289,arxiv:2004.02124}."]},"relations":{"parents":[{"code_id":"majorana_stab"},{"code_id":"small_distance"},{"code_id":"topological_abelian","detail":"When treated as ground states of the code Hamiltonian, surface codewords realize, codewords of a single Kitaev chain realize \\(\\mathbb{Z}_2\\) fermionic topological order. The MZMs used to define the tetron code act as Ising anyons, which are nonabelian."}],"cousins":[{"code_id":"hamiltonian","detail":"The tetron code forms the ground-state subspace of two Kitaev Majorana chain Hamiltonians."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-07"}]},"_zoodb":{"id":"mbq","source_file_path":"codes/quantum/qubits/fermions/mbq.yml","source_file_modification_token":1680994436849.233}},"cluster_state":{"code_id":"cluster_state","physical":"qubits","logical":"qubits","name":"Cluster-state code","introduced":"\\cite{arxiv:quant-ph/0004051}","description":"Code consisting of cluster states \\cite{arxiv:quant-ph/0004051}, which are stabilizer states defined on a graph. There is one stabilizer generator \\(S_v\\) per graph vertex \\(v\\) of the form\n\\begin{align}\n  S_v = X_{v} \\prod_{w\\in N(v)} Z_w~,\n\\end{align}\nwhere the neighborhood \\(N(v)\\) is the set of vertices which share an edge with \\(v\\).\n\nCluster-state codewords are used in measurement-based quantum computation (MBQC), which substitutes the temporal dimension necessary for decoding with a spatial dimension.\nThis is done by encoding the computation into the topological features of the cluster state''s graph.\n\nAn MBQC scheme can be constructed out of any qubit CSS code (via \\textit{foliation} \\cite{arxiv:1607.02579}) or qubit stabilizer code \\cite{arxiv:1811.11780}.\nThe original MBQC scheme \\cite{arxiv:quant-ph/0510135,arxiv:quant-ph/0610082} uses the RBH cluster state on the bcc lattice (equivalently, a cubic lattice with qubits on edges and faces).\n","protection":"Protection is related to the stabilizer code underlying the cluster state.\nThere is no physical error correction, and decoding output is simply used to update the Pauli frame.\n","features":{"encoders":["Initialization of all qubits in the \\(|+\\rangle\\) state and action of \\(CZ\\) gates along the edges of the graph."],"general_gates":["The computation encoded in pre-determined fashion via topological features of the cluster state's graph, such as boundaries, defects, or twists. Such features can be created using \\(Z\\)-type measurements, which effectively cut a qubit off from the cluster state. Non-Clifford gates are performed by inserting non-Clifford states into particular \\textit{singular} qubits. More generally, any gate protocol of a qubit stabilizer code yields an MBQC protocol \\cite{arxiv:1811.11780}.\nTo perform the computation, subsets qubits are measured, e.g., along one two-dimensional slice of a 3D lattice for each time step. This effectively teleports the logical information into the remaining unmeasured portion of the cluster state. The computation terminates after all qubits are measured.\nThe entire cluster state does not need to be created at the start of the computation. Instead, the portion of the cluster state in the extra dimension can be initialized as the computation progresses."],"decoders":["MBQC syndrome extraction is performed by multiplying certain single-qubit \\(X\\)-type measurements, which yield syndrome values."],"code_capacity_threshold":["Independent \\(X,Z\\) noise: \\(p_X = 2.9\\%\\) under MWPM decoding \\cite{arxiv:quant-ph/0510135}. The threshold under ML decoding corresponds to the value of critical point of the 3D random-plaquette \\(\\mathbb{Z}_2\\) gauge theory (3D-RPGM) via the statistical mechanical mapping \\cite{arxiv:quant-ph/0110143}, calculated to be \\(3.3 \\%\\) \\cite{arxiv:quant-ph/0401101} (see also \\cite{arxiv:cond-mat/0501372})."],"fault_tolerance":["Generalized foliation procedures exist for noise-bias preserving MBQC \\cite{arxiv:2201.10566}."]},"relations":{"parents":[{"code_id":"qubit_stabilizer","detail":"Cluster states are particular qubit stabilizer states defined on a graph. Conversely, any fault-tolerant scheme based on qubit stabilizer codes can be mapped into a cluster-state based MBQC protocol \\cite{arxiv:1811.11780}."}],"cousins":[{"code_id":"fusion","detail":"FBQC and MBQC are both computational models in which computation is done by measuring resource states (which are qubit stabilizer states). The difference from ordinary MBQC is that error-correction two-qubit measurements are performed, which requires a foliation with more qubits but one which can be built by fusing smaller modules."},{"code_id":"qubit_css","detail":"A resource cluster state can be constructed out of any qubit CSS code via foliation. Conversely, CSS codes can be constructed out of cluster states \\cite{arxiv:1607.02579}."},{"code_id":"gkp-cluster-state","detail":"The GKP cluster-state code is a concatenation of a cluster-state stabilizer code with a single-mode GKP code."},{"code_id":"dynamic_gen","detail":"MBQC is done using a measurement-based dynamical process."},{"code_id":"dual_rail","detail":"MBQC can be achieved with dual-rail codes using linear optical elements and photon detectors \\cite{arxiv:quant-ph/0405157}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-01"},{"user_id":"YaronJarach","date":"2023-03-01"},{"user_id":"VictorVAlbert","date":"2023-03-01"}]},"_zoodb":{"id":"cluster_state","source_file_path":"codes/quantum/qubits/mbqc/cluster_state.yml","source_file_modification_token":1681484685083.2686}},"fusion":{"code_id":"fusion","physical":"qubits","logical":"qubits","name":"Fusion-based quantum computing (FBQC) code","short_name":"FBQC","introduced":"\\cite{arXiv:2101.09310}","description":"Code whose codewords are resource states used in an FBQC scheme. Related to a cluster state via Hadamard transformations.\n\nFBQC is a fault tolerant way to produce \\textit{fusion networks}, or large entangled resource states starting from small constant-sized entangled resource states along with destructive measurements called \\textit{fusions}.\nThese large states can be produced asychronously in the fusion framework and can be used as resources, as in measurement-based quantum computation (MBQC), or as logical states of topological codes.\nThe difference from ordinary MBQC is that error-correction two-qubit measurements are performed, which requires a foliation with more qubits.\nThe use of two-qubit measurements makes FBQC more compatible with photonic platforms.\n","protection":"Protects against erasure, Pauli errors, photon loss, fusion failure from non-determinism, and faulty resource states. Redundancy in fusion outcomes is captured by the check operator group. Fusion measurement outcomes form a syndrome that allows to correct for Pauli errors. There is no physical error correction, and decoding output is simply used to update the Pauli frame.","features":{"encoders":["Resource state generators, which produce small constant size cluster states, and Fusion measurements (Bell fusions)."],"general_gates":["Clifford gates are performed by creating topological features such as boundaries, defects, or twists, which can be done by single qubit measurements. Logical gates can also be performed by code deformation.\nNon Clifford gates are perfomed by magic-state injection."],"fault_tolerance":["Fusion networks are constructed in a fault tolerant way (as a stabilizer code), and they can be created in a way that naturally encodes topological fault tolerance."],"threshold":["\\(11.98\\%\\) against erasure in fusion measurements.","\\(1.07\\%\\) against Pauli error.","In linear optical systems, can tolerate \\(10.4\\%\\) probability of photon loss in each fusion.","\\(43.2\\%\\) against fusion failure.","FBQC applied to the surface code yields thresholds for logical gates that is consistent with the code capacity threshold \\cite{arxiv:2112.12160}."]},"relations":{"parents":[{"code_id":"qubit_stabilizer","detail":"The resource states in FBQC are small stabilizer states, and after fusion measurements, the outputs are stabilizers (conditioned on measurement outcomes)."}],"cousins":[{"code_id":"topological","detail":"Arbitrary topological codes can be created using FBQC, as can topological features such as defects and boundaries, by modifying fusion measurements or adding single qubit measurements."},{"code_id":"dual_rail","detail":"FBQC resource states are concatenated with dual-rail codes to increase loss detection."},{"code_id":"dynamic_gen","detail":"Building a fusion network is done using a measurement-based dynamical process."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-01"},{"user_id":"YaronJarach","date":"2023-03-01"},{"user_id":"VictorVAlbert","date":"2021-12-30"},{"user_id":"DhruvDevulapalli","date":"2021-12-17"}]},"_zoodb":{"id":"fusion","source_file_path":"codes/quantum/qubits/mbqc/fusion.yml","source_file_modification_token":1679678315324.5327}},"rbh":{"code_id":"rbh","physical":"qubits","logical":"qubits","name":"Raussendorf-Bravyi-Harrington (RBH) cluster-state code","short_name":"RBH","introduced":"\\cite{arxiv:quant-ph/0407255,arxiv:quant-ph/0510135,arxiv:quant-ph/0610082}","description":"Also called an \\textit{RHG (Raussendorf-Harrington-Goyal) cluster-state code}.\nA three-dimensional cluster-state code defined on the bcc lattice (equivalently, a cubic lattice with qubits on edges and faces).\n\nThe MBQC version of the code is defined as the unique ground state of a certain code Hamiltonian. This state is the resource state used in the first MBQC scheme \\cite{arxiv:quant-ph/0510135,arxiv:quant-ph/0610082}.\nIt encodes the temporal gate operations on the surface code into a third spatial dimension.\n\nAddition of certain boundary Hamiltonians yields a degenerate ground-state space that serves as an example of a symmetry-protected self-correcting memory \\cite{arXiv:1805.01474}.\n","protection":"Exhibits symmetry-protected self-correction \\cite{arXiv:1805.01474}. The energy barrier for symmetry-preserving excitations outside of the code space grows linearly with the lattice width. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the lattice width.\n","features":{"general_gates":["The computation encoded in pre-determined fashion via topological features of the lattice, such as boundaries, defects, or twists. For example, qubits may be encoded in 2D defects along slices of the surface code, and Clifford gates are encoded by spatially braiding the defects along the 3rd dimension. Non-Clifford gates are performed by inserting non-Clifford states into particular \\textit{singular} qubits.\nTo perform the computation, qubits along the extra dimension are measured, e.g., along one two-dimensional slice per time step. This effectively teleports the logical information into the remaining unmeasured portion of the cluster state."],"decoders":["MBQC syndrome extraction consists of single-qubit measurements and classical post-processing. The six \\(X\\)-measurements of qubits on the faces of a cube of the bcc lattice multiply to the product of the six cluster-state stabilizers whose vertices are on the faces of the cube. Such measurements, if done on a 2D slice, also yield \\(Z\\)-type syndromes on the next slice.","Minimum weight perfect-matching (MWPM) \\cite{arXiv:quant-ph/0110143,arXiv:1307.1740} (based on work by Edmonds on finding a matching in a graph \\cite{doi:10.4153/CJM-1965-045-4,doi:10.6028/jres.069B.013})."]},"relations":{"parents":[{"code_id":"cluster_state"},{"code_id":"walker_wang","detail":"The Walker-Wang model code reduces to the RBH cluster-state code when the input category \\(\\mathcal{C}\\) is that of the surface code \\cite[Sec. V.A]{arxiv:2011.04693}."}],"cousins":[{"code_id":"symmetry_protected_self_correct","detail":"The RBH code can exhibit self-correction protected by a certain symmetry."},{"code_id":"subsystem_color","detail":"The RBH code for a certain boundary Hamiltonian is dual to the gauge color code \\cite[Sec. IV.C.1]{arxiv:1805.01474}."},{"code_id":"surface","detail":"The RBH state encodes the temporal gate operations on the surface code into a third spatial dimension \\cite{arxiv:quant-ph/0510135,arxiv:quant-ph/0610082}. In addition, one of possible 2D boundaries of the RBH code is effectively a 2D toric code."},{"code_id":"bcc","detail":"The RBH code is defined on the bcc lattice."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-18"},{"user_id":"YiTingRickTu","date":"2022-04-23"}]},"_zoodb":{"id":"rbh","source_file_path":"codes/quantum/qubits/mbqc/rbh.yml","source_file_modification_token":1680994436849.4243}},"cws":{"code_id":"cws","physical":"qubits","logical":"qubits","name":"Codeword stabilized (CWS) code","short_name":"CWS","introduced":"\\cite{arXiv:0708.1021}","description":"This family of codes strictly generalizes stabilizer codes. They are usually denoted by \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\) where \\(\\mathcal{G}\\) is a graph and \\(\\mathcal{C}\\) is a \\( (n,K,d) \\) binary classical code. From the graph we form the unique graph state (stabilizer state) \\( |G \\rangle \\). From the classical code we form Pauli \\(Z\\)-type operators \\( W_i = Z^{c_{i,1}} \\otimes \\cdots \\otimes Z^{c_{i,n}} \\), where \\(c_{i,j} \\) is the \\(j\\)-th bit of the \\(i\\)-th classical codeword. The CWS codewords are then \\( | i \\rangle =  W_i | G \\rangle \\).\n\nThere is an alternative description to the one above that is locally Clifford-equivalent. In particular, we can describe CWS codes as \\( \\mathcal{Q} = (S,\\mathcal{W})\\) where \\(S\\) is a stabilizer group and \\( \\mathcal{W} = \\{ w_\\ell \\}_{\\ell = 1}^K \\) is a family of \\(K\\) \\(n\\)-qubit Pauli strings. We then form CWS codeswords as \\( | i \\rangle = w_i | S \\rangle \\), where \\( | S \\rangle \\) is the (unique) stabilizer state of \\(S\\).\n","protection":"Code distance \\(\\mathcal{Q} = ( \\mathcal{G},\\mathcal{C}) \\) is upper bounded by the distance of the classical code \\(\\mathcal{C} \\). The \\hyperref[code:qubits_into_qubits]{diagonal distance} is upper bounded by \\(\\delta + 1\\), where \\(\\delta\\) is the minimum degree of \\(\\mathcal{G}\\). Computing the distance is generally NP-complete, and is \\(NP\\)-hard for non-degenerate codes \\cite{arXiv:2203.04262}.","features":{"encoders":["If \\( \\mathcal{C} \\) has an efficient classical encoder, then so does the CWS code \\( \\mathcal{Q} = (\\mathcal{G},\\mathcal{C}) \\)."],"decoders":["There is no known \\textit{efficient} algorithm to decode \\textit{non-additive} (non-stabilizer) CWS codes."]},"notes":["See Ref. \\cite{doi:10.1017/CBO9781139034807.012} for an introduction to CWS codes."],"relations":{"parents":[{"code_id":"qubits_into_qubits"}],"cousins":[{"code_id":"movassagh_ouyang","detail":"The Movassagh-Ouyang codes overlap the CWS codes but neither family is contained in the other."},{"code_id":"spacetime","detail":"CWS codes have been considered in the context of spacetime replication of quantum data \\cite{arxiv:1210.0913,arXiv:1601.02544}, while STCs are designed to replicate classical data."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-21"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"EricKubischta","date":"2021-12-15"}]},"_zoodb":{"id":"cws","source_file_path":"codes/quantum/qubits/nonstabilizer/cws.yml","source_file_modification_token":1681484685083.3723}},"eth":{"code_id":"eth","physical":"qubits","logical":"qubits","name":"Eigenstate thermalization hypothesis (ETH) code","short_name":"ETH","introduced":"\\cite{arxiv:1710.04631}","description":"Also called a \\textit{thermodynamic code} \\cite{arxiv:1902.07714}. An \\(n\\)-qubit approximate code whose codespace is formed by eigenstates of a translationally-invariant quantum many-body system which satisfies the Eigenstate Thermalization Hypothesis (ETH). ETH ensures that codewords cannot be locally distinguished in the thermodynamic limit. Relevant many-body systems include 1D non-interacting spin chains, Motzkin chains, or Heisenberg models.\n\nETH requires that for ordered energy eigenstates \\(|E_l\\rangle\\) and any local observable \\(O\\),\n\\begin{align}\n|\\langle E_l|O|E_l\\rangle-\\langle E_{l+1}|O|E_{l+1}\\rangle|\\leq\\exp(-cn)\n\\end{align}\nfor a constant \\(c\\). This implies that energy eigenstates around some energy \\(\\bar E\\) are approximately locally indistinguishable from one another, as their reduced density matrices on any subsystem are both approximately thermal at energy \\(\\bar E\\). In this way, global information is protected from local measurements by the environment as \\(n\\to\\infty\\).\n","protection":"Approximately protects against erasure errors at known locations. Translation invariance alone is sufficient for good approximate error-correcting properties in a many-body spectrum, including in integrable models \\cite{arxiv:1710.04631}. The ETH code generated from the spectrum of the translation-invariant 1D Heisenberg spin chain \\cite{arxiv:1710.04631} has recovery infidelity (against the erasure of a constant number of sites) scale as \\(\\epsilon_\\text{worst}=O(1/n)\\) \\cite{arxiv:1902.07714}.","features":{"decoders":["An explicit universal recovery channel for the ETH code is given in \\cite{arXiv:1906.03669}."]},"relations":{"parents":[{"code_id":"qubits_into_qubits"},{"code_id":"hamiltonian","detail":"ETH codewords are eigenstates of a local Hamiltonian whose eigenstates satisfy ETH."},{"code_id":"approximate_qecc","detail":"ETH codes approximately protect against erasures in the thermodynamic limit."}],"cousins":[{"code_id":"topological","detail":"ETH codewords, like topological codewords, are locally indistinguishable."},{"code_id":"permutation_invariant","detail":"Several instances of ETH codes contain permutation-invariant codewords."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-01"},{"user_id":"ChrisFechisin","date":"2021-12-13"}]},"_zoodb":{"id":"eth","source_file_path":"codes/quantum/qubits/nonstabilizer/eth.yml","source_file_modification_token":1679678315324.7886}},"icosahedral_permutation_invariant":{"code_id":"icosahedral_permutation_invariant","physical":"qubits","logical":"qubits","name":"\\(((7,2,3))\\) permutation-invariant code","introduced":"\\cite{arxiv:quant-ph/0304153,arXiv:2005.10910,arxiv:2305.07023}","description":"Seven-qubit code designed to realize gates from the binary icosahedral group transversally.\nCan also be interpreted as a spin-\\(7/2\\) spin code.\nThe codespace projection is a projection onto an irrep of the binary icosahedral group \\(2I\\).\n\nIn terms of Dicke states, the unnormalized logical states of one version \\cite{arxiv:2305.07023} of this code are\n\\begin{align}\n  \\begin{split}\n    |0_{L}\\rangle&\\propto15|D_{0}^{7}\\rangle+3\\sqrt{35}|D_{4}^{7}\\rangle\\\\&\\quad+\\sqrt{105}\\;|D_{2}^{7}\\rangle-3\\sqrt{35}|D_{6}^{7}\\rangle\\,,\\\\|1_{L}\\rangle&\\propto X^{\\otimes7}|0_{L}\\rangle\\,.\n  \\end{split}\n\\end{align}\n","features":{"transversal_gates":"Binary icosahedral group \\(2I\\) gates can be realized transversally \\cite{arxiv:2305.07023}."},"relations":{"parents":[{"code_id":"qubits_into_qubits"},{"code_id":"j_gross","detail":"The \\(((7,2,3))\\) permutation-invariant code can be interpreted as a spin-\\(7/2\\) Clifford code \\cite{arXiv:2005.10910}."},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-12"}]},"_zoodb":{"id":"icosahedral_permutation_invariant","source_file_path":"codes/quantum/qubits/nonstabilizer/icosahedral_permutation_invariant.yml","source_file_modification_token":1683978912609.1165}},"movassagh_ouyang":{"code_id":"movassagh_ouyang","physical":"qubits","logical":"qubits","name":"Movassagh-Ouyang Hamiltonian code","introduced":"\\cite{arXiv:2012.01453}","description":"This is a family of codes derived via an algorithm that takes as input \\textit{any} binary classical code and outputs a quantum code (note that this framework can be extended to \\(q\\)-ary codes). The algorithm is probabalistic but succeeds almost surely if the classical code is random. An explicit code construction does exist for linear distance codes encoding one logical qubit. For finite rate codes, there is no rigorous proof that the construction algorithm succeeds, and approximate constructions are described instead.\n\nThis family strictly generalizes CSS codes (because CSS codes come only from linear or self orthogonal classical codes). These codes can be shown to be realized as a subspace of the ground space of a (geometrically) local Hamiltonian.\n","protection":"Let \\(C \\subset \\{0,1,\\dots,q-1\\}^n\\) be a classical code with distance \\(d_x\\). Let \\(d_z\\) satisfy \\(q^n > 2 V_q(d_z-1) -1\\), where \\(V_q(r)\\) is the volume of the \\(q\\)-ary Hamming ball of radius \\(r\\). Then the algorithm produces a quantum code with distance \\(d = \\text{min}(d_x,d_z)\\). Asymptotically, the distance scales linearly with \\(n\\).","features":{"rate":"The rate depends on the classical code, but distance can scale linearly with \\(n\\)."},"relations":{"parents":[{"code_id":"qubits_into_qubits"},{"code_id":"hamiltonian","detail":"Movassagh-Ouyang codes reside in the ground space of a Hamiltonian."}],"cousins":[{"code_id":"qubit_stabilizer","detail":"Many, but not all, Movassagh-Ouyang codes are stabilizer codes."},{"code_id":"bits_into_bits","detail":"Movassagh-Ouyang codes are constructed from classical binary codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"EricKubischta","date":"2021-12-15"}]},"_zoodb":{"id":"movassagh_ouyang","source_file_path":"codes/quantum/qubits/nonstabilizer/movassagh_ouyang.yml","source_file_modification_token":1673511200349.9988}},"mps":{"code_id":"mps","physical":"qubits","logical":"qubits","name":"Matrix-product state (MPS) code","short_name":"MPS","introduced":"\\cite{arxiv:1902.02115}","description":"Also called a \\textit{magnon code}. An \\(n\\)-qubit approximate code whose codespace of \\(k=\\Omega(\\log n)\\) qubits is efficiently described in terms of matrix product states (MPS) or Bethe ansatz tensor networks.\nA no-go theorem states that open-boundary MPS that form a degenerate ground-state space of a gapped local Hamiltonian yield codes with distance that is only constant in the number of qubits \\(n\\), so MPS excitation ansatze have to be used to achieve a distance scaling nontrivially with \\(n\\).\n","protection":"Distance \\(d=\\Omega(n^{1-\\nu})\\) for any \\(\\nu\\in(0,1)\\).","relations":{"parents":[{"code_id":"qubits_into_qubits"},{"code_id":"hamiltonian","detail":"MPS codewords are low-energy excited states of a local Hamiltonian."},{"code_id":"approximate_qecc","detail":"MPS codes approximately protect against erasures in the thermodynamic limit."}],"cousins":[{"code_id":"eth","detail":"MPS codes have been shown to protect against non-geometrically local noise, while ETH codes protect only against erasures on geometrically local patches."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-28"}]},"_zoodb":{"id":"mps","source_file_path":"codes/quantum/qubits/nonstabilizer/mps.yml","source_file_modification_token":1679678315324.871}},"xp_stabilizer":{"code_id":"xp_stabilizer","physical":"qubits","logical":"qubits","name":"XP stabilizer code","introduced":"\\cite{arXiv:2203.00103}","description":"The XP Stabilizer formalism is a generalization of the XS and Pauli stabilizer formalisms, with stabilizer generators taken from the group \\( \\{\\omega I, X, P\\}^{\\otimes n} \\). Here, \\( \\omega \\) is a \\( 2N \\) root of unity, and \\( P = \\text{diag} ( 1, \\omega^2) \\). The codespace is a \\(+1\\) eigenspace of a set of XP stabilizer generators, which need not commute to define a valid codespace.\n\nXP stabilizer codes are classified into XP-regular and XP-non-regular, where the former can be mapped to a CSS code with similar logical operator structure.\n","relations":{"parents":[{"code_id":"qubits_into_qubits"}],"cousins":[{"code_id":"qubit_css","detail":"Each XP-regular code can be mapped to a CSS code with a similar logical operator structure \\cite{arXiv:2203.00103}."},{"code_id":"cws","detail":"The orbit representatives of XP codes play a similar role to the word operators of CWS codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-19"},{"user_id":"MuhammadJunaidAftab","date":"2022-04-15"}]},"_zoodb":{"id":"xp_stabilizer","source_file_path":"codes/quantum/qubits/nonstabilizer/xp_stabilizer.yml","source_file_modification_token":1681484685083.4666}},"xs_stabilizer":{"code_id":"xs_stabilizer","physical":"qubits","logical":"qubits","name":"XS stabilizer code","introduced":"\\cite{arXiv:1404.5327}","description":"A type of stabilizer code where stabilizer generators are elements of the group \\( \\{\\alpha I, X, \\sqrt{Z}]\\}^{\\otimes n} \\), with \\( \\sqrt{Z} = \\text{diag} (1, i)\\). The codespace is a joint \\(+1\\) eigenspace of a set of stabilizer generators, which need not commute to define a valid codespace.\n","relations":{"parents":[{"code_id":"xp_stabilizer","detail":"The XP stabilizer formalism reduces to the XS formalism at \\(N=4\\)."}],"cousins":[{"code_id":"tqd_abelian","detail":"TQD models for the groups \\(\\mathbb{Z}_2^k\\) can be realized as XS stabilizer codes \\cite{arXiv:1404.5327}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-19"}]},"_zoodb":{"id":"xs_stabilizer","source_file_path":"codes/quantum/qubits/nonstabilizer/xs_stabilizer.yml","source_file_modification_token":1680994436849.5217}},"qubits_into_qubits":{"code_id":"qubits_into_qubits","physical":"qubits","logical":"qubits","name":"Qubit code","description":"Encodes \\(K\\)-dimensional Hilbert space into a \\(2^n\\)-dimensional (i.e., \\(n\\)-qubit) Hilbert space. Usually denoted as \\(((n,K))\\) or \\(((n,K,d))\\), where \\(d\\) is the code's distance.\n","protection":"Corrects erasure errors on up to \\(d-1\\) qubits.\nThe number of correctable errors is often called the \\textit{decoding radius}, and it is upper bounded by half of the code distance.\nAs a result, qubit codes cannot tolerate adversarial errors on more than \\((1-R)/4\\) registers.\n\nA convenient and often considered error set is the \\textit{Pauli error} or \\textit{Pauli string} basis. For a single qubit, this set consists of products of powers of the Pauli matrices\n\\begin{align}\n  X=\\begin{pmatrix}0 & 1\\\\\n  1 & 0\n  \\end{pmatrix}\\,\\,\\text{ and }\\,\\,Z=\\begin{pmatrix}1 & 0\\\\\n  0 & -1\n  \\end{pmatrix}~.\n\\end{align}\nFor multiple qubits, error set elements are tensor products of elements of the single-qubit error set.\n\nThe Pauli error set is a unitary and Hermitian basis for linear operators on the multi-qubit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a prototypical nice error basis \\cite{arxiv:quant-ph/9608048,arxiv:quant-ph/9608049,arxiv:quant-ph/0010082}. The distance associated with this set is often the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.\n\nThe minimum weight of a Pauli error that has a non-zero expectation value for some code basis state is called the \\textit{diagonal distance} \\cite{arXiv:2107.11286}. Codes whose distance is greater than the diagonal distance are degenerate.\n","features":{"decoders":["The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}. For few-qubit codes (\\(n\\) is small), maximum-likelihood decoding can be based by creating a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used."],"fault_tolerance":["There are lower bounds on the overhead of fault-tolerant QEC in terms of the capacity of the noise channel \\cite{arxiv:2202.00119}. A more stringent bound applies to geometrically local QEC due to the fact that locality constrains the growth of the entanglement that is needed for protection \\cite{arxiv:2302.04317}."]},"notes":["There is a relation between one-way entanglement distillation protocols and QECCs \\cite{arXiv:quant-ph/9604024}."],"relations":{"parents":[{"code_id":"qudits_into_qudits","detail":"Modular-qudit quantum codes for \\(q=2\\) correspond to qubit codes."},{"code_id":"galois_into_galois","detail":"Galois-qudit quantum codes for \\(q=2\\) correspond to qubit codes."},{"code_id":"spins_into_spins","detail":"Spin codes with spin \\(\\ell=1/2\\) correspond to qubit codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-08"},{"user_id":"SamGunn","date":"2022-01-08"},{"user_id":"VictorVAlbert","date":"2022-05-07"},{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"qubits_into_qubits","source_file_path":"codes/quantum/qubits/qubits_into_qubits.yml","source_file_modification_token":1679678315326.8044}},"diagonal_clifford":{"code_id":"diagonal_clifford","physical":"qubits","logical":"qubits","name":"\\([[2^r-1, 1, 3]]\\) quantum Reed-Muller code","short_name":"\\([[2^r-1, 1, 3]]\\)","introduced":"\\cite{arxiv:quant-ph/9908010,arXiv:quant-ph/0611214}","description":"Member of CSS code family constructed with a first-order punctured RM\\((1,r)\\) \\([2^r-1,r+1,2^{r-1}-1]\\) code and its even subcode for \\(r \\geq 3\\). Each code transversally implements a member of an infinite family of diagonal gates from the Clifford hierarchy \\cite{arxiv:1608.06596}.","features":{"transversal_gates":"\\(Z\\)-rotation by angle \\(-\\pi/2^{r-1}\\) \\cite{arxiv:quant-ph/0611214}. These are the smallest qubit stabilizer codes with such a gate \\cite{arxiv:2210.14066}."},"relations":{"parents":[{"code_id":"quantum_reed_muller"},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-15"}]},"_zoodb":{"id":"diagonal_clifford","source_file_path":"codes/quantum/qubits/rm/diagonal_clifford.yml","source_file_modification_token":1677058672668.496}},"quantum_hamming_css":{"code_id":"quantum_hamming_css","physical":"qubits","logical":"qubits","name":"\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS code","short_name":"\\([[2^r-1, 2^r-2r-1, 3]]\\)","introduced":"\\cite{arxiv:quant-ph/9605021}","description":"CCS code constructed with a classical Hamming code \\([2^r-1,2^r-1-r,3]=C_X=C_Z\\) \\textit{a.k.a.} a first-order punctured Reed-Muller code RM\\((r-2,r)\\).","protection":"Protects against any single qubit error.","features":{"transversal_gates":"Pauli, Hadamard, and CNOT gates.","decoders":["Efficient decoder \\cite{arxiv:2207.08826}."],"fault_tolerance":["Syndrome measurement can be done with two ancillary flag qubits \\cite{arxiv:1705.02329}.","Concatenations of Hamming-based CSS codes yield fault-tolerant quantum computation with constant space and quasi-polylogarithmic time overheads \\cite{arxiv:2207.08826}."],"threshold":["Concatenated thresholds requiring constant-space and quasi-polylogarithmic time overhead \\cite{arxiv:2207.08826}."]},"relations":{"parents":[{"code_id":"quantum_reed_muller","detail":"\\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS codes are quantum Reed-Muller codes because they are formed from classical Hamming codes, which are equivalent to RM\\((r-2,r)\\)."},{"code_id":"qudit_hamming_css","detail":"\\([[2^r-1, 2^r-2r-1, 3]]_p\\) prime-qudit CSS code for \\(p=2\\) reduce to \\([[2^r-1, 2^r-2r-1, 3]]\\) Hamming-based CSS codes."}],"cousins":[{"code_id":"hamming","detail":"Quantum Hamming codes result from applying the CSS construction to Hamming codes."}]},"_meta":{"changelog":[{"user_id":"QingfengKeeWang","date":"2022-01-07"},{"user_id":"VictorVAlbert","date":"2021-12-30"}]},"_zoodb":{"id":"quantum_hamming_css","source_file_path":"codes/quantum/qubits/rm/quantum_hamming_css.yml","source_file_modification_token":1680994436849.9973}},"quantum_reed_muller":{"code_id":"quantum_reed_muller","physical":"qubits","logical":"qubits","name":"Quantum Reed-Muller code","introduced":"\\cite{arXiv:quant-ph/9608026}","description":"A CSS code formed from a classical Reed-Muller code (or its punctured versions) in which polynomials over finite fields encode data. This is done by transforming these polynomials into the stabilizer generator matrices.","protection":"Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.","features":{"rate":"\\(\\frac{k}{n}\\), where \\(k = 2^r - {r \\choose t} + 2 \\sum_{i=0}^{t-1} {r \\choose i}\\). Additionally, CSS codes formed from binary Reed-Muller codes achieve channel capacity on erasure channels \\cite{arXiv:1601.04689}.","general_gates":["Magic state distillation in all prime dimensions \\cite{doi:10.1103/PhysRevX.2.041021}"],"fault_tolerance":["Gate switching protocol for universal computation \\cite{arxiv:1403.2734}."],"threshold":["Between \\(10^{-3}\\) and \\(10^{-6}\\) for depolarizing noise (assuming ideal decoders), see \\cite{doi:10.1088/2058-9565/abb027}"]},"relations":{"parents":[{"code_id":"qubit_css"}],"cousins":[{"code_id":"reed_muller"},{"code_id":"quantum_convolutional","detail":"Quantum convolutional codes can be derived from quantum Reed-Muller codes \\cite{arxiv:quant-ph/0701037}."}]},"_meta":{"changelog":[{"user_id":"BenjaminQuiring","date":"2021-12-16"},{"user_id":"VictorVAlbert","date":"2021-12-03"}]},"_zoodb":{"id":"quantum_reed_muller","source_file_path":"codes/quantum/qubits/rm/quantum_reed_muller.yml","source_file_modification_token":1681484685083.563}},"single_qubit_clifford":{"code_id":"single_qubit_clifford","physical":"qubits","logical":"qubits","name":"\\([[2^{2r-1}-1,1,2^r-1]]\\) quantum punctured Reed-Muller code","short_name":"\\([[2^{2r-1}-1,1,2^r-1]]\\)","introduced":"\\cite[Ch. 7]{preset:PreskillNotes}","description":"Member of CSS code family constructed with a punctured self-dual RM \\([2^r-1,2^{r-1},\\sqrt{2}^{r-1}-1]\\) code and its even subcode for \\(r \\geq 2\\).\n","features":{"transversal_gates":"All single-qubit Clifford gates."},"relations":{"parents":[{"code_id":"quantum_reed_muller"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-17"},{"user_id":"IanTeixeira","date":"2021-11-17"},{"user_id":"VictorVAlbert","date":"2022-11-15"}]},"_zoodb":{"id":"single_qubit_clifford","source_file_path":"codes/quantum/qubits/rm/single_qubit_clifford.yml","source_file_modification_token":1670025425882.3809}},"quantum_h":{"code_id":"quantum_h","physical":"qubits","logical":"qubits","name":"\\([[k+4,k,2]]\\) H code","short_name":"\\([[k+4,k,2]]\\)","introduced":"\\cite{arXiv:1210.3388}","description":"Family of \\([[k+4,k,2]]\\) CSS codes with transversal Hadamard gates; relevant to magic state distillation.\nThe four stablizer generators are \\(X_1X_2X_3X_4\\), \\(Z_1Z_2Z_3Z_4\\), \\(X_1X_2X_5X_6...X_{k+4}\\), and \\(Z_1Z_2Z_5Z_6...Z_{k+4}\\).'\n","protection":"Detects weight-1 Pauli errors. The \\(r\\)-level contatenated H code detects weight Pauli errors up to weight \\(2^r-1\\).","features":{"magic_scaling_exponent":"A total of \\(r\\) rounds of magic-state distillation yields a magic-state scaling exponent \\(\\gamma\\to 1\\) as \\(k,r\\rightarrow \\infty\\). This matches a conjectured bound for \\(\\gamma\\) \\cite{arXiv:1209.2426}.","rate":"The H codes are dense, i.e., the rate \\(\\frac{k}{k+4}\\rightarrow 1\\) as \\(k \\rightarrow \\infty\\). The distance is 2. However an \\(r\\)-level concatenation of H codes gives a distance of \\(2^r\\).","transversal_gates":"Hadamard and \\(TXT^{\\dagger}\\) gates, with the latter Clifford-equivalent to Hadamard, and where \\(T=\\exp(i\\pi(I-Z)/8)\\) is the \\(\\pi/8\\)-rotation gate.","general_gates":["The H codes can be used for high-quality and high-efficiency magic-state distillation \\cite{arXiv:1210.3388}. Their associated multi-level magic states protocols have an efficency advantage over the 10-to-2 and 15-to-1 protocals for output error below \\(10^{-7}\\)."]},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-28"},{"user_id":"XiaoXiao","date":"2022-04-28"}]},"_zoodb":{"id":"quantum_h","source_file_path":"codes/quantum/qubits/small_distance/h_code_jones.yml","source_file_modification_token":1681484685083.664}},"iceberg":{"code_id":"iceberg","physical":"qubits","logical":"qubits","name":"\\([[2m,2m-2,2]]\\) error-detecting code","short_name":"\\([[2m,2m-2,2]]\\)","introduced":"\\cite{arxiv:quant-ph/9605021,arxiv:quant-ph/9702029}","description":"Also known as the \\textit{iceberg} code. CSS stabilizer code for \\(m\\geq 2\\) with generators \\(\\{XX\\cdots X, ZZ\\cdots Z\\} \\) acting on all \\(2m\\) physical qubits.\nAdmits a basis such that each codeword is a superposition of a computational basis state labeled by a bitstring \\(b\\) and a state labeled by the negation of \\(b\\).\nSuch states generalize the two-qubit Bell states and three-qubit GHz states and are often called \\textit{(qubit) cat states} or \\textit{poor-man's GHz states}.\n","protection":"Detects a single-qubit error.","features":{"encoders":["Adaptive constant-depth circuit with geometrically local gates and measurements throughout \\cite{arxiv:1906.08890,arXiv:2112.03061}."],"transversal_gates":"Transveral CNOT gates can be performed by first teleporting qubits into different code blocks \\cite{arxiv:quant-ph/9702029}.","general_gates":["Universal set of gates, each of which is supported on two qubits \\cite{arXiv:2211.06703}."],"fault_tolerance":["Two-qubit fault-tolerant state preparation, error detection and projective measurements \\cite{arxiv:1705.02329} (see also \\cite{arXiv:2211.06703}).","CNOT and Hadamard gates using only two extra qubits and four-qubit fault-tolerant CCZ gate \\cite{arxiv:1705.05365}."]},"realizations":["Trapped-ion devices: 12-qubit device by Quantinuum \\cite{arXiv:2211.06703}. Subsequent experiment performed Bayesian Quantum Phase Estimation on the \\(m=3\\) code \\cite{arxiv:2306.16608}."],"notes":["See description of the code in Ref. \\cite{preset:PreskillNotes}."],"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"quantum_mds","detail":"The \\([[2m,2m-2,2]]\\) error-detecting code is one of the two qubit quantum MDS \\cite{arxiv:quant-ph/0312164}."},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-03"}]},"_zoodb":{"id":"iceberg","source_file_path":"codes/quantum/qubits/small_distance/iceberg.yml","source_file_modification_token":1689550329219.214}},"quantum_divisible":{"code_id":"quantum_divisible","physical":"qubits","logical":"qubits","name":"Quantum divisible code","introduced":"\\cite{arXiv:2204.13176}","description":"Consider a CSS code whose \\(Z\\)-stabilizers are determined by the dual of a classical \\([n, k_1]\\) linear binary code \\(C_1\\), and whose \\(X\\)-stabilizers are determined by a classical \\([n, k_2]\\) binary code \\(C_2 \\subset C_1\\). This code is quantum divisible if all weights in \\(C_2\\) share a common divisor \\(\\Delta > 1\\), and all weights in each coset of \\(C_2\\) in \\(C_1\\) are congruent to \\(\\Delta\\).\n\nFor example, if \\(C_2\\) is the first-order Reed-Muller code, and \\(C_1/ C_2\\) consists of quadratic forms with a bounded rank, then \\([[n = 2m − 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m − i), d = 3]]\\) is a family of quantum divisible codes.\n","protection":"Distance \\(d\\) is upper bounded by the two classical codes that determine the CSS code.","features":{"general_gates":["The \\([[2m − 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m − i), 3]]\\) quantum divisible code family can serve as outer codes of either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code to realize a \\(T\\) gate on the inner code. For example, when \\(m=5\\) (\\(m=6\\)), the resulting \\([[31,5,3]]\\) (\\([[63,7,3]]\\)) code yields the \\(T\\) gate on the inner five-qubit (Steane) code."],"fault_tolerance":["The \\(T\\) gate realized by concatenating members of the \\([[2m − 1, 1 \\leq k \\leq 1 + \\sum_{i=1}^{m-4}(m − i), 3]]\\) quantum divisible code family with either the five-qubit \\([[5,1,3]]\\) or Steane \\([[7,1,3]]\\) code is fault-tolerant and does not require magic-state distillation. The gate is performed on the inner five-qubit/Steane code and does require encoding and decoding algorithms to pass between the inner and outer codes."]},"relations":{"parents":[{"code_id":"qubit_css"}],"cousins":[{"code_id":"divisible","detail":"Quantum divisible codes are constructed via the CSS construction using a divisible linear binary code."},{"code_id":"reed_muller","detail":"Quantum divisible codes can be constructed out of first-order RM codes."},{"code_id":"quantum_reed_muller","detail":"Quantum RM codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions."},{"code_id":"quantum_triorthogonal","detail":"Triorthogonal codes can be derived using a procedure that yields sufficient conditions for a CSS code to admit a given transversal diagonal logical gate. Quantum divisible codes are derived in a similar procedure, but one that yields necessary and sufficient conditions."},{"code_id":"quantum_concatenated","detail":"A fault-tolerant \\(T\\) gate on the five-qubit or Steane code can be obtained by concatenating with particular quantum divisible codes."},{"code_id":"stab_5_1_3","detail":"A fault-tolerant \\(T\\) gate on the five-qubit code can be obtained by concatenating with particular quantum divisible codes."},{"code_id":"steane","detail":"A fault-tolerant \\(T\\) gate on the Steane code can be obtained by concatenating with particular quantum divisible codes."}]},"_meta":{"changelog":[{"user_id":"JingzhenHu","date":"2022-05-04"},{"user_id":"VictorVAlbert","date":"2022-05-04"}]},"_zoodb":{"id":"quantum_divisible","source_file_path":"codes/quantum/qubits/small_distance/quantum_divisible.yml","source_file_modification_token":1681484685083.858}},"quantum_hamming":{"code_id":"quantum_hamming","physical":"qubits","logical":"qubits","name":"\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code","short_name":"\\([[2^r, 2^r-r-2, 3]]\\)","introduced":"\\cite{arXiv:quant-ph/9604038}","description":"A family of stabilizer codes of distance \\(3\\) that saturate the asymptotic quantum Hamming bound. Can be obtained from the CSS construction using a first-order \\([2^r,r+1,2^{r-1}]\\) RM code and a \\([2^r,2^r-1,2]\\) even-weight code \\cite{arxiv:quant-ph/9605021}.","protection":"Protects against any single qubit error.","relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"small_distance"}],"cousins":[{"code_id":"quantum_perfect","detail":"Quantum Hamming codes saturate the asymptotic quantum Hamming bound."},{"code_id":"hamming","detail":"\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming codes are analogues of Hamming codes in that they saturate the asymptotic Hamming bound."},{"code_id":"reed_muller","detail":"\\([[2^r, 2^r-r-2, 3]]\\) quantum Hamming code can be obtained from the CSS construction using a first-order \\([2^r,r+1,2^{r-1}]\\) RM code and a \\([2^r,2^r-1,2]\\) even-weight code \\cite{arxiv:quant-ph/9605021}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-04"},{"user_id":"VictorVAlbert","date":"2022-07-20"},{"user_id":"MariannaPodzorova","date":"2021-12-13"},{"user_id":"VictorVAlbert","date":"2021-11-24"}]},"_zoodb":{"id":"quantum_hamming","source_file_path":"codes/quantum/qubits/small_distance/quantum_hamming.yml","source_file_modification_token":1680994436850.1965}},"quantum_repetition":{"code_id":"quantum_repetition","physical":"qubits","logical":"qubits","name":"Quantum repetition code","introduced":"\\cite{doi:10.1103/PhysRevA.32.3266}","description":"Encodes \\(1\\) qubit into \\(n\\) qubits according to \\(|0\\rangle\\to|\\phi_0\\rangle^{\\otimes n}\\) and \\(|1\\rangle\\to|\\phi_1\\rangle^{\\otimes n}\\). Also known as a \\textit{bit-flip} code when \\(|\\phi_i\\rangle = |i\\rangle\\), and a \\textit{phase-flip} code when \\(|\\phi_0\\rangle = |+\\rangle\\) and \\(|\\phi_1\\rangle = |-\\rangle\\).\n\nThe \\(\\pm\\)-basis codewords for the bit-flip code are GHz (a.k.a. cat) states \\(|0\\rangle^{\\otimes n}\\pm|1\\rangle^{\\otimes n}\\). These are ground states of the one-dimensional \\textit{classical Ising model} Hamiltonian \\(H=\\sum_{i} Z_{i}Z_{i+1}\\).\n\nThe \\(\\pm\\)-basis codewords for the phase-flip code are expanded in the computational basis as\n\\begin{align}\n  \\begin{split}\n    |\\overline{+}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=0}|v_{1},\\cdots,v_{n}\\rangle~{\\phantom{,}}\\\\\n    |\\overline{-}\\rangle =\\frac{1}{\\sqrt{2^{n-1}}}\\sum_{\\sum_{i}v_{i}=1}|v_{1},\\cdots,v_{n}\\rangle~,\n  \\end{split}\n\\end{align}\nshowing that the phase-flip code stores information in the total parity of the qubits.\n","protection":"Bit-flip code detects bit-flip errors \\(X\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any phase-flip errors \\(Z\\).\nPhase-flip code detects phase-flip errors \\(Z\\) on \\(\\left\\lfloor (n-1)/2\\right\\rfloor\\) qubits and does not detect any bit-flip errors \\(X\\).\n\nBecause they protect against only one type of noise, both codes can be thought of as a classical \\([n,1,d]\\) repetition code with classical distance \\(d=\\left\\lfloor (n-1)/2\\right\\rfloor\\) embedded in a quantum system.\nNevertheless, the phase-flip code can offer some degree of protection in particular physical systems based on superconducting circuits \\cite{arxiv:1205.1836,arxiv:2303.17810}.\n","features":{"encoders":["Unitary circuit of depth logarithmic in \\(n\\) \\cite{arxiv:1807.05572}. Any circuit has to have range \\(n\\) because Ghz states are locally indistinguishable \\cite{arxiv:1910.08980}.","Adaptive constant-depth circuit with geometrically local gates and measurements throughout \\cite{arxiv:1906.08890,arXiv:2112.03061}.","Lindbladian-based dissipative encoding passively protecting against bit flips \\cite{arxiv:quant-ph/0110111,arxiv:1702.08673}."],"general_gates":["Toffoli magic-state preparation protocol \\cite{arXiv:2012.04108}."],"decoders":["Automaton-like decoders for the repetition code on a 2D lattice, otherwise known as the classical 2D Ising model, were developed by Toom \\cite{manual:{A. L. Toom, “Nonergodic Multidimensional System of Automata”, Probl. Peredachi Inf., 10:3 (1974), 70–79; Problems Inform. Transmission, 10:3 (1974), 239–246},doi:10.1007/978-1-4612-2168-5_18}. An automaton by Gacs yields a decoder for a 1D lattice \\cite{doi:10.1023/A:1004823720305}.","Machine learning algorithm to implement continuous error-correction for the three-qubit quantum repetition code \\cite{arxiv:2110.10378}."],"fault_tolerance":["Toffoli magic-state preparation protocol \\cite{arXiv:2012.04108}."]},"realizations":["NMR: 3-qubit phase-flip code \\cite{arxiv:quant-ph/9802018,arXiv:1108.4842}, with up to two rounds of error correction in liquid-state NMR \\cite{arXiv:1109.4821}.","Superconducting circuits: 3-qubit phase-flip and bit-flip code by Schoelkopf group \\cite{arXiv:1109.4948}; 3-qubit bit-flip code \\cite{arXiv:1411.5542}; 3-qubit phase-flip code up to 3 cycles of error correction \\cite{arXiv:1508.01388}; IBM 15-qubit device \\cite{arXiv:1709.00990}; IBM Rochester device using 43-qubit code \\cite{arXiv:2004.11037}; Google system performing up to 8 error-correction cycles on 5 and 9 qubits \\cite{arXiv:1411.7403}; Google Quantum AI Sycamore utilizing up to 11 physical qubits and running 50 correction rounds \\cite{arXiv:2102.06132}; Google Quantum AI Sycamore utilizing up to 25 qubits for comparison of logical error scaling with a quantum code \\cite{arxiv:2207.06431} (see also \\cite{arxiv:2211.04728}).","Continuous error correction protocols have been implemented on a 3-qubit superconducting qubit device \\cite{arxiv:2107.11398}.","Semiconductor spin-qubit devices: 3-qubit devices at RIKEN \\cite{arXiv:2201.08581} and Delft \\cite{arXiv:2202.11530}.","Nitrogen-vacancy centers in diamond: 3-qubit phase-flip code \\cite{arXiv:1309.6424,doi:10.1038/s42005-022-00875-6} (see also Ref. \\cite{arXiv:1309.5452}).","Trapped-ion device: 3-qubit phase-flip algorithm implemented in 3 cycles on high fidelity gate operations \\cite{doi:10.1126/science.1203329}. Both phase- and bit-flip codes for 31 qubits and their stabilizer measurements have been realized by Quantinuum \\cite{arxiv:2305.03828}."],"notes":["Repetition codes can be used to benchmark device performance \\cite{arxiv:2202.11045}."],"relations":{"parents":[{"code_id":"quantum_parity","detail":"A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) QPC is a concatenation of a \\(m_1\\) bit-flip and a \\(m_2\\) phase-flip repetition codes, reducing to a repetition code when \\(m_1\\) or \\(m_2\\) is one."}],"cousins":[{"code_id":"hamiltonian","detail":"Bit-flip codespace is the ground-state space of a one-dimensional classical Ising model with nearest-neighbor interactions."},{"code_id":"qubit_classical_into_quantum","detail":"A quantum repetition code can be thought of as a classical \\([n,1,d]\\) repetition code with classical distance \\(d=\\left\\lfloor (n-1)/2\\right\\rfloor\\) embedded in a quantum system."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-28"},{"user_id":"MazinKarjikar","date":"2022-06-28"},{"user_id":"VictorVAlbert","date":"2022-06-07"},{"user_id":"VictorVAlbert","date":"2022-02-23"},{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"quantum_repetition","source_file_path":"codes/quantum/qubits/small_distance/quantum_repetition.yml","source_file_modification_token":1683723710998.4937}},"qubit_5_6_2":{"code_id":"qubit_5_6_2","physical":"qubits","logical":"qubits","name":"\\(((5,6,2))\\) qubit code","introduced":"\\cite{arXiv:quant-ph/9703002}","description":"Six-qubit cyclic CWS code detecting a single-qubit error. Smallest nontrivial member of the \\(((5+2r,3\\times 2^{2r+1},2))\\) qubit code family \\cite{arxiv:quant-ph/9704043}. Qubit member of the \\(((n, 1+n(q-1),2))_q\\) Galois-qudit code family \\cite{arxiv:quant-ph/0210097}.","relations":{"parents":[{"code_id":"cws"},{"code_id":"quantum_cyclic"},{"code_id":"non_stabilizer","detail":"The six-qubit CWS code is a non-stabilizer qubit code \\cite{arxiv:quant-ph/0210097}."},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-01"}]},"_zoodb":{"id":"qubit_5_6_2","source_file_path":"codes/quantum/qubits/small_distance/small/qubit_5_6_2.yml","source_file_modification_token":1680994436850.3862}},"shor_nine":{"code_id":"shor_nine","physical":"qubits","logical":"qubits","name":"\\([[9,1,3]]\\) Shor code","short_name":"Shor","introduced":"\\cite{doi:10.1103/PhysRevA.52.R2493}","description":"Nine-qubit \\hyperref[code:css]{CSS code} that is the first quantum error-correcting code.\n\nLogical codewords are\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right)^{\\otimes3}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2\\sqrt{2}}\\left(|000\\rangle-|111\\rangle\\right)^{\\otimes3}~.\n\\end{split}\n\\end{align}\nThe code works by \\hyperref[code:quantum_concatenated]{concatenating} each qubit of a phase-flip with a bit-flip \\hyperref[code:quantum_repetition]{repetition code}. Therefore, the code can correct both type of errors simultaneously.\n\nSpecifically, a state is phase-flip error-corrected by a three-qubit phase-flip \\hyperref[code:quantum_repetition]{repetition code}, with stabilizer generators \\(X_0 X_1I_2\\) and \\(X_0I_1X_2\\) in \\(X\\) basis, where the subscript represents the qubit index. Each logical qubit is encoded using\n\\begin{align}\n\\label{eq:phase-flip}\n\\begin{split}\n  |\\overline{0}\\rangle &= |+_0+_1+_2\\rangle \\\\\n  |\\overline{1}\\rangle &= |-_0-_1-_2\\rangle .\n\\end{split}\n\\end{align}\nThen, each physical qubit used in \\eqref{eq:phase-flip} is further encoded in the three-qubit bit-flip \\hyperref[code:quantum_repetition]{repetition code},\n\\begin{align}\n  |\\pm _j \\rangle  = \\frac{1}{\\sqrt{2}}( |0_{j0}0_{j1}0_{j2}\\rangle \\pm |1_{j0}1_{j1}1_{j2}\\rangle),\n\\end{align}\neach with bit-flip error stabilizer generators \\(Z_{j0}Z_{j1}I_{j2}\\) and  \\(Z_{j0}I_{j1}Z_{j2} \\) with \\(j=0,1,2\\).\nNotice now the phase-flip error stabilizer generator is extended as \\(X_j = X_{j0}X_{j1}X_{j2}\\).\nAs a result, the stabilizer generators with the qubit index flattened are\n\\begin{align}\n\\begin{split}\n  Z_{j0}Z_{j1}I_{j2} &\\rightarrow \\{Z_0Z_1, Z_3Z_4, Z_6Z_7\\} \\\\\n  Z_{j0}I_{j1}Z_{j2} &\\rightarrow \\{Z_0Z_2, Z_3Z_5, Z_6Z_8\\} \\\\\n  X_0 X_1I_2  &\\rightarrow  \\{X_0X_1X_2X_3X_4X_5\\}\\\\\n  X_0 I_1X_2  &\\rightarrow  \\{X_0X_1X_2X_6X_7X_8\\}.\n\\end{split}\n\\end{align}\n","protection":"The code detects two-qubit errors or corrects an arbitrary single-qubit error.","features":{"decoders":["Bit- and phase-flip circuits utilize CNOT and Hadamard gates (\\cite{doi:10.1201/9781420012293}, Fig. 10.6)."]},"realizations":["Trapped-ion qubits: state preparation with 98.8(1)\\% and 98.5(1)\\% fidelity for state \\(|\\overline{0}\\rangle\\) and \\(|\\overline{1}\\rangle\\), respectively, by N. Linke group \\cite{arXiv:2104.01205}. Variants of the code to handle coherent noise studied and realized by K. Brown and C. Monroe groups \\cite{arxiv:2105.05068}.","Optical systems: quantum teleportation of information implemented by J.-W. Pan group on maximally entangled pair of one physical and one logical qubit with fidelity rate of up to 78.6\\% \\cite{arXiv:2009.06242}. All-photonic quantum repeater architecture tested on the same code \\cite{arxiv:2203.07979}."],"relations":{"parents":[{"code_id":"quantum_parity","detail":"The Shor code is part of the sub-family of \\([[m^2,1,m]]\\) QPC codes."},{"code_id":"real_projective_plane","detail":"The Shor code is the smallest surface code defined on the projective plane \\(\\mathbb{R}P^2\\) \\cite[Fig. 4]{arxiv:quant-ph/9810055}."},{"code_id":"stab_9_1_3","detail":"The \\([[9,1,3]]_{\\mathbb{Z}_q}\\) modular-qudit code for \\(q=2\\) reduces to the \\([[9,1,3]]\\) Shor code."}],"cousins":[{"code_id":"quantum_repetition","detail":"The Shor code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code."},{"code_id":"quantum_concatenated","detail":"The Shor code is a concatenation of a three-qubit bit-flip with a three-qubit phase-flip repetition code."},{"code_id":"qecc","detail":"The Shor code is the first quantum error-correcting code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-29"},{"user_id":"VictorVAlbert","date":"2022-03-15"},{"user_id":"VictorVAlbert","date":"2021-12-10"},{"user_id":"QingfengKeeWang","date":"2021-12-07"}]},"_zoodb":{"id":"shor_nine","source_file_path":"codes/quantum/qubits/small_distance/small/shor_nine.yml","source_file_modification_token":1684508734557.2507}},"stab_15_1_3":{"code_id":"stab_15_1_3","physical":"qubits","logical":"qubits","name":"\\([[15,1,3]]\\) quantum Reed-Muller code","short_name":"\\([[15,1,3]]\\)","description":"\\([[15,1,3]]\\) CSS code that is most easily thought of as a tetrahedral 3D color code.\nThis code contains 15 qubits, represented by four vertices, four face centers, six edge centers, and one body center.\nThe tetrahedron is cellulated into four identical polyhedron cells by connecting the body center to all four face centers, where each face center is then connected by three adjacent edge centers.\nEach colored cell corresponds to a weight-8 \\(X\\)-check, and each face corresponds to a weight-4 \\(Z\\)-check.\nA logical \\(Z\\) is any weight-3 \\(Z\\)-string along an edge of the entire tetrahedron.\nThe logical \\(X\\) is any weight-7 \\(X\\)-face of the entire tetrahedron.\n","features":{"magic_scaling_exponent":"Magic-state distillation scaling exponent \\( \\gamma= \\log_d (n/k)\\approx 2.46\\) \\cite{arXiv:1703.07847}.","transversal_gates":"This code is the smallest qubit stabilizer code with a transversal gate outside of the Clifford group \\cite{arxiv:2210.14066}. A transversal logical \\(T^\\dagger\\) is implemented by applying a \\(T\\) gate on every qubit \\cite{arXiv:quant-ph/9610011,arXiv:1403.2734,arXiv:1612.07330}. A subsystem version yields a transversal \\(CCZ\\) gate \\cite{arxiv:1304.3709}. The code fails to have a transversal Hadamard gate; otherwise, it would violate the Eastin-Knill theorem.","general_gates":["Code is often used in magic-state distillation protocols because of its transversal \\(T\\) gate \\cite{arXiv:quant-ph/0403025}."],"fault_tolerance":["Combining the Steane code and the 15-qubit Reed-Muller code through a fault-tolerant conversion can result in a universal transversal gate set that does not need magic state distillation \\cite{arxiv:1304.3709,arXiv:1403.2734,arXiv:1703.03860,arxiv:2210.14074}."]},"notes":["The \\([[15,1,3]]\\) code can be converted into the smallest known stabilizer code with a fault-tolerant logical \\(T\\) gate (i.e., the \\([[10,1,2]]\\) code) through a \"morphing procedure\" \\cite{arXiv:2112.01446}."],"relations":{"parents":[{"code_id":"color","detail":"The \\([[15,1,3]]\\) code is a 3D color code."},{"code_id":"diagonal_clifford"},{"code_id":"quantum_triorthogonal","detail":"The \\([[15, 1, 3]]\\) code is a triorthogonal code \\cite{arXiv:2107.09684}."},{"code_id":"doubled_color","detail":"The \\([[15,1,3]]\\) code, when extended to a gauge color code, is the smallest doubled color code."}]},"_meta":{"changelog":[{"user_id":"balopat","date":"2023-03-30"},{"user_id":"VictorVAlbert","date":"2021-12-09"},{"user_id":"QingfengKeeWang","date":"2021-12-07"}]},"_zoodb":{"id":"stab_15_1_3","source_file_path":"codes/quantum/qubits/small_distance/small/stab_15_1_3.yml","source_file_modification_token":1680994436850.474}},"stab_15_7_3":{"code_id":"stab_15_7_3","physical":"qubits","logical":"qubits","name":"\\([[15, 7, 3]]\\) Hamming-based CSS code","short_name":"\\([[15, 7, 3]]\\)","introduced":"\\cite{arxiv:quant-ph/9605021,manual:{Jim Harrington and Ben W. Reichardt, “Addressable multi-qubit logic via permutations,” Talk at Southwest Quantum Information and Technology (SQuInT) (2011).}}","description":"Self-dual Hamming-based CSS code that admits permutation-based CZ logical gates.","features":{"transversal_gates":"Single-qubit Clifford operations applied transversally yield the corresponding Clifford gates on one of the logical qubits \\cite{arxiv:1705.05365}. CNOT gate because it is a CSS code. Transversal CCZ gate \\cite{arxiv:1304.3709}.","general_gates":["CZ gates can be performed using qubit permutations, and a CCZ gate can be performed using four ancilla qubits \\cite{arxiv:1705.05365}."],"fault_tolerance":["Clifford gates can be performed fault-tolerantly using two ancillary flag qubits, and a CCZ gate can be performed using four ancilla qubits \\cite{arxiv:1705.05365}."]},"relations":{"parents":[{"code_id":"quantum_hamming_css"}],"cousins":[{"code_id":"quantum_perfect","detail":"\\([[15, 7, 3]]\\) Hamming-based CSS code is perfect as a CSS code, i.e., the number of its \\(Z\\)-type syndromes matches the number of \\(X\\)-type Pauli errors up to weight one \\cite{arxiv:1705.05365}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-06"}]},"_zoodb":{"id":"stab_15_7_3","source_file_path":"codes/quantum/qubits/small_distance/small/stab_15_7_3.yml","source_file_modification_token":1671665864796.113}},"stab_4_2_2":{"code_id":"stab_4_2_2","physical":"qubits","logical":"qubits","name":"\\([[4,2,2]]\\) CSS code","short_name":"\\([[4,2,2]]\\)","introduced":"\\cite{arXiv:quant-ph/9603031,arXiv:quant-ph/9610042}","alternative_names":["\\(C_4\\) code"],"description":"Four-qubit CSS stabilizer code is the smallest qubit stabilizer code to detect a single-qubit error.\nAdmits generators \\(\\{XXXX, ZZZZ\\} \\) and codewords\n\\begin{align}\n  \\begin{split}\n    |\\overline{00}\\rangle = (|0000\\rangle + |1111\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{01}\\rangle = (|0011\\rangle + |1100\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{10}\\rangle = (|0101\\rangle + |1010\\rangle)/\\sqrt{2}~{\\phantom{.}}\\\\\n    |\\overline{11}\\rangle = (|0110\\rangle + |1001\\rangle)/\\sqrt{2}~.\n  \\end{split}\n\\end{align}\nThis code is the smallest instance of the toric code, and its various single-qubit subcodes are small planar surface codes.\n\nThe subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is a \\([[4,1,2]]\\) code \\cite{arXiv:quant-ph/9704002}, whose \\(\\pm\\)-basis codewords can be written as\n\\begin{align}\n  |\\overline{\\pm}\\rangle = \\frac{1}{2}(|00\\rangle \\pm |11\\rangle)^{\\otimes 2}~.\\\\\n\\end{align}\nThis code can be thought of as a concatenation of a two-qubit bit-flip with a two-qubit phase-flip code. The subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\) \\cite{arxiv:quant-ph/0103042} has also been studied against amplitude-damping noise. This subcode \\cite{arxiv:2006.03071} and the subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) \\cite{arxiv:1912.09410}, \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) \\cite{arXiv:2102.06132}, and \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) \\cite{arXiv:2102.13071} are small planar surface codes.\n","protection":"Detects a single-qubit error \\cite{arXiv:quant-ph/9603031} or single erasure \\cite{arXiv:quant-ph/9610042}. Not able to correct arbitrary single-qubit errors because \\( \\lfloor \\frac{d-1}{2} \\rfloor =0 \\). Approximately corrects a single amplitude damping error \\cite{arXiv:quant-ph/9704002}.","features":{"transversal_gates":"Transversal Pauli, Hadamard, and two-qubit \\(R\\) \\cite{arxiv:1610.03507}. A transversal \\(CZ\\) gate is realized by the rotation \\(\\sqrt{Z}\\otimes\\sqrt{Z}^{\\dagger}\\otimes\\sqrt{Z}^{\\dagger}\\otimes\\sqrt{Z}\\).","fault_tolerance":["Preparation of certain states, both magic and non-magic, along with transversal gates can be performed fault-tolerantly, but requires post-selection because the code cannot correct errors \\cite{arxiv:1610.03507}."]},"realizations":["\\([[4,1,2]]\\) subcode implemented using four-qubit graph state of photons \\cite{arXiv:1404.5498}.","Trapped-ion device by IonQ \\cite{arXiv:1611.06946}.","Logical state preparation and flag-qubit error correction realized in superconducting-circuit devices by IBM \\cite{arXiv:1705.09259,arXiv:2110.04285}.","The subcode \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) \\cite{arXiv:1912.09410} and \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) \\cite{arXiv:2102.06132}, treated as a planar surface code, has been realized in superconducting-circuit devices.","Logical gates between two copies of the subcode \\(\\{|\\overline{10}\\rangle,|\\overline{11}\\rangle\\}\\), interpreted as lattice surgery between planar surface codes, realized in superconducting circuits \\cite{arXiv:2006.03071}.","Logical gates for the \\(\\{|\\overline{00}\\rangle,|\\overline{11}\\rangle\\}\\) subcode, treated as a planar code, realized in superconducting circuits \\cite{arXiv:2102.13071}.","The CZ magic state has been realized on an IBM heavy-hex superconducting circuit device \\cite{arxiv:2305.13581}."],"notes":["Concatenating \\([[4,2,2]]\\) code with surface code can generate 2D topological code with a reasonable circuit-based threshold \\cite{doi:10.26421/QIC16.15-16-1}."],"relations":{"parents":[{"code_id":"surface","detail":"\\([[4,2,2]]\\) code is the smallest toric code."},{"code_id":"iceberg"}],"cousins":[{"code_id":"rotated_surface","detail":"Various \\([[4,1,2]]\\) subcodes are small rotated planar codes \\cite{arxiv:2006.03071,arxiv:1912.09410,arXiv:2102.06132,arXiv:2102.13071}."},{"code_id":"bacon_shor","detail":"The error-detecting \\([[4,1,2]]\\) Bacon-Shor code, which reduces to a subcode of the \\hyperref[code:stab_4_2_2]{\\([[4,2,2]]\\) code} for a particular gauge configuration, has gauge operators \\(\\{XXII,IIXX,ZIZI,IZIZ\\}\\)."},{"code_id":"quantum_parity","detail":"\\([[4,1,2]]\\) subcode \\(\\{|\\overline{00}\\rangle,|\\overline{01}\\rangle\\}\\) is the smallest member of the sub-family of \\([[m^2,1,m]]\\) QPC codes."},{"code_id":"stab_5_1_3","detail":"\\([[4,2,2]]\\) can be derived from the five-qubit code using a protocol that converts an \\([[n,k,d]]\\) code into an \\([[n-1, k+1, d-1]]\\) code; see Sec. 3.5 in Gottesman \\cite{arXiv:quant-ph/9705052}."},{"code_id":"quantum_polar","detail":"\\([[4,2,2]]\\) code is a small quantum polar code \\cite{manual:{Kyungjoo Noh, \\href{https://github.com/errorcorrectionzoo/eczoo_data/files/7652763/Leung_code_as_quantum_polar_code.pdf}{Leung code as quantum polar code}, 2017.}}."},{"code_id":"approximate_qecc","detail":"\\([[4,1,2]]\\) subcodes \\(\\{|\\overline{00}\\rangle,|\\overline{10}\\rangle\\}\\) \\cite{arXiv:quant-ph/9704002} and \\(\\{|\\overline{01}\\rangle,|\\overline{11}\\rangle\\}\\) \\cite{arxiv:quant-ph/0103042} approximately correct a single amplitude damping error."},{"code_id":"binomial","detail":"\\([[4,1,2]]\\) subcode consisting of \\(\\{|\\overline{00}\\rangle\\) and any other codeword reduces to the \\(0,2,4\\) binomial code when the basis labels in each codeword are written as in base-ten. Such a mapping can be generalized \\cite{manual:{Linshu Li, private communication, 2018}}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-23"},{"user_id":"AntonioDCorcoles","date":"2022-03-01"},{"user_id":"VictorVAlbert","date":"2022-03-01"},{"user_id":"QingfengKeeWang","date":"2021-12-07"}]},"_zoodb":{"id":"stab_4_2_2","source_file_path":"codes/quantum/qubits/small_distance/small/stab_4_2_2.yml","source_file_modification_token":1687727505574.3545}},"stab_5_1_3":{"code_id":"stab_5_1_3","physical":"qubits","logical":"qubits","name":"Five-qubit perfect code","short_name":"\\([[5,1,3]]\\)","introduced":"\\cite{arXiv:quant-ph/9602019,arxiv:quant-ph/9604024}","description":"Five-qubit stabilizer code that is the smallest qubit stabilizer code to correct a single-qubit error.\nIts generators that are symmetric under cyclic permutation of qubits, \\begin{align}\n  \\begin{split}\n  S_1 &= IXZZX \\\\\n  S_2 &= XZZXI \\\\\n  S_3 &= ZZXIX \\\\\n  S_4 &= ZXIXZ~.\n  \\end{split}\n\\end{align}\n\nThe five-qubit code is the smallest known example of quantum cyclic code.\nIts automorphism group is the dihedral group of order 10 \\cite{arxiv:2109.12735}.\n","protection":"Smallest stabilizer code that protects against a single error on any one qubit. Detects two-qubit errors.","features":{"encoders":["Four CCZ, four Hadamard, and one \\(Z\\) gate (\\cite{doi:10.1201/9781420012293}, Fig. 10.16).","Four CNOT and five CPHASE gates \\cite{arxiv:1509.01239}."],"transversal_gates":"Pauli gates are transversal, along with a non-Pauli Hadamard-phase gate \\(SH\\) and three-qubit Clifford operation \\(M_3\\) \\cite{arxiv:quant-ph/9705052}. These realize the \\(2T\\) binary tetrahedral subgroup of \\(SU(2)\\).","general_gates":["Pieceable fault-tolerant CZ, CNOT, and CCZ gates \\cite{arxiv:1603.03948}."],"decoders":["Combined dynamical decoupling and error correction protocol on individually-controlled qubits with always-on Ising couplings \\cite{arxiv:1509.01239}.","Symmetric decoder correcting all weight-one Pauli errors. The resulting logical error channel after coherent noise has been explicitly derived \\cite{arxiv:2203.01706}."],"fault_tolerance":["Pieceable fault-tolerant CZ, CNOT, and CCZ gates \\cite{arxiv:1603.03948}.","Syndrome measurement can be done with two ancillary flag qubits \\cite{arXiv:1705.02329}. The depth of syndrome extraction circuits can be lowered by using past syndrome values \\cite{arxiv:2305.00784}."]},"realizations":["NMR: Implementation of perfect error correcting code on 5 spin subsystem of labeled crotonic acid for quantum network benchmarking \\cite{arXiv:quant-ph/0101034}. Single-qubit logical gates \\cite{arXiv:1208.4797}.","Superconducting qubits \\cite{arXiv:1907.04507}.","Trapped-ion qubits: non-transversal CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 12-qubit device by Quantinuum \\cite{arxiv:2208.01863}.","Nitrogen-vacancy centers in diamond: fault-tolerant single-qubit Clifford operations \\cite{arxiv:2108.01646}."],"relations":{"parents":[{"code_id":"xzzx","detail":"The five-qubit code is the smallest XZZX surface code \\cite[Ex. 11]{arxiv:1108.5490}\\cite[Ex. 3]{arxiv:1212.6703}."},{"code_id":"quantum_perfect","detail":"The five-qubit code is the smallest perfect code."},{"code_id":"stabilizer_over_gf4","detail":"The five-qubit code is derived from the \\([5,3,3]_4\\) shortened hexacode via the \\hyperref[code:stabilizer_over_gf4]{stabilizer-over-\\(GF(4)\\)} construction."},{"code_id":"quantum_mds","detail":"The five-qubit code is one of the two qubit quantum MDS codes."},{"code_id":"qudit_5_1_3","detail":"The \\([[5,1,3]]_{\\mathbb{Z}_q}\\) modular-qudit code for \\(q=2\\) reduces to the five-qubit perfect code."},{"code_id":"galois_5_1_3","detail":"The \\([[5,1,3]]_q\\) Galois-qudit code for \\(q=2\\) reduces to the five-qubit perfect code."}],"cousins":[{"code_id":"hamiltonian","detail":"The five-qubit code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators \\cite{manual:{Aleksander Kubica, private communication, 2019}}."},{"code_id":"majorana_stab","detail":"The five-qubit code Hamiltonian is local when expressed in terms of mutually commuting Majorana operators \\cite{manual:{Aleksander Kubica, private communication, 2019}}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-10"},{"user_id":"AleksanderKubica","date":"2022-03-14"},{"user_id":"VictorVAlbert","date":"2022-03-14"},{"user_id":"MariannaPodzorova","date":"2021-12-13"},{"user_id":"QingfengKeeWang","date":"2021-12-07"}]},"_zoodb":{"id":"stab_5_1_3","source_file_path":"codes/quantum/qubits/small_distance/small/stab_5_1_3.yml","source_file_modification_token":1684508734558.064}},"stab_8_3_2":{"code_id":"stab_8_3_2","physical":"qubits","logical":"qubits","name":"\\([[8,3,2]]\\) code","introduced":"\\cite{arxiv:1503.02065,manual:{E. Campbell, “The smallest interesting colour code,” Online available at https://earltcampbell.com/2016/09/26/the-smallest-interesting-colour-code/ (2016), accessed on 2019-12-09.}}","description":"Smallest 3D color code whose physical qubits lie on vertices of a cube and which admits a transversal CCZ gate.\nSimilar constructions exist on \\(d\\)-dimensional hypercubes and are called hyperoctahedron \\([[2^d,d,2]]\\) codes \\cite{arxiv:2112.01446}.\n","features":{"transversal_gates":"CZ gates between any two logical qubits \\cite{arxiv:1912.10063} and CCZ gate \\cite{arxiv:1503.02065,manual:{E. Campbell, “The smallest interesting colour code,” Online available at https://earltcampbell.com/2016/09/26/the-smallest-interesting-colour-code/ (2016), accessed on 2019-12-09.},arxiv:1912.10063}.","fault_tolerance":["CCZ gate can be distilled in a fault-tolerant manner \\cite{arxiv:2007.07929}."]},"relations":{"parents":[{"code_id":"color","detail":"The \\([[8,3,2]]\\) code is the smallest non-trivial 3D color code."},{"code_id":"small_distance"}],"cousins":[{"code_id":"stab_15_1_3","detail":"The \\([[8,3,2]]\\) code can be obtained from a subset of physical qubits of the \\([[15,1,3]]\\) code \\cite{arxiv:2112.01446}."},{"code_id":"stab_4_2_2","detail":"The \\([[4,2,2]]\\) (\\([[8,3,2]]\\)) code's physical qubits correspond to vertices of a square (cube). Similar constructions exist on \\(d\\)-dimensional hypercubes and are called hyperoctahedron \\([[2^d,d,2]]\\) codes \\cite{arxiv:2112.01446}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-03"}]},"_zoodb":{"id":"stab_8_3_2","source_file_path":"codes/quantum/qubits/small_distance/small/stab_8_3_2.yml","source_file_modification_token":1675269976716.0786}},"steane":{"code_id":"steane","physical":"qubits","logical":"qubits","name":"\\([[7,1,3]]\\) Steane code","short_name":"Steane","introduced":"\\cite{doi:10.1098/rspa.1996.0136}","description":"A \\([[7,1,3]]\\) CSS code that is the smallest qubit CSS code to correct a single-qubit error.\nThe code is constructed using the classical binary \\([7,4,3]\\) Hamming code for protecting against both \\(X\\) and \\(Z\\) errors.\n\nThe parity-check matrix for the \\([7,4,3]\\) Hamming code is\n\\begin{align}\n  H = \\left(\\begin{matrix}\n    1&0&0&1&0&1&1\\\\\n    0&1&0&1&1&0&1\\\\\n    0&0&1&0&1&1&1\n  \\end{matrix}\\right),\n\\end{align}\nand the check matrix for the Steane code is therefore\n\\begin{align}\n  \\left(\\begin{matrix}\n    0&H\\\\\n    H&0\n  \\end{matrix}\\right).\n\\end{align}\nThe stabilizer group for the Steane code has six generators.\nLogical codewords are\n\\begin{align}\n\\begin{split}\n  |\\overline{0}\\rangle&=\\frac{1}{\\sqrt{8}}\\Big(|0000000\\rangle+|1010101\\rangle+|0110011\\rangle+|1100110\\rangle\\\\&\\,\\,\\,\\,\\,\\,\\,\\,+|0001111\\rangle+|1011010\\rangle+|0111100\\rangle+|1101001\\rangle\\Big)\\\\|\\overline{1}\\rangle&=\\frac{1}{\\sqrt{8}}\\Big(|1111111\\rangle+|0101010\\rangle+|1001100\\rangle+|0011001\\rangle\\\\&\\,\\,\\,\\,\\,\\,\\,\\,+|1110000\\rangle+|0100101\\rangle+|1000011\\rangle+|0010110\\rangle\\Big)~.\n\\end{split}\n\\end{align}\nThe automorphism group of the code is \\(PGL(3,2)\\) \\cite{arxiv:2109.12735}.\n","protection":"The Steane code is a distance 3 code. It detects errors on 2 qubits, corrects errors on 1 qubit.","realizations":["Trapped-ion qubits: seven-qubit device in Blatt group \\cite{arXiv:1403.5426}, ten-qubit QCCD device by Quantinuum \\cite{arXiv:2107.07505} (see APS Physics Synopsys \\cite{doi:10.1103/Physics.14.184}). Fault-tolerant universal two-qubit gate set by Monz group \\cite{arxiv:2111.12654}. Logical CNOT gate between two logical qubits, including rounds of correction and fault-tolerant primitives such as flag qubits and pieceable fault tolerance, on a 20-qubit device by Quantinuum \\cite{arxiv:2208.01863}; logical fidelity interval of the combined preparation-CNOT-measurement procedure was higher than that of the unencoded physical qubits.","Rydberg atom arrays: Lukin group \\cite{arXiv:2112.03923}."],"features":{"encoders":["Nine CNOT and four Hadamard gates (\\cite{doi:10.1201/9781420012293}, Fig. 10.14)."],"transversal_gates":"All single-qubit Clifford gates, which realize the \\(2O\\) binary octahedral subgroup of \\(SU(2)\\) \\cite{arxiv:quant-ph/9605011,arxiv:0706.1382}.","general_gates":["Pieceable fault-tolerant CCZ gate \\cite{arxiv:1603.03948}."],"fault_tolerance":["Pieceable fault-tolerant CCZ gate \\cite{arxiv:1603.03948}.","Syndrome measurement can be done with ancillary flag qubits \\cite{arXiv:1612.04795,arXiv:1705.02329} or with no extra qubits \\cite{doi:10.1088/2058-9565/abc6f4}. The depth of syndrome extraction circuits can be lowered by using past syndrome values \\cite{arxiv:2305.00784}."]},"relations":{"parents":[{"code_id":"color","detail":"Steane code is the smallest 2D color code."},{"code_id":"diagonal_clifford"},{"code_id":"quantum_hamming_css"},{"code_id":"single_qubit_clifford"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-04"},{"user_id":"VictorVAlbert","date":"2022-03-14"},{"user_id":"JosephTIosue","date":"2021-12-19"}]},"_zoodb":{"id":"steane","source_file_path":"codes/quantum/qubits/small_distance/small/steane.yml","source_file_modification_token":1684508734558.1914}},"tfim":{"code_id":"tfim","physical":"qubits","logical":"qubits","name":"Transverse-field Ising model (TFIM) code","short_name":"TFIM","introduced":"\\cite{arXiv:2205.12998}","description":"A 1D translationally invariant stabilizer code whose encoding is a constant-depth circuit of nearest-neighbor gates on alternating even and odd bonds that consist of transverse-field Ising Hamiltonian interactions. The code allows for perfect state transfer of arbitrary distance using local operations and classical communications (LOCC).","protection":"Code distance is 1 for open boundary conditions similar to a repetition code, and 3 for periodic boundary conditions with an encoding circuit depth of 4.","features":{"encoders":["1D geometrically local constant-depth brickwork circuit of nearest-neighbor gates on alternating even and odd bonds. Gates are generated by interaction terms of the transverse-field Ising Hamiltonian."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"translationally_invariant_stabilizer"},{"code_id":"small_distance"}],"cousins":[{"code_id":"majorana_stab","detail":"The TFIM code stabilizers can be expressed in terms of Majorana operators."},{"code_id":"quantum_repetition","detail":"When written in the computational basis, the phase-flip and TFIM codewords are superpositions of qubit states of fixed total parity. The superposition is equal for the phase-flip code, whereas some states appear with a \\(-1\\) coefficient for TFIM code. However, the TFIM code can be encoded in constant depth."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-20"}]},"_zoodb":{"id":"tfim","source_file_path":"codes/quantum/qubits/small_distance/tfim.yml","source_file_modification_token":1675269976716.2407}},"eastab":{"code_id":"eastab","physical":"qubits","logical":"qubits","name":"EA qubit stabilizer code","introduced":"\\cite{arxiv:quant-ph/0608027,arxiv:quant-ph/0610092}","description":"Constructed using a variation of the stabilizer formalism designed to utilize pre-shared entanglement between sender and receiver.\nA code is typically denoted as \\([[n,k;c]]\\) or \\([[n,k,d;c]]\\), where \\(d\\) is the distance of the underlying non-EA \\([[n,k,d]]\\) code, and \\(c\\) is the number of required pre-shared maximally entangled Bell states.\nWhile other entangled states can be used, there is always a choice a generators such that the Bell state suffices while still using the fewest ebits.\n\nAn \\([[n,k+c;c]]\\) EA stabilizer code can be constructed from an ordinary \\([[n,k]]\\) stabilizer code with check matrix \\(H=(A|B)\\), where the required number of ebits is \\(c = \\text{rank}(AB^T+BA^T)\\) \\cite{arxiv:0804.1404}.\n","features":{"decoders":["Optical implementation of a minimal code using hyper-entangled states \\cite{arxiv:0807.4906}."]},"notes":["See Ref. \\cite{arxiv:2207.05647} for code tables and bounds on performance.","See Ref. \\cite{arxiv:quant-ph/9604024} for related notions."],"relations":{"parents":[{"code_id":"qubit_stabilizer","detail":"EA qubit stabilizer codes utilize additional ancillary qubits in a pre-shared entangled state, but reduce to qubit stabilizer codes when said qubits are interpreted as noiseless physical qubits."},{"code_id":"eaqecc"}],"cousins":[{"code_id":"binary_linear","detail":"Any linear binary code can be used to construct an EA qubit stabilizer code."},{"code_id":"q-ary_linear","detail":"Any linear quaternary (\\(q=4\\)) code can be used to construct an EA qubit stabilizer code."},{"code_id":"qubit_css","detail":"As opposed to CSS codes, EA qubit stabilizer codes can be constructed from any linear binary code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-12"},{"user_id":"LaneGGunderman","date":"2023-01-12"},{"user_id":"VictorVAlbert","date":"2022-07-14"}]},"_zoodb":{"id":"eastab","source_file_path":"codes/quantum/qubits/stabilizer/eastab.yml","source_file_modification_token":1681484685084.0437}},"happy":{"code_id":"happy","physical":"qubits","logical":"qubits","name":"Pastawski-Yoshida-Harlow-Preskill (HaPPY) code","short_name":"HaPPY","introduced":"\\cite{arxiv:1503.06237}","description":"Also known as a \\textit{hyperbolic pentagon code (HyPeC)}.\nHolographic code constructed out of a network of perfect tensors that tesselates hyperbolic space. Physical qubits are associated with uncontracted tensor legs at the boundary of the tesselation, while logical qubits are associated with uncontracted legs in the bulk. The code serves as a minimal model for several aspects of the AdS/CFT holographic duality and potentially a dF/CFT duality \\cite{arxiv:2201.11658}. The construction below is described for qubits, but straightforward generalizations exist to modular qudits, oscillators, and rotors \\cite{arXiv:1902.07714}.\n\nEncoding is accomplished using a tensor network of five-qubit encoding isometries, which are six-legged perfect tensors (with five legs corresponding to the physical qubits and one for the encoded logical qubit). A \\(2n\\)-legged \\textit{perfect tensor} is proportional to an isometry for any bipartition of its indices into a set \\(A\\) and a complementary set \\(A^{\\perp}\\) such that \\(|A|\\leq|A^{\\perp}|\\).\n\nTo construct the encoding, one first uniformly tiles the hyperbolic AdS/CFT disc using pentagons and hexagons. Then, one places a 6-legged five-qubit encoding tensor at each hexagon and pentagon, contracting legs between neighboring shapes and leaving one leg uncontracted at each pentagon. This construction forms an encoding isometry from the uncontracted legs in the bulk to the uncontracted legs at the boundary.\n","protection":"Protects against erasure errors and Pauli errors on the boundary qubits.","features":{"rate":"The pentagon HaPPY code has an asymptotic rate \\(\\frac{1}{\\sqrt{5}} \\approx 0.447\\). The pentagon/hexagon HaPPY code, with alternating layers of pentagons and hexagons in the tiling, has a rate of \\(0.299\\) if the last layer is a pentagon layer and a rate of \\(0.088\\) if the last layer is a hexagon layer.","encoders":["Heisenberg-picture encoding is done through \\textit{tensor pushing}. Each bulk operator (logical) is pushed to an operator supported on a portion of the boundary region (physical). Pushing all the bulk operators through results in reconstruction of the boundary."],"transversal_gates":"For locality-preserving physical gates on the boundary, the set of transversally implementable logical operations in the bulk is strictly contained in the Clifford group \\cite{arxiv:2103.13404}.","decoders":["Greedy algorithm for decoding specified in Ref. \\cite{arxiv:1503.06237}."],"threshold":["\\(26\\%\\) for boundary erasure errors on the the pentagon/hexagon HaPPY code, which has alternating layers of pentagons and hexagons in the tiling.","\\(\\sim 50\\%\\) for boundary erasure errors on the single-qubit HaPPY code, which has a central pentagon encoding one bulk operator and hexagons tiling all other layers","\\(16.3\\%\\) for boundary Pauli errors on the single-qubit HaPPY code with 3 layers \\cite{arxiv:2008.10206}.","There is no threshold for the pentagon HaPPY code as a constant number of errors (two) can make bulk recovery impossible."]},"notes":["Ref. \\cite{arXiv:2201.11658} discusses the HaPPY code for an AdS_3 space and its relation to a dS_2 \\textit{braneworld} with a conformal boundary."],"relations":{"parents":[{"code_id":"qubit_stabilizer","detail":"The HaPPY code is a stabilizer code because it is defined by a contracted network of stabilizer tensors; see Thm. 6 in Ref. \\cite{arxiv:1503.06237}."},{"code_id":"holographic"}],"cousins":[{"code_id":"stab_5_1_3","detail":"The five-qubit encoding isometry tiles various holographic codes because its corresponding tensor is perfect \\cite{arXiv:1503.06237}."},{"code_id":"majorana_stab","detail":"HaPPY code Hamiltonian can be expressed in terms of mutually commuting two-body Majorana operators \\cite{arxiv:1905.03268}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-28"},{"user_id":"VictorVAlbert","date":"2021-12-29"},{"user_id":"JoelRajakumar","date":"2021-12-20"}]},"_zoodb":{"id":"happy","source_file_path":"codes/quantum/qubits/stabilizer/happy.yml","source_file_modification_token":1681484685084.1157}},"check_product":{"code_id":"check_product","physical":"qubits","logical":"qubits","name":"Quantum check-product code","introduced":"\\cite{arXiv:2209.11405}","description":"Stub.\n","relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"generalized_homological_product_css"},{"code_id":"qltc","detail":"Quantum check-product constructions yield a sLTC code with constant soundness \\(2\\rho\\) from a classical LTC code with soundness \\(\\rho\\). While these are the first bona-fide QLTC code family because they admit asymptotically constant soundess, they are not practical because their distance is two."}],"cousins":[{"code_id":"tensor","detail":"Quantum check-product codes extend the concept of a check product, which yields the dual of a tensor code, to a product between a classical and a quantum code."},{"code_id":"distance_balanced","detail":"Quantum check-product code constructions use distance balancing to increase distance."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-26"}]},"_zoodb":{"id":"check_product","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/check_product.yml","source_file_modification_token":1681484685084.1956}},"classical_product":{"code_id":"classical_product","physical":"qubits","logical":"qubits","name":"Classical-product code","introduced":"\\cite{doi:10.1007/s11128-018-2095-3,arxiv:2209.13474}","description":"A CSS code constructed by separately constructing the \\(X\\) and \\(Z\\) check matrices using product constructions from classical codes. A particular \\([[512,174,8]]\\) code performed well \\cite{arxiv:2209.13474} against erasure and depolarizing noise when compared to other notable CSS codes, such as the asymptotically good quantum Tanner codes.\n\nFor example, for \\(H_i^x\\), \\(H_i^z\\) being the \\(X\\) and \\(Z\\) check matrices of CSS codes \\(C_i\\) with \\(i\\in\\{1,2,3,4\\}\\), the 2-fold symmetric classical product code is given by\n\\begin{align}\nH_{\\otimes}^x &:=\\left(\\begin{array}{c}\nH_1^x \\otimes H_2^x \\otimes I \\otimes I \\\\\nI \\otimes I \\otimes H_3^x \\otimes H_4^x\n\\end{array}\\right) \\\\\nH_{\\otimes}^z &:=\\left(\\begin{array}{c}\nH_1^z \\otimes I \\otimes H_3^z \\otimes I \\\\\nI \\otimes H_2^z \\otimes I \\otimes H_4^z\n\\end{array}\\right)~.\n\\end{align}","relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"qldpc"}],"cousins":[{"code_id":"quantum_tanner","detail":"A \\([[512,174,8]]\\) classical-product code performed well \\cite{arxiv:2209.13474} against erasure and depolarizing noise when compared to a member of an asymptotically good quantum Tanner code family."},{"code_id":"parity_check","detail":"SPC codes are used as component codes in classical-product code constructions."},{"code_id":"tensor","detail":"Tensor-product codes are utilized in classical-product code constructions."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-13"},{"user_id":"HarryZhou","date":"2022-11-13"}]},"_zoodb":{"id":"classical_product","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/classical_product.yml","source_file_modification_token":1681484685084.262}},"dhlv":{"code_id":"dhlv","physical":"qubits","logical":"qubits","name":"Dinur-Hsieh-Lin-Vidick (DHLV) code","short_name":"DHLV","introduced":"\\cite{arxiv:2206.07750}","description":"Stub.","features":{"rate":"Asymptotically good QLDPC codes.","decoders":["Linear-time decoder utilizing the small set-flip decoder \\cite{arxiv:2206.06557} for \\(Z\\) errors and a reconstruction procedure for \\(X\\) errors \\cite{arxiv:2206.07750}."]},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"balanced_product"}],"cousins":[{"code_id":"good_qldpc","detail":"DHLV code construction yields asymptotically good QLDPC codes."},{"code_id":"regular_binary_tanner","detail":"Regular binary Tanner codes are used in constructing quantum DHLV codes."},{"code_id":"tensor","detail":"Tensor codes are used in constructing quantum DHLV codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-06-17"}]},"_zoodb":{"id":"dhlv","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/dhlv.yml","source_file_modification_token":1683723710998.8638}},"fiber_bundle":{"code_id":"fiber_bundle","physical":"qubits","logical":"qubits","name":"Fiber-bundle code","introduced":"\\cite{arxiv:2009.03921}","description":"Also called a \\textit{twisted product code}. CSS code constructed by combining a random LDPC code as the base and a cyclic repetition code as the fiber of a fiber bundle. After applying distance balancing, a QLDPC code with distance \\(\\Omega(n^{3/5}\\text{polylog}(n))\\) and rate \\(\\Omega(n^{-2/5}\\text{polylog}(n))\\) is obtained.","features":{"rate":"Rate \\(k/n = \\Omega(n^{-2/5}/\\text{polylog}(n))\\), distance \\(d=\\Omega(n^{3/5}/\\text{polylog}(n))\\). This is the first QLDPC code to achieve a distance scaling better than \\(\\sqrt{n}~\\text{polylog}(n)\\).","decoders":["Greedy algorithm can be used to efficiently decode \\(X\\) errors, but no known efficient decoding of \\(Z\\) errors yet \\cite{arxiv:2009.03921}."]},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"balanced_product","detail":"Fiber-bundle codes can be formulated in terms of a balanced product \\cite{arXiv:2012.09271}."}],"cousins":[{"code_id":"distance_balanced","detail":"Fiber-bundle code constructions use distance balancing to increase distance."},{"code_id":"quantum_random"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-04"},{"user_id":"JonNelson","date":"2021-12-15"}]},"_zoodb":{"id":"fiber_bundle","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/fiber_bundle.yml","source_file_modification_token":1681484685084.369}},"hierarchical":{"code_id":"hierarchical","physical":"qubits","logical":"qubits","name":"Hierarchical code","introduced":"\\cite{arxiv:2303.04798}","description":"Member of a family of \\([[n,k,d]]\\) qubit stabilizer codes resulting from a concatenation of a constant-rate \\hyperref[code:qldpc]{QLDPC code} with a \\hyperref[code:rotated_surface]{rotated surface code}.\nConcatenation allows for syndrome extraction to be performed on a 2D geometry while maintining a threshold at the expense of a logarithmically vanishing rate.\nThe growing syndrome extraction circuit depth allows known bounds in the literature to be weakened \\cite{arxiv:2109.14599,arxiv:2302.04317}.","features":{"rate":"Rate vanishes as \\(\\Omega(1/\\log(n)^2)\\).","decoders":["Decoding is performed as in a standard \\hyperref[code:quantum_concatenated]{concatenated code} using a decoder for the inner code and outer code."],"threshold":["Threshold exists for the locally decaying error model; see \\cite[Thm. 1.3]{arxiv:2303.04798}. However, the logical error rate below threshold falls super-polynomially (as opposed to exponentially) with the code distance. The code family possesses a threshold equal to that of surface codes given by tuning the inner code size for any fixed physical error rate."],"fault_tolerance":["2D geometrically local syndrome extraction circuits of depth \\(O(\\sqrt{n}/R)\\) that utilize Clifford and SWAP gates of range \\(R\\) and that require order \\(O(n)\\) data and ancilla qubits. Such parameters (including a range of one) are possible while maintaining a threshold because of the concatenation step. This reduces the noise that would otherwise accumulate within a growing-depth syndrome extraction circuit. A key idea is that constant-depth syndrome extraction is not a necessary condition for fault-tolerance."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"qldpc"},{"code_id":"quantum_concatenated","detail":"Hierarchical code is a concatenation of a constant-rate QLDPC code (outer code) with a rotated surface code (inner code). The block length of the inner code is picked to grow logarithmically with the block length of the outer code."}]},"_meta":{"changelog":[{"user_id":"ChrisPattison","date":"2023-06-02"},{"user_id":"VictorVAlbert","date":"2023-03-12"}]},"_zoodb":{"id":"hierarchical","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/hierarchical.yml","source_file_modification_token":1687727505574.4805}},"homological_product":{"code_id":"homological_product","physical":"qubits","logical":"qubits","name":"Homological product code","introduced":"\\cite{arXiv:1301.1363,arXiv:1311.0885}","description":"CSS code formulated using the homological product of two chain complexes (see \\ref{topic:CSS-to-homology-correspondence}). Stub.\n","protection":"Given two codes \\([[n_a, k_a, d_a, w_a]]\\) for \\(a\\in\\{1,2\\}\\), where \\(w_a\\) denotes the maximum hamming weight of all rows and columns of \\(\\partial_a\\), the homological product code has parameter \\([[n=n_1 n_2, k=k_1 k_2, d\\leq d_1 d_2, w\\leq w_1+w_2]]\\). From this formula, and the fact that a randomly selected boundary operator \\(\\partial\\) yields a CSS code that is good with high probability, we see that the product code has \\(k=\\Theta(n)\\) and \\(w=O(\\sqrt{n})\\) with high probability. The main result in \\cite{arXiv:1311.0885} is to show that the product code actually has linear distance with high probability as well. To sum up, it is shown that we have a family of \\([[n,k=c_1 n, d=c_2 n, w=c_3 \\sqrt{n}]]\\) codes given small enough \\(c_1,c_2,c_3\\).","features":{"general_gates":["Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state \\cite{arXiv:1807.09783}."],"fault_tolerance":["Universal set of gates can be obtained by fault-tolerantly mapping between different encoded representations of a given logical state \\cite{arXiv:1807.09783}."],"decoders":["Union-find \\cite{arXiv:2009.14226}."]},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"fiber_bundle","detail":"Fiber-bundle code can be viewed as a homological product code with a twisted product."}],"cousins":[{"code_id":"quantum_random","detail":"Random homological codes are asymptotically good with high probability \\cite[Thm. 1]{arXiv:1301.1363}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-22"},{"user_id":"VictorVAlbert","date":"2022-03-14"},{"user_id":"XinyuanZheng","date":"2021-12-15"},{"user_id":"VictorVAlbert","date":"2021-12-03"}]},"_zoodb":{"id":"homological_product","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/homological/homological_product.yml","source_file_modification_token":1681484685084.5146}},"hypergraph_product":{"code_id":"hypergraph_product","physical":"qubits","logical":"qubits","name":"Hypergraph product (HGP) code","short_name":"HGP","introduced":"\\cite{arXiv:0903.0566,arxiv:1202.0928}","description":"A family of \\([[n,k,d]]\\) CSS codes whose construction is based on two binary linear \\textit{seed} codes \\(C_1\\) and \\(C_2\\).","protection":"The hypergraph product has distance \\(d=O(\\sqrt{n})\\). The number of encoded logical qubits is \\(k=O(k_1k_2)\\) where \\(k_1\\) and \\(k_2\\) are the dimensions of the classical seed codes \\(C_1\\) and \\(C_2\\).","features":{"transversal_gates":"Hadamard (up to logical SWAP gates) and control-\\(Z\\) on all logical qubits \\cite{arXiv:2204.10812}.","decoders":["ReShape decoder that uses minimum weight decoders for the classical codes used in the hypergraph construction \\cite{arxiv:2105.02370}.","2D geometrically local syndrome extraction circuits with depth order \\(O(\\sqrt{n})\\) using order \\(O(n)\\) ancilla qubits \\cite{arxiv:2109.14599}.","Improved BP-OSD decoder \\cite{arxiv:2206.03122}.","Erasure-correction can be implemented approximately with \\(O(n^2)\\) operations with quantum generalizations \\cite{arxiv:2208.01002} of the peeling and pruned peeling decoders \\cite{doi:10.1109/18.910575}, with a probabilistic version running in \\(O(n^{1.5})\\) operations."],"general_gates":["Code deformation techniques yield Clifford gates \\cite{arXiv:1909.07424}."],"code_capacity_threshold":["The threshold under ML decoding corresponds to the value of critical point of a two-dimensional random-bond Ising model on the Nishimori line \\cite{doi:10.1143/JPSJ.55.3305,arxiv:quant-ph/0110143,arxiv:1804.01950} (see also \\cite{arxiv:2301.05689})."],"threshold":["Circuit-level noise: \\(0.1\\%\\) with all-to-all connected syndrome extraction circuits \\cite{arxiv:2109.14599}. No threshold observed above physical noise rates at or above \\(10^{-6}\\) using 2D geometrically local syndrome extraction circuits."]},"relations":{"parents":[{"code_id":"homological_product","detail":"A homological product of chain complexes corresponding to two classical codes is a hypergraph product code \\cite{arxiv:2009.03921}."},{"code_id":"lifted_product","detail":"Lifted-product codes for trivial group \\(G\\) are hypergraph-product codes."},{"code_id":"sc_qldpc","detail":"Hypergraph-product stabilizer generator matrices can be used as sub-matrices to define a 2D SC-QLDPC code \\cite{arxiv:2305.00137}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-02"},{"user_id":"VictorVAlbert","date":"2022-01-20"},{"user_id":"JoschkaRoffe","date":"2021-11-04"}]},"_zoodb":{"id":"hypergraph_product","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/homological/hypergraph_product.yml","source_file_modification_token":1683978912609.633}},"lossless_expander":{"code_id":"lossless_expander","physical":"qubits","logical":"qubits","name":"Lossless expander balanced-product code","introduced":"\\cite{arXiv:2201.11369,arxiv:2203.03581}","description":"QLDPC code constructed by taking the balanced product of lossless expander graphs.\nUsing one part of a quantum-code chain complex constructed with one-sided loss expanders \\cite{doi:10.1145/509907.510003} yields a \\(c^3\\)-LTC \\cite{arxiv:2201.11369}.\nUsing two-sided expanders, which are only conjectured to exist, yields an asymptotically good QLDPC code family \\cite{arxiv:2203.03581}.\n","features":{"rate":"Asymptotically good QLDPC codes \\cite{arxiv:2203.03581}, assuming the existence of two-sided lossless expanders."},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"balanced_product"}],"cousins":[{"code_id":"ltc","detail":"Using one part of a quantum-code chain complex constructed with one-sided loss expanders yields a \\(c^3\\)-LTC \\cite{arxiv:2201.11369}."},{"code_id":"good_qldpc","detail":"Taking a balanced product of two-sided expanders, which are only conjectured to exist, yields an asymptotically good QLDPC code family \\cite{arxiv:2203.03581}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-10"}]},"_zoodb":{"id":"lossless_expander","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/homological/lossless_expander.yml","source_file_modification_token":1683978912609.7031}},"quantum_expander":{"code_id":"quantum_expander","physical":"qubits","logical":"qubits","name":"Quantum expander code","introduced":"\\cite{arXiv:1504.00822}","description":"CSS codes constructed from a hypergraph product of bipartite expander graphs \\cite{doi:10.1090/S0273-0979-06-01126-8} with bounded left and right vertex degrees. For every bipartite graph there is an associated matrix (the parity check matrix) with columns indexed by the left vertices, rows indexed by the right vertices, and 1 entries whenever a left and right vertex are connected. This matrix can serve as the parity check matrix of a classical code. Two bipartite expander graphs can be used to construct a quantum CSS code (the quantum expander code) by using the parity check matrix of one as \\(X\\) checks, and the parity check matrix of the other as \\(Z\\) checks.","protection":"Pauli errors of weight \\(\\leq t\\), distance scales as \\(\\Omega(n^{1/2})\\).","features":{"rate":"\\([[n,k=\\Theta(n),d=O(\\sqrt{n})]]\\) code with asymptotically constant rate.","decoders":["Small set-flip linear-time decoder, which corrects \\(\\Omega(n^{1/2})\\) adversarial errors \\cite{arXiv:1504.00822}.","Log-time decoder \\cite{arxiv:1808.03821}.","Constant-time decoder \\cite{manual:{A. Grospellier. Constant time decoding of quantum expander codes and application to fault-tolerant quantum computation. PhD thesis, Inria Paris (2019).}}.","2D geometrically local syndrome extraction circuits acting on a patch of \\(N\\) physical qubits have to be of depth at least \\(\\Omega(n/\\sqrt{N})\\) \\cite{arxiv:2109.14599}."],"fault_tolerance":["Fault-tolerance with constant overhead can be achieved \\cite{arXiv:1808.03821}."],"threshold":["Locally stochastic noise: \\(2.7 \\cdot 10^{-16}\\) \\cite{arXiv:1711.08351}."]},"relations":{"parents":[{"code_id":"hypergraph_product"}],"cousins":[{"code_id":"expander"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-23"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"NolanCoble","date":"2021-12-03"}]},"_zoodb":{"id":"quantum_expander","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/homological/quantum_expander.yml","source_file_modification_token":1683723710999.124}},"iterated_ramanujan":{"code_id":"iterated_ramanujan","physical":"qubits","logical":"qubits","name":"Tensor-product HDX code","introduced":"\\cite{arXiv:2008.09495}","description":"Code constructed in a similar way as the HDX code, but utilizing tensor products of Ramanujan complexes in order to improve code distance from \\(\\sqrt{n}\\log n\\) to \\(\\sqrt{n}~\\text{polylog}(n)\\). The utility of such tensor products comes from the fact that one of the Ramanujan complexes is a \\textit{collective cosystolic expander} as opposed to just a cosystolic expander.","protection":"Construction yields explicit QLDPC codes with distance \\(\\sqrt{n}\\log^c n\\) using the \\(c\\)-tensor-product of Ramanujan complexes.","relations":{"parents":[{"code_id":"ramanujan_tensor_product"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-10-02"}]},"_zoodb":{"id":"iterated_ramanujan","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/iterated_ramanujan.yml","source_file_modification_token":1681484685084.6907}},"quantum_tanner":{"code_id":"quantum_tanner","physical":"qubits","logical":"qubits","name":"Quantum Tanner code","introduced":"\\cite{arXiv:2202.13641}","description":"Member of a family of QLDPC codes based on two compatible classical Tanner codes defined on a two-dimensional Cayley complex.\nFor certain choices of codes and complex, the resulting codes have asymptotically good parameters.\n\nThe underlying geometric complex of the code is a left-right Cayley complex \\(\\operatorname{Cay}_2(A,G,B)\\), where \\(G\\) is a finite group and \\(A=A^{-1}\\), \\(B=B^{-1}\\) are two symmetric generating sets satisfying the total no-conjugacy condition: \\(ag\\ne gb\\) for any \\(g\\in G\\), \\(a\\in A\\), and \\(b\\in B\\).\nThe vertices of the complex are group elements, i.e., \\(V=G\\). If necessary, the double cover of the graph should be taken so that the graph is bipartite, \\(V=V_0\\sqcup V_1\\).\n\nThere are two types of edges in the resulting complex,\n  \\begin{align}\n  \\begin{split}\n    E_A &= \\{(g,ag): g\\in G, a\\in A\\}\\\\\n    E_B &= \\{(g,gb): g\\in G, b\\in B\\}~.\n  \\end{split}\n  \\end{align}\nThe faces are squares defined by quadruples,\n  \\begin{align}\n    Q = \\{(g,ag,gb,agb): g\\in G, a\\in A, b\\in B\\}~.\n  \\end{align}\nTwo additional graphs can be obtained from \\(\\operatorname{Cay}_2(A,G,B)\\) by taking the diagonals of the squares as edges, \\(\\mathcal G_0^\\square = (V_0, Q)\\) and \\(\\mathcal G_1^\\square = (V_1, Q)\\).\n\nIn the quantum Tanner construction, qubits are placed on the squares of the left-right Cayley complex.\nTwo classical codes \\(C_A\\) and \\(C_B\\) of blocklengths \\(|A|\\) and \\(|B|\\), respectively, are chosen, yielding local codes \\(C_0 = C_A\\otimes C_B\\) and \\(C_1 = C_A^\\perp\\otimes C_B^\\perp\\).\nThe quantum Tanner code is a CSS code defined by the classical Tanner codes \\(C_Z = T(\\mathcal G_0^\\square, C_0^\\perp)\\) and \\(C_X = T(\\mathcal G_1^\\square, C_1^\\perp)\\).\nThe figure below depicts an example of a stabilizer generator.\n\n\\begin{figure}\n  \\includegraphics{local-view-stabilizer.png}\n  \\caption{An example of a \\(Z\\) generator on a \\(V_0\\) local view when \\(C_A = \\{000\\}\\) and \\(C_B=\\{110, 011\\}\\). The faces incident to a \\(V_0\\) vertex are in bijection with the set \\(A\\times B\\), and a codeword of \\(C_0 = C_A\\otimes C_B\\) can be described using this set.}\n  \\label{figure:local-view-stabilizer}\n\\end{figure}\n\nTo achieve asymptotically good parameters, fixed classical local codes are chosen so that their dual tensor codes are sufficiently robust, and the left-right Cayley complexes are chosen to be sufficiently expanding. The family is defined using a family of groups \\(G\\) of increasing size but constant-size generating sets \\(A\\), \\(B\\).\n","protection":"For correctly chosen complexes and local codes, the distance scales as \\(d=\\Theta(n)\\). Minimum distance bound obtained using robustness of dual \\hyperref[code:tensor]{tensor-product} codes \\cite{arxiv:2208.05537}.","features":{"rate":"Asymptotically good QLDPC codes. When \\(C_A\\) and \\(C_B\\) are chosen to have rates not equal to a half, the number of encoded qubits scales as \\(k=\\Theta(n)\\).","decoders":["Linear-time decoder similar to the small-set-flip decoder for quantum expander codes \\cite{arxiv:2206.06557}.","Linear-time decoder \\cite{arxiv:2206.07571}.","Logarithmic-time decoder \\cite{arxiv:2208.05537}."]},"realizations":["Used to obtain explicit lower bounds in the sum-of-squares game \\cite{arXiv:2204.11469}.","States that, on average, achieve small violations of check operators for quantum Tanner codes require a circuit of non-constant depth to make. They are used in the proof \\cite{arxiv:2206.13228} of the \\textit{No low-energy trivial states} (NLTS) conjecture \\cite{arxiv:1301.1363}."],"notes":["For details, see talk by \\href{https://www.youtube.com/watch?v=5GO3BtJuo3I}{A. Leverrier}."],"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"generalized_homological_product_css"},{"code_id":"single_shot","detail":"Quantum Tanner codes facilitate single-shot decoding \\cite{arxiv:2306.12470}."}],"cousins":[{"code_id":"good_qldpc","detail":"Quantum Tanner code construction yields asymptotically good QLDPC codes."},{"code_id":"regular_binary_tanner","detail":"Regular binary Tanner codes are used in constructing quantum Tanner codes."},{"code_id":"tensor","detail":"Tensor codes are used in constructing quantum Tanner codes."},{"code_id":"expander_lifted_product","detail":"Quantum Tanner codes are an attempt to construct asymptotically good QLDPC codes that are similar to but simpler than expander lifted-product codes; see Ref. \\cite{arxiv:2206.07571} for connection between the codes."}]},"_meta":{"changelog":[{"user_id":"BaileyGu","date":"2023-02-21"},{"user_id":"VictorVAlbert","date":"2023-02-21"},{"user_id":"VictorVAlbert","date":"2022-08-12"},{"user_id":"VictorVAlbert","date":"2022-04-26"}]},"_zoodb":{"id":"quantum_tanner","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/quantum_tanner/quantum_tanner.yml","source_file_modification_token":1689550329219.3416}},"ramanujan_tensor_product":{"code_id":"ramanujan_tensor_product","physical":"qubits","logical":"qubits","name":"High-dimensional expander (HDX) code","short_name":"HDX","introduced":"\\cite{arXiv:2004.07935}","description":"CSS code constructed from a Ramanujan quantum code and an asymptotically good classical LDPC code using distance balancing. Ramanujan quantum codes are defined using Ramanujan complexes which are simplicial complexes that generalise Ramanujan graphs \\cite{doi:10.1007/BF02126799,doi:10.1017/CBO9780511615825}. Combining the quantum code obtained from a Ramanujan complex and a good classical LDPC code, which can be thought of as coming from a 1-dimensional chain complex, yields a new quantum code that is defined on a 2-dimensional chain complex. This 2-dimensional chain complex is obtained by the co-complex of the product of the 2 co-complexes. The length, dimension and distance of the new quantum code depend on the input codes.","protection":"Without distance balancing, a Ramanujan code can have \\(d_X =\\Omega(\\log n)\\) and \\(d_Z = \\Omega (n)\\). For 2D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d = \\Omega(\\sqrt{n \\log n})\\). For 3D Ramanujan complexes, distance-balanced codes protect against errors with minimum distance \\(d= \\Omega(\\sqrt{n} \\log n )\\).","features":{"rate":"For 2D Ramanujan complexes, the rate is \\(\\Omega(\\sqrt{ \\frac{1}{n \\log n} })\\), with minimum distance \\(d = \\Omega(\\sqrt{n \\log n}) \\). For 3D, the rate is \\( \\Omega(\\frac{1}{\\sqrt{n}\\log n}) \\) with minimum distance \\(d \\geq \\sqrt{n} \\log n \\).","decoders":["For 2D simplicial complexes, cycle code decoder admitting a polynomial-time decoding algorithm can be used \\cite{arXiv:2004.07935}."]},"notes":["Codes were first to break a 20-year record set by the \\hyperref[code:freedman_meyer_luo]{Freedman-Meyer-Luo code} for the lower bound on scaling of the minimum distance \\cite{arXiv:2103.06309}."],"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"generalized_homological_product_css","detail":"Ramanujan codes result from a tensor product of a classical-code and a quantum-code chain complex."}],"cousins":[{"code_id":"distance_balanced","detail":"Ramanujan tensor-product constructions use distance balancing to increase distance."},{"code_id":"hypergraph_product","detail":"Ramanujan codes utilize the hypergraph product with a twist, which is an automorphism on one of the complexes in the tensor product, in order to increase distance \\cite{arXiv:2103.06309}."},{"code_id":"freedman_meyer_luo","detail":"Ramanujan codes broke 20-year record on minimum code distance set by Freedman-Meyer-Luo codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-03"},{"user_id":"XiaozhenFu","date":"2021-12-12"}]},"_zoodb":{"id":"ramanujan_tensor_product","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/ramanujan_tensor_product.yml","source_file_modification_token":1683723711001.5383}},"sc_qldpc":{"code_id":"sc_qldpc","physical":"qubits","logical":"qubits","name":"Quantum spatially coupled (SC-QLDPC) code","short_name":"SC-QLDPC","introduced":"\\cite{arxiv:1102.3181,arxiv:2305.00137}","description":"QLDPC code whose stabilizer generator matrix resembles the parity-check matrix of SC-LDPC codes.\nThere exist CSS \\cite{arxiv:1102.3181} and stabilizer constructions \\cite{arxiv:2305.00137}.\nIn either case, the stabilizer generator matrix is constructed by \"spatially\" coupling sub-matrix blocks in chain-like fashion (or, more generally, in grid-like fashion) to yield a band matrix.\nThe sub-matrix blocks have to satisfy certain conditions amongst themselves so that the resulting band matrix is a stabilizer generator matrix.\nMatrices corresponding to translationally invariant chains are called \\textit{time-variant}, and otherwise are called \\textit{time-invariant}.\n\nA finite-length chain is then capped by imposing either open boundary conditions (yielding \\textit{non-tail-biting} SC-QLDPC codes) or open boundary conditions (yielding \\textit{tail-biting} SC-QLDPC codes).\nBoth constructions \\cite{arxiv:1102.3181,arxiv:2305.00137} are tail-biting.\n\nIn the stabilizer construction \\cite{arxiv:2305.00137}, the structure of the band matrix allows codes to be concisely defined in terms of \\textit{characteristic polynomials}, whose coefficients are the sub-matrix blocks and which resemble the \\hyperref[topic:quantum-polynomial-mapping]{Pauli-to-polynomial mapping} associated with translationally invariant stabilizer codes.\nSome CSS code constructions can used to define sub-matrix blocks, yielding spatially coupled (i.e., translationally invariant) extensions of such codes.\n\nFor example, the \\(3\\times 3\\) toric code can be expressed as an SC-QLDPC code with stabilizer generator matrix given in \\ref{figure:sc-qldpc-3toric-stabilizer-generators}.\n\\begin{figure}\n  \\includegraphics{sc_qldpc_3toric_generator_matrix}\n  \\caption{Stabilizer generator matrix of the \\(3\\times 3\\) toric code, expressed\n      as an SC-QLDPC code.}\n  \\label{figure:sc-qldpc-3toric-stabilizer-generators}\n\\end{figure}\n","relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"translationally_invariant_stabilizer","detail":"Stabilizer generator matrices of SC-QLDPC codes on infinite-length chains or grids define a class of translationally-invariant stabilizer codes."}],"cousins":[{"code_id":"sc_ldpc","detail":"SC-QLDPC code stabilizer-generator matrices have similar block form as the parity-check matrices of SC-LDPC codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-10"}]},"_zoodb":{"id":"sc_qldpc","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/sc_qldpc/sc_qldpc.yml","source_file_modification_token":1687727505574.5837}},"xyz_product":{"code_id":"xyz_product","physical":"qubits","logical":"qubits","name":"XYZ product code","introduced":"\\cite{arxiv:2011.09746}","description":"A non-CSS QLDPC code constructed from three classical codes. The construction of an XYZ product code is similar to that of a hypergraph product code and related codes. The idea is that rather than taking a product of only two classical codes to produce a CSS code, a third classical code is considered, acting with Pauli-\\(Y\\) operators.\n","features":{"rate":"Not much has been proven about the relationship between XYZ-product codes and other codes. The logical dimension depends on properties of the input classical codes, specifically \\textit{similarity invariants} from abstract algebra. It is conjectured that specific instances of XYZ-product codes have a constant encoding rate and a minimum distance of \\(d \\in \\Theta(n^{2/3})\\) \\cite{arxiv:2011.09746}.\n"},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"generalized_homological_product","detail":"XYZ product codes result from a tensor product of three classical-code chain complexes."},{"code_id":"sc_qldpc","detail":"XYZ-product stabilizer generator matrices can be used as sub-matrices to define a 2D SC-QLDPC code \\cite{arxiv:2305.00137}."}],"cousins":[{"code_id":"hypergraph_product","detail":"The XYZ product code is based on a hypergraph product of three classical codes."}]},"_meta":{"changelog":[{"user_id":"FinneganVoichick","date":"2021-12-01"}]},"_zoodb":{"id":"xyz_product","source_file_path":"codes/quantum/qubits/stabilizer/qldpc/xyz_product.yml","source_file_modification_token":1683978912609.889}},"quantum_bch":{"code_id":"quantum_bch","physical":"qubits","logical":"qubits","name":"Qubit BCH code","introduced":"\\cite{arxiv:quant-ph/9605021,arXiv:quant-ph/9610042,arxiv:quant-ph/9608006,arxiv:quant-ph/9802061,arxiv:quant-ph/9910060}","description":"Qubit stabilizer code constructed from a self-orthogonal binary BCH code via the CSS construction, from a Hermitian self-orthogonal quaternary BCH code via the stabilizer-over-\\(GF(4)\\) construction, or by taking a Euclidean self-orthogonal BCH code over \\(GF(2^m)\\), converting it to a binary code, and applying the CSS construction.\n","relations":{"parents":[{"code_id":"qubit_stabilizer","detail":"Qubit BCH codes constructed via the CSS construction are CSS codes, and the rest are stabilizer codes over \\(GF(4)\\)."},{"code_id":"galois_bch","detail":"Galois-qudit BCH codes for \\(q=2\\) reduce to qubit BCH codes."}],"cousins":[{"code_id":"bch","detail":"Binary BCH codes are used to construct a subset of qubit BCH codes via the CSS construction."},{"code_id":"q-ary_bch","detail":"BCH codes are used to construct qubit BCH codes via the CSS and stabilizer-over-\\(GF(4)\\) constructions."},{"code_id":"qubit_css","detail":"Some qubit BCH codes are CSS."},{"code_id":"stabilizer_over_gf4","detail":"Hermitian self-orthogonal quaternary BCH codes are used to construct a subset of qubit BCH codes via the stabilizer-over-\\(GF(4)\\) construction."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-21"}]},"_zoodb":{"id":"quantum_bch","source_file_path":"codes/quantum/qubits/stabilizer/quantum_bch.yml","source_file_modification_token":1681484685085.1677}},"quantum_parity":{"code_id":"quantum_parity","physical":"qubits","logical":"qubits","name":"Quantum parity code (QPC)","short_name":"QPC","introduced":"\\cite{arxiv:quant-ph/0006088,arxiv:quant-ph/0501184,doi:10.1038/35051009}","description":"Also called a \\textit{generalized Shor code} \\cite{arxiv:quant-ph/0610088}. A \\([[m_1 m_2,1,\\min(m_1,m_2)]]\\) CSS code family obtained from concatenating an \\(m_1\\)-qubit phase-flip repetition code with an \\(m_2\\)-qubit bit-flip repetition code. Logical codewords are\n\\begin{align}\n\\begin{split}\n|\\overline{0}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}+|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}\\\\\n|\\overline{1}\\rangle&=\\frac{1}{2^{m_2/2}}\\left(|0\\rangle^{\\otimes m_1}-|1\\rangle^{\\otimes m_1}\\right)^{\\otimes m_2}~.\n\\end{split}\n\\end{align}\n","protection":"Has distance \\(d=\\min(m_1,m_2)\\).","realizations":["The \\([[m^2,1,m]]\\) codes for \\(m\\leq 7\\) have been realized in trapped-ion quantum devices \\cite{arXiv:2104.01205}."],"notes":["Non-determinisitic linear-optical encoding \\cite{arxiv:quant-ph/0501184} whose success probability \\(P_{E}\\) is determined by the efficiency \\(\\eta\\) of the photonic encoding circuit. A threshold \\(\\eta > 0.82 \\) exists for the efficiency, above which \\(P_{E}\\to 1\\) as \\(m_1\\to\\infty\\) given particular \\(m_2\\).","Studied in the context of error-corrected quantum repeaters \\cite{arXiv:1310.5291}."],"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"translationally_invariant_stabilizer"},{"code_id":"quantum_concatenated","detail":"A QPC is a concatenation of a phase-flip repetition code with a bit-flip repetition code."},{"code_id":"bacon_shor","detail":"Bacon-Shor codes reduce to QPCs for a particular gauge configuration."}],"cousins":[{"code_id":"majorana_stab","detail":"QPCs for \\(m_1=m_2\\) can be conveniantly expressed in terms of mutually commuting Majorana operators \\cite{arxiv:quant-ph/0003137}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-31"},{"user_id":"XinyuanZheng","date":"2021-12-20"}]},"_zoodb":{"id":"quantum_parity","source_file_path":"codes/quantum/qubits/stabilizer/quantum_parity.yml","source_file_modification_token":1681484685085.2317}},"quantum_polar":{"code_id":"quantum_polar","physical":"qubits","logical":"qubits","name":"Quantum polar code","introduced":"\\cite{arxiv:1109.3195}","description":"Entanglement-assisted CSS code utilized in a quantum polar coding scheme producing entangled pairs of qubits between sender and receiver. In such a scheme, the amplitude and phase information of a quantum state is handled in complementary fashion \\cite{arxiv:0803.3096} using an encoding based on classical polar codes. Variants of the initial scheme have been developed for degradable channels \\cite{arxiv:1201.2906} and extended to arbitrary channels \\cite{arxiv:1109.5346}.\n\nThe scheme requires some a-priori quantum side information in the general case, making the associated code entanglement assisted \\cite{arxiv:1109.3195}. The requirement of having quantum side information vanishes when the sum of the amplitude channel fidelity and the phase channel fidelity is not greater than 1. It is shown to vanish for the case of degradable noise channels \\cite{arxiv:1109.5346}. A more complicated quantum polar-coding scheme that does not require pre-shared entanglement has also been derived \\cite{arxiv:1307.1136}.\n","protection":"Protects against Pauli noise and erasures.","features":{"rate":"The rate approaches the symmetric coherent information of arbitrary quantum channels \\cite{arxiv:1201.2906}.","decoders":["Quantum successive-cancellation list decoder (SCL-E) for quantum polar codes that do not need entanglement assistance \\cite{arxiv:2304.04743}."],"fault_tolerance":["State preparation of a single logical qubit \\cite{arxiv:2209.06673}."]},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"eastab","detail":"Quantum polar codes are CSS codes used in an entanglement generation scheme that generally requires entanglement assistance. They require assistance only to determine positions to store information which optimally protect against both bit and phase noise. Without this assistance, they are just CSS codes constructed out of polar codes. A variant of quantum polar codes exists that does not require entanglement assistance \\cite{arxiv:1307.1136}."}],"cousins":[{"code_id":"polar","detail":"Without entanglement assistance, quantum polar codes are just CSS codes constructed out of polar codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-06"},{"user_id":"RichardBarney","date":"2022-05-18"},{"user_id":"VictorVAlbert","date":"2021-12-03"}]},"_zoodb":{"id":"quantum_polar","source_file_path":"codes/quantum/qubits/stabilizer/quantum_polar.yml","source_file_modification_token":1681484685085.3674}},"quantum_triorthogonal":{"code_id":"quantum_triorthogonal","physical":"qubits","logical":"qubits","name":"Triorthogonal code","introduced":"\\cite{arXiv:1209.2426}","description":"A triorthogonal \\(m \\times n\\) binary matrix is triorthogonal if its rows \\(r_1, \\ldots, r_m\\) satisfy \\(|r_i \\cdot r_j| = 0\\) and \\(|r_i \\cdot r_j \\cdot r_k| = 0\\), where addition and multiplication are done on \\(\\mathbb{Z}_2\\). The triorthogonal code associated with the matrix is constructed by mapping non-zero entries in even-weight rows to \\(X\\) operators, and \\(Z\\) operators for each row in the orthogonal complement.","protection":"Weight \\(t\\) Pauli errors, where \\(t\\) depends on the family. For example, Ref. \\cite{arXiv:1209.2426} provides a family of distance \\(2\\) codes. It also presents a \\([[49, 1, 5]]\\) code.","features":{"magic_scaling_exponent":"Depends on the matrix. Reference \\cite{arXiv:1209.2426} gave a family of \\(\\frac{k}{3k+8}\\) codes with magic-state distillation scaling exponent \\(\\gamma = \\log_2 \\frac{3k+8}{k}\\).","encoders":["Encoder for magic states for the code constructed in \\cite{arXiv:1209.2426}."],"transversal_gates":"Admits transversal \\(T\\) gates \\cite{arXiv:1209.2426} and the controlled-controlled-\\(Z\\) gate \\cite{arxiv:1304.3709}.","general_gates":["Triorthogonal codes can be used for high-quality magic-state distillation \\cite{arXiv:1209.2426}."],"threshold":["Approximately \\(\\frac{1}{3k + 1}\\) \\cite{arXiv:1209.2426}."],"fault_tolerance":["Universal fault-tolerant gates can be performed without magic-state distillation \\cite{arxiv:1304.3709,arxiv:2210.14074}."]},"notes":["Reference \\cite{arXiv:2107.09684} presents a classification of triorthogonal codes up to \\(n + k \\leq 38\\) by associating each triorthogonal code with a Reed-Muller polynomial."],"relations":{"parents":[{"code_id":"qubit_css"}],"cousins":[{"code_id":"quantum_reed_muller","detail":"Classification of triorthongonal codes yields a connection to Reed-Muller polynomials \\cite{arXiv:2107.09684}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"BenjaminQuiring","date":"2021-12-16"}]},"_zoodb":{"id":"quantum_triorthogonal","source_file_path":"codes/quantum/qubits/stabilizer/quantum_triorthogonal.yml","source_file_modification_token":1681484685085.4453}},"qubit_css":{"code_id":"qubit_css","physical":"qubits","logical":"qubits","name":"Qubit CSS code","introduced":"\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029}","description":"An \\([[n,k,d]]\\) stabilizer code admitting a set of stabilizer generators that are either \\(Z\\)-type or \\(X\\)-type Pauli strings.\nCodes can be defined from two classical codes and/or chain complexes over \\(\\mathbb{Z}_2\\) per the \\hyperref[topic:CSS-to-homology-correspondence]{qubit CSS-to-homology correspondence} below.\n\nThe stabilizer generator matrix is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parity}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:comm}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related \\hyperref[code:binary_linear]{binary linear codes}, an \\([n,k_X,d_X]\\) code \\(C_X\\) and \\([n,k_Z,d_Z]\\) code \\(C_Z\\), satisfying \\(C_X^\\perp \\subseteq C_Z\\).\nThe resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\).\nThe \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parity} is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)).\nThe requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\eqref{eq:comm} and also implies  \\(C_Z^\\perp \\subseteq C_X \\).\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n\nA CSS code has \\textit{stabilizer weight} \\(w\\) if the highest weight of any stabilizer generator is \\(w\\), i.e., any row of \\(H_X\\) and \\(H_Z\\) has weight at most \\(w\\).\nIn the context of comparing weight as well as of determining distances for noise models biased toward \\(X\\)- or \\(Z\\)-type errors, an extended notation for \\textit{asymmetric} CSS codes is \\([[n,k,(d_X,d_Z),w]]\\) or \\([[n,k,d_X/d_Z,w]]\\).\nThe quantity \\(\\min\\{d_X,d_Z\\}\\) is often called the \\textit{worst-case minimum distance} and is often less than the actual code distance due to degeneracy \\cite{preset:GottesmanBook}.\n\nTo find the minimum distance of degenerate CSS code, we have to first remove the codewords of the smaller codes as those codewords correspond to stabilizer generators instead of logical operators.\nThus the general formulae for the minimum distances \\(d, d_Z, d_X\\) for an \\([[n,k,d]]\\) or \\([[n,k,(d_X,dZ)]]\\) \\(CSS(C_X, C_Z)\\) code are:\n\\begin{align}\nd_{X}&=\\min\\{ w_H(c) | c \\in C_X \\setminus C_Z^\\perp \\} \\\\\nd_{Z}&=\\min\\{ w_H(c) | c \\in C_Z \\setminus C_X^\\perp \\} \\\\\nd&=\\min\\{d_X,d_Z\\}~,\n\\end{align}\nwhere \\(w_H\\) is the Hamming weight of a codeword.\n\n\\subsection{CSS-to-homology correspondence}\n\n\\begin{defterm}{Qubit CSS-to-homology correspondence}\n\\label{topic:CSS-to-homology-correspondence}\nCSS codes and their properties can be formulated in terms of homology theory, yielding a powerful correspondence between codes and chain complexes, the primary homological structures.\nThere exists a many-to-one mapping from size three chain complexes to CSS codes \\cite{doi:10.1070/RM1997v052n06ABEH002155,arXiv:quant-ph/0605094,arXiv:1311.0885,arXiv:1802.01520} that allows one to extract code properties from topological features of the complexes.\nCodes constructed in this manner are sometimes called \\textit{homological CSS codes}, but they are equivalent to CSS codes.\nThis mapping of codes to manifolds allows the application of structures from topology to error correction, yielding \\hyperref[code:generalized_homological_product]{various QLDPC codes} with favorable properties.\n\\end{defterm}\n\nA \\textit{chain complex} of size three is given by binary vector spaces \\(A_2\\), \\(A_1\\), \\(A_0\\) and binary matrices \\(\\partial_{i=1,2}\\) (called \\textit{boundary operators}) \\(A_i\\) to \\(A_{i-1}\\) that satisfy \\(\\partial_1 \\partial_2 = 0\\). Such a complex is typically denoted as\n\\begin{align}\nA_2 \\xrightarrow{\\partial_2} A_1 \\xrightarrow{\\partial_1} A_0~.\n\\label{eq:chain}\n\\end{align}\nOne constructs a CSS code by associating a physical qubit to every basis element of \\(A_1\\), and defining parity-check matrices \\(H_X=\\partial_1\\) and \\(H_Z=\\partial_2^T\\)). That way, the spaces \\(A_0\\) and \\(A_2\\) can be associated with \\(X\\)-type and \\(Z\\)-type Pauli operators, respectively, and boundary operators determine the Paulis making up the stabilizer generators. The requirement \\(\\partial_1 \\partial_2 = 0\\) guarantees that the \\(X\\)-stabilizer generators associated with \\(H_X\\) commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nUsually, the chain complex \\eqref{eq:chain} used in the construction comes from the chain complex associated with a cellulation of a manifold. When the manifold is a two-dimensional surface, its entire chain is used. Higher-dimensional manifolds allow for longer chain complexes, and one can use the three largest non-trivial vector spaces in its chain.\n","protection":"Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.\n\nUsing the relation to chain complexes, the number of encoded logical qubits is equal to the dimension of the first \\(\\mathbb{Z}_2\\)-homology of the chain complex, \\(H_1(\\partial, \\mathbb{Z}_2) = \\frac{\\text{Ker}(\\partial_1)}{\\text{Im}(\\partial_2)}\\).\n\nThe distance of the CSS code is equal to the minimum of the combinatorial (\\(d-1\\))-systole of the cellulated \\(d\\)-dimensional manifold and its dual.\n","features":{"rate":"For a depolarizing channel with probability \\(p\\), CSS codes allowing for arbitrarily accurate recovery exist with asymptotic rate \\(1-2h(p)\\), where \\(h\\) is the binary entropy function \\cite{arxiv:quant-ph/0110143}.","encoders":["Stabilizer measurement \\cite{arxiv:1404.2495}.","Clusterization, i.e., measurement of a particular cluster state \\cite{arxiv:1607.02579}."],"transversal_gates":"All CSS codes admit transversal Pauli and CNOT gates. Self-dual CSS codes admit a transversal Hadamard, completing the Clifford group. A CSS code is \\textit{doubly-even} (\\textit{triply-even}) if all \\(X\\)-type stabilizer generators have weight divisible by two (three); such codes yield a transversal \\(S\\) (\\(T\\)) gate \\cite{arxiv:1509.03239}.","general_gates":["LDPC CSS code symmetries called \\(XZ\\)-dualities allow for fold-transversal gates, i.e., transversal gates followed by qubit permutations \\cite{arxiv:2202.06647}.","Generalized lattice surgery \\cite{arxiv:2301.13738}."],"fault_tolerance":["Steane error correction \\cite{arXiv:quant-ph/9611027}.","Homomorphic gadgets fault-tolerant measurement unify Steane and Shor error correction \\cite{arxiv:2211.03625}.","Parallel syndrome extraction for distance-three codes can be done fault-tolerantly using one flag qubit \\cite{arXiv:2208.00581}."],"code_capacity_threshold":["Bounds on code capacity thresholds for various noise models exist in terms of stabilizer generator weights \\cite{arxiv:1208.2317,arxiv:1412.6172}."],"decoders":["Coherent decoders allow for measurement-free error correction \\cite{arxiv:2109.00086}. One method is table/multi-control decoding \\cite{arXiv:1002.1536}, which scales exponentially with the number of ancillas used in syndrome measurement. Another method, the Ising-based decoder, utilizes the mapping of the effect of the noise to a statistical mechanical model \\cite{arxiv:quant-ph/0110143,arXiv:2002.11733} such that the decoding problem maps to preparation of the ground state of an Ising model.","Decoders based on neural networks \\cite{arxiv:2301.11930}."]},"realizations":["Fully homomorphic encryption \\cite{arxiv:1708.09156}.","Entanglement purification protocols related to quantum key distribution (QKD) \\cite{arxiv:quant-ph/0003004}.","Cryptographic applications stemming from the monogamy of entanglement of CSS code and error words \\cite{arxiv:2107.05692}."],"notes":["See Refs. \\cite{arxiv:quant-ph/9605021,doi:10.1017/CBO9780511976667,preset:PreskillNotes,preset:GottesmanBook} for simple examples.","Introduction to \\ref{topic:CSS-to-homology-correspondence} by \\href{https://www.youtube.com/watch?v=SeLpWg_8qlc}{M. Hastings}.","Using linear programming to solve a set of equations and inequalities on weight distribution of a classical self-orthogonal code \\(C=(n, 2^n-k)\\) and its dual, one can find a \\(C\\) such that the \\([[n,k,d]]\\) CSS code constructed using \\(C\\) and its dual would have rate and distance close to the Singleton bound \\cite{arXiv:quant-ph/9608006}."],"relations":{"parents":[{"code_id":"qubit_stabilizer","detail":"Stabilizer generators can be expressed as either only \\(X\\)-type or only \\(Z\\)-type. However, any \\([[n,k,d]]\\) stabilizer code can be mapped onto a \\([[4n,2k,2d]]\\) self-orthogonal CSS code, with the mapping preserving geometric locality of a code up to a constant factor \\cite{arXiv:1004.3791}."},{"code_id":"movassagh_ouyang","detail":"Movassagh-Ouyang codes stem from a prescription that converts an \\textit{arbitrary} classical code into a quantum code."},{"code_id":"qudit_css","detail":"Modular-qudit CSS codes for \\(q=2\\) are (qubit) CSS codes."},{"code_id":"galois_css","detail":"Galois-qudit CSS codes for \\(q=2\\) are (qubit) CSS codes."}],"cousins":[{"code_id":"binary_linear","detail":"Construction uses two related binary linear codes \\(C_X\\) and \\(C_Z\\)."},{"code_id":"dual","detail":"CSS codes for which \\(C_X=C_Z \\equiv C\\) are called \\textit{self-orthogonal} since \\(C^{\\perp} \\subseteq C\\). The stabilizer group of such codes is invariant under the Hadamard gate exchanging \\(X\\) and \\(Z\\)."},{"code_id":"alternant","detail":"Alternant codes used in the CSS construction yield quantum codes that asymptotically achieve the quantum Gilbert-Varshamov bound \\cite{doi:10.1109/TIT.2022.3201239}."},{"code_id":"quantum_random","detail":"Random CSS codes asymptotically achieve linear distance with high probability, achieving the quantum Gilbert-Varshamov bound \\cite{arxiv:quant-ph/9512032}."},{"code_id":"ag","detail":"Algebraic geometry codes can be plugged into the CSS construction to yield asymptotically good quantum codes \\cite{arxiv:quant-ph/0006061}."}]},"_meta":{"changelog":[{"user_id":"balopat","date":"2023-02-28"},{"user_id":"balopat","date":"2023-02-25"},{"user_id":"VictorVAlbert","date":"2022-09-10"},{"user_id":"VictorVAlbert","date":"2022-05-18"},{"user_id":"ArminGerami","date":"2022-05-16"},{"user_id":"LeonidPryadko","date":"2022-02-16"},{"user_id":"VictorVAlbert","date":"2022-02-16"},{"user_id":"SeyedSajjadNezhadi","date":"2021-12-14"},{"user_id":"VictorVAlbert","date":"2021-11-04"}]},"_zoodb":{"id":"qubit_css","source_file_path":"codes/quantum/qubits/stabilizer/qubit_css.yml","source_file_modification_token":1683723711001.6865}},"qubit_stabilizer":{"code_id":"qubit_stabilizer","physical":"qubits","logical":"qubits","name":"Qubit stabilizer code","introduced":"\\cite{arXiv:quant-ph/9605005,arXiv:quant-ph/9705052}","description":"Also called a \\textit{Pauli stabilizer code}. An \\(((n,2^k,d))\\) qubit stabilizer code is denoted as \\([[n,k]]\\) or \\([[n,k,d]]\\), where \\(d\\) is the code's distance. Logical subspace is the joint eigenspace of commuting Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace of a set of \\(2^{n-k}\\) commuting Pauli operators which do not contain \\(-I\\). The distance is the minimum weight of a Pauli string that implements a nontrivial logical operation in the code.\n\n\\begin{defterm}{Binary symplectic representation}\n\\label{topic:binary-symplectic-representation}\nEach stabilizer code can be represented by a \\((n-k) \\times 2n\\) \\textit{check matrix} (a.k.a. \\textit{stabilizer generator matrix}) \\(H=(A|B)\\), where each row \\((a|b)\\) is the binary symplectic representation of an element from a set of generating elements of the stabilizer group.\nIn the symplectic representation, the single-qubit identity, \\(X\\), \\(Y\\), or \\(Z\\) Pauli matrices represented using two bits as \\((0|0)\\), \\((1|0)\\), \\((1|1)\\), and \\((0|1)\\), respectively.\nThe check matrix can be brought into standard form via Gaussian elimination \\cite{doi:10.1017/CBO9780511976667}.\n\\end{defterm}\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of \\(n\\)-qubit stabilizers with symplectic representations \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their symplectic inner product is zero,\n\\begin{align}\n  a \\cdot b^{\\prime} + a^{\\prime}\\cdot b = \\sum_{j=1}^{n} a_j b^{\\prime}_j + a^{\\prime}_i b_i = 0~.\n\\end{align}\nBinary symplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(2)^{2n}\\) with respect to the symplectic inner product.\n\nAlternative representations include the \\textit{decoupling representation}, in which Pauli strings are represented as vectors over \\(GF(2)\\) using three bits \\cite{arxiv:2305.17505}, or the representation over \\(GF(4)\\) (see stabilizer codes over \\(GF(4)\\)).\n","protection":"Detects errors on up to \\(d-1\\) qubits, and corrects erasure errors on up to \\(d-1\\) qubits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all Pauli operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).\n\nA stabilizer code is \\textit{geometrically local} if the support of the stabilizer generators is bounded by a ball of size independent of \\(n\\).\n","features":{"encoders":["Clifford circuits, i.e., those consisting of CNOT, Hadamard, and certain phase gates, using an algorithm based on the Gottesman-Knill theorem \\cite{arXiv:quant-ph/0406196} or using ZX calculus \\cite{doi:10.1007/978-3-540-70583-3_25,arxiv:0906.4725} \\cite{arxiv:2301.02356}.","Circuits obtained by first constructing the CWS form of the code \\cite{arXiv:0803.3232,arXiv:0708.1021}. These consist of \\(n\\) Hadamard gates, a classical encoder which takes at most \\(n\\) CX gates for a single-qubit encoding code, and at most \\(n(n-1)/2\\) CZ gates to create the needed graph state.","Lindbladian-based dissipative encoding \\cite{arxiv:quant-ph/9707049,arXiv:1310.1036}, for which codespace is steady-state space of a Lindbladian. This does not give a speedup, in terms of scaling with \\(n\\), over circuit-based encoders \\cite{arxiv:1310.1037}."],"transversal_gates":"All stabilizer codes realize Pauli transformations transversally; for a single logical qubit, these a realize dicyclic subgroup of \\(SU(2)\\). More generally, transversal logical gates are in a finite level of the Clifford hierarchy, which is shown using stabilizer \\textit{disjointness} \\cite{arxiv:1710.07256} (see also \\cite{arxiv:0706.1382,arxiv:1409.8320}). Transversal gates for \\(n\\in\\{1,2\\}\\) are semi-Clifford \\cite{arxiv:0712.2084}.","general_gates":["With pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates \\cite{arXiv:1603.03948}."],"decoders":["The structure of stabilizer codes allows for \\textit{syndrome-based decoding}, where errors are corrected based on the results of stabilizer measurements (\\textit{syndromes}). The size of the circuit extracting the syndrome depends on the weight of its corresponding stabilizer generator. \\textit{Maximum-likelihood} (ML) decoding, i.e., the process of finding the most likely error, is \\(NP\\)-complete in general \\cite{arxiv:1009.1319,manual:{Kuo, Kao-Yueh, and Chung-Chin Lu. \"On the hardness of decoding quantum stabilizer codes under the depolarizing channel.\" 2012 International Symposium on Information Theory and its Applications. IEEE, 2012.}}. If the noise model is such that the most likely error is the lowest-weight error, then ML decoding is called \\textit{minimum-weight} decoding. \\textit{Degenerate maximum-likelihood} decoding, i.e., the process of finding the most likely error class (up to degeneracy of errors), is \\(\\#P\\)-complete in general \\cite{arxiv:1310.3235}.","Trellis decoder, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) \\cite{arXiv:quant-ph/0512041}.","Quantum extension of GRAND decoder \\cite{arxiv:2208.02744}.","Deep neural-network probabilistic decoder \\cite{arxiv:1705.09334}.","Generalized belief propagation (GBP) \\cite{arxiv:2212.03214} based on a classical version \\cite{manual:{J. S. Yedidia, W. T. Freeman, and Y. Weiss, Generalized belief propagation, in NIPS, Vol. 13 (2000) pp. 689–695.}}."],"fault_tolerance":["Logical Bell measurements can be done transversally, and thus fault tolerantly, by performing bitwise Bell measurements for each pair of qubits (with each member of the pair taken from one of the two code blocks) and processing the result.","With pieceable fault-tolerance, any nondegenerate stabilizer code with a complete set of fault-tolerant single-qubit Clifford gates has a universal set of non-transversal fault-tolerant gates \\cite{arXiv:1603.03948}.","Fault-tolerant error correction scheme by Shor \\cite{arXiv:quant-ph/9605011}, which is based on repeated measurements. A modification uses adaptive measurements \\cite{arxiv:2208.05601}.","Generalization of Steane error correction stabilizer codes \\cite[Sec. 3.6]{manual:{Yoder, Theodore., \\emph{DSpace@MIT} Practical Fault-Tolerant Quantum Computation (2018)}}.","Fault-tolerant error correction scheme by Knill (a.k.a. telecorrection \\cite{arxiv:quant-ph/0601066}), which is based on teleportation \\cite{arxiv:quant-ph/0410199,arXiv:quant-ph/0312190}.","GHz state distillation for Steane error correction \\cite{arxiv:2109.06248}.","Syndrome extraction using flag qubits and classical codes \\cite{arxiv:2212.10738}."],"code_capacity_threshold":["Bounds on code capacity thresholds using maximum-likelihood (ML) decoding can be obtained by mapping the effect of noise on the code to a statistical mechanical model \\cite{arxiv:quant-ph/0110143,arXiv:1208.2317,arXiv:1311.7688,arXiv:1809.10704}."],"threshold":["Computational thresholds against stochastic local noise can be achieved through repeated use of concatenatenation, and can rely on the same small code in every level \\cite{arxiv:quant-ph/9702058,arxiv:quant-ph/9906129,arXiv:quant-ph/9705031,arXiv:quant-ph/0504218}. The resulting code is highly degenerate, with all but an exponentially small fraction of generators having small weights. Circuit and measurement designs have to take case of the few stabilizer generators with large weights in order to be fault tolerant."]},"notes":["Introductions to stabilizer codes can be found in \\cite{arXiv:quant-ph/9705052,preset:PreskillNotes,doi:10.1002/9783527618637.ch1}.","Tables of bounds and examples of stabilizer codes for various \\(n\\) and \\(k\\), based on algorithms developed in Ref. \\cite{doi:10.1007/978-3-540-37634-7_13}, are maintained by M. Grassl at this \\href{http://codetables.markus-grassl.de/}{website}.","Stabilizer error-recovery circuits can be simulated efficiently using dedicated software (e.g., STIM \\cite{arxiv:2103.02202}).","There is a correspondence between stabilizer codes and bilocal Clifford entanglement distillation circuits \\cite{arxiv:2303.11465}."],"relations":{"parents":[{"code_id":"cws","detail":"If the CWS set \\( \\mathcal{W} \\) is an abelian group not containing \\(-I\\), then the CWS code is a stabilizer code."},{"code_id":"xp_stabilizer","detail":"The XP stabilizer formalism reduces to the Pauli formalism at \\(N=2\\)."},{"code_id":"qudit_stabilizer","detail":"Modular-qudit stabilizer codes for \\(q=2\\) correspond to qubit stabilizer codes. Modular-qudit stabilizer codes for prime-dimensional qudits \\(q=p\\) inherit most of the features of qubit stabilizer codes, including encoding an integer number of qudits and a Pauli group with a unique number of generators. Conversely, qubit codes can be extended to modular-qudit codes by decorating appropriate generators with powers. For example, \\([[4,2,2]]\\) qubit code generators can be adjusted to \\(ZZZZ\\) and \\(XX^{-1} XX^{-1}\\). A systematic procedure extending a qubit code to prime-qudit codes involves putting its generator matrix into local-dimension-invariant (LDI) form  \\cite{arxiv:1910.08122}. Various bounds exist on the distance of the resulting codes \\cite{arxiv:2110.11510,arxiv:2110.15274}."},{"code_id":"galois_stabilizer","detail":"Galois-qudit stabilizer codes for \\(q=2\\) correspond to qubit stabilizer codes."},{"code_id":"qubit_stabilizer_oaqecc"}],"cousins":[{"code_id":"binary_linear","detail":"Qubit stabilizer codes are the closest quantum analogues of binary linear codes because addition modulo two corresponds to multiplication of stabilizers in the quantum case."},{"code_id":"dual","detail":"Binary symplectic representations of stabilizer group elements form a linear code over \\(GF(2)\\) that is self-orthogonal with respect to the symplectic inner product \\cite[Thm. 27.3.6]{preset:HKSquantum}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-28"},{"user_id":"VictorVAlbert","date":"2022-05-19"},{"user_id":"VictorVAlbert","date":"2022-02-16"},{"user_id":"QingfengKeeWang","date":"2021-12-07"},{"user_id":"LaneGGunderman","date":"2022-02-04"},{"user_id":"LeonidPryadko","date":"2021-11-02"},{"user_id":"DanielGottesman","date":"2021-11-02"},{"user_id":"VictorVAlbert","date":"2021-11-02"}]},"_zoodb":{"id":"qubit_stabilizer","source_file_path":"codes/quantum/qubits/stabilizer/qubit_stabilizer.yml","source_file_modification_token":1689550329219.5552}},"stabilizer_over_gf4":{"code_id":"stabilizer_over_gf4","physical":"qubits","logical":"qubits","name":"Stabilizer code over \\(GF(4)\\)","introduced":"\\cite{arXiv:quant-ph/9608006}","description":"An \\([[n,k,d]]\\) stabilizer code constructed from a quaternary classical code using the one-to-one correspondence between the four Pauli matrices \\(\\{I,X,Y,Z\\}\\) and the four elements \\(\\{0,1,\\alpha^2,\\alpha\\}\\) of the quaternary field \\(GF(4)\\).\n\nAn \\(n\\)-qubit Pauli stabilizer can be represented as a length-\\(n\\) quaternary vector. The stabilizer commutation condition corresponds to a zero trace-Hermitian inner product between the corresponding vectors. Stabilizer codes over \\(GF(4)\\) can thus be constructed from classical trace-Hermitian self-orthogonal additive quaternary codes and Hermitian self-orthogonal linear quaternary codes (since the latter are automatically trace-Hermitian self-orthogonal).\nThe classical code corresponds to the stabilizer group \\(\\mathsf{S}\\) while its trace-Hermitian dual corresponds to the normalizer \\(\\mathsf{N(S)}\\).\n\nStabilizer codes over \\(GF(4)\\) can be constructed as follows. Let \\(\\phi\\) be a bijection from a linear binary subspace to \\(GF(4)^n\\). Let \\(C\\) be a trace-Hermitian self-orthogonal additive subcode over \\(GF(4)\\), containing \\(2^{n-k}\\) vectors, such that there are no vectors of weight less than \\(d\\) in \\(C^{\\perp}\\setminus C\\). Then, any eigenspace of the inverse map \\(\\phi^{-1}(C)\\) is an \\([[n, k, d]]\\) stabilizer code over \\(GF(4)\\).\n\nQuaternary linear codes are Hermitian self-orthogonal (self-dual) iff they are trace-Hermitian self-orthogonal (self-dual) additive \\cite[Thm. 27.4.1]{preset:HKSquantum} (\\cite[Thm. 9.10.3]{doi:10.1017/CBO9780511807077}).\nIn other words, if the underlying quaternary code is linear, then the extra trace operation can be removed from the definition of inner product.\n","features":{"fault_tolerance":["Characterizing fault-tolerant multi-qubit gates may involve characterizing all global automorphisms of some number of copies of a code that preserve the symplectic inner product \\cite[pg. 9]{arxiv:quant-ph/9703048}."]},"protection":"Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.","notes":["Tables of \\([[n,0,d]]\\) codes, corresponding to a self-dual \\(GF(4)\\) representation, at \\href{http://www.ii.uib.no/~larsed/vncorbits/}{this website}."],"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"stabilizer_over_gfqsq","detail":"Stabilizer codes over \\(GF(q^2)\\) for \\(q=2\\) are stabilizer codes over \\(GF(4)\\)."}],"cousins":[{"code_id":"dual_additive","detail":"The stabilizer commutation condition for stabilizer codes over \\(GF(4)\\) can equivalently be stated in the representation of stabilizers as quaternary vectors. A pair of \\(n\\)-qubit stabilizers commute iff the trace-Hermitian inner product of their corresponding vectors is zero. Stabilizer codes over \\(GF(4)\\) can thus be constructed from trace-Hermitian self-orthogonal additive quaternary codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-21"},{"user_id":"MariannaPodzorova","date":"2021-12-13"}]},"_zoodb":{"id":"stabilizer_over_gf4","source_file_path":"codes/quantum/qubits/stabilizer/stabilizer_over_gf4.yml","source_file_modification_token":1682420107453.2607}},"color":{"code_id":"color","physical":"qubits","logical":"qubits","name":"Color code","introduced":"\\cite{arxiv:quant-ph/0605138}","description":"A family of abelian topological \\hyperref[code:css]{CSS stabilizer} codes defined on a \\(D\\)-dimensional lattice which satisfies two properties: The lattice is (1) a homogeneous simplicial \\(D\\)-complex obtained as a triangulation of the interior of a \\(D\\)-simplex and (2) is \\(D+1\\)-colorable. Qubits are placed on the \\(D\\)-simplices and generators are supported on suitable simplices \\cite{doi:10.7907/059V-MG69}. For 2-dimensional color code, the lattice must be such that it is 3-valent and has 3-colorable faces, such as a honeycomb lattice. The qubits are placed on the vertices and two stabilizer generators are placed on each face \\cite{arXiv:1311.0277}.","protection":"As with the surface code, the code distance depends on the specific kind of lattice used to define the code. More precisely, the distance depends on the homology of logical string operators \\cite{arXiv:1311.0277}.","features":{"rate":"For general 2D manifolds, \\(kd^2 \\leq c(\\log k)^2 n\\) for some constant \\(c\\) \\cite{arXiv:1301.6588}, meaning that color codes with finite rate can only achieve an asymptotic minimum distance that is logarithmic in \\(n\\).","transversal_gates":"Transversal CNOT can be implemented via braiding \\cite{arXiv:0806.4827}. Universal transversal gates can be achieved in 3D color code using gauge fixing \\cite{arxiv:1311.0879}, lattice surgery \\cite{arXiv:1407.5103}, or code deformation \\cite{doi:10.1088/1367-2630/13/4/043005,arXiv:0806.4827}.","general_gates":["Magic-state distillation protocols \\cite{doi:10.7907/059V-MG69}.","Non-clifford gates can be implemented via code switching \\cite{doi:10.7907/059V-MG69}.","Lattice surgery scheme for 2D layout yields lower resource overhead when compared to analogous surface code scheme \\cite{arXiv:2201.07806}."],"decoders":["Projection decoder \\cite{doi:10.7907/059V-MG69}.","Matching decoder gives low logical failure rate \\cite{arXiv:2108.11395}.","Integer-program-based decoder \\cite{arXiv:1402.3037}.","Restriction decoder \\cite{doi:10.1088/1367-2630/ab68fd}.","Cellular-automaton decoder for the \\(XYZ\\) color code \\cite{arxiv:2203.16534}.","MaxSAT-based decoder \\cite{arxiv:2303.14237}."],"fault_tolerance":["Clifford gates can be performed fault-tolerantly on a suitable 2D lattice \\cite{arxiv:quant-ph/0605138}.","Steane's ancilla-coupled measurement method \\cite{arXiv:1407.5103}","Gauge fixing can be used to switch between 2D and 3D color codes, thereby yielding fault-tolerant with constant time overhead using only local quantum operations \\cite{arxiv:1412.5079}."],"code_capacity_threshold":["\\(12.6\\%\\) threshold for triangular color code with the restriction decoder \\cite{arXiv:1911.00355}.","\\(12.6\\%\\) threshold for triangular color code with the projection decoder (\\cite{arXiv:1308.6207}) \\cite{arXiv:1802.08680}","\\(8.7\\%\\) threshold for phase errors for the hexagonal color code with the projection decoder \\cite{arXiv:1308.6207}","\\(\\geq 6\\%\\) threshold with rescaling-based decoder \\cite{arXiv:2112.09584}."],"threshold":["\\(\\geq 6.25\\%\\) threshold for 2D color codes with error-free syndrome extraction, and \\(0.1\\%\\) with faulty syndrome extraction \\cite{arXiv:0907.1708}.","\\(0.46\\%\\) for 3D codes with clustering decoder \\cite{arXiv:1708.07131}.","\\(1.9\\%\\) for 1D string-like logical operators and \\(27.6\\%\\) for 2D sheet-like operators for 3D codes with noise models using optimal decoding and perfect measurements \\cite{arXiv:1708.07131}.","\\(0.31\\%\\) noise threshold error rate for gauge code using clustering decoder \\cite{arXiv:1503.08217}.","\\(0.2\\%\\) with depolarizing circuit-level noise using two flag-qubits per stabilizer generator and the restriction decoder \\cite{arXiv:1911.00355}.","\\(0.143\\%\\) with depolarizing circuit-level noise using perfect-matching decoder \\cite{arXiv:1407.5103}.","\\(>0\\%\\) threshold with sweep decoder \\cite{doi:10.7907/059V-MG69}."]},"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"generalized_color","detail":"The generalized color code for \\(G=\\mathbb{Z}_2\\) reduces to the color code."},{"code_id":"quantum_double_abelian","detail":"When treated as ground states of the code Hamiltonian, color code states on realize \\(\\mathbb{Z}_2\\times\\mathbb{Z}_2\\) topological order \\cite{arxiv:0906.4127}, equivalent to the phase realized by two copies of the surface code \\cite{arxiv:1503.02065}."}],"cousins":[{"code_id":"galois_topological","detail":"The 2D color code has been extended to Galois qudits."},{"code_id":"surface","detail":"The 3D color code is equivalent to multiple decoupled copies of the 2D surface code \\cite{arxiv:1007.4601,arxiv:1503.02065,arXiv:1804.00866}. Conversely, the 2D color code can \\hyperref[topic:code-switching]{condense} to form the 2D surface code in nine different ways, i.e., by adding two body hopping terms along one of its three hexagonal directions to the stabilizer group and then taking the center of the resulting nonabelian group \\cite{arxiv:2212.00042}."},{"code_id":"higher_dimensional_surface","detail":"The color code on a \\(D\\)-dimensional closed manifold is equivalent to multiple decoupled copies of the \\(D-1\\)-dimensional surface code \\cite{arxiv:1007.4601,arxiv:1503.02065,arXiv:1804.00866}."},{"code_id":"quantum_triorthogonal","detail":"The 3D color code is triorthogonal."},{"code_id":"hexagonal","detail":"The 2D color code is defined on a trivalent lattice such as the honeycomb lattice."}]},"_meta":{"changelog":[{"user_id":"balopat","date":"2023-01-11"},{"user_id":"VictorVAlbert","date":"2022-01-05"},{"user_id":"XiaozhenFu","date":"2021-12-12"}]},"_zoodb":{"id":"color","source_file_path":"codes/quantum/qubits/stabilizer/topological/color.yml","source_file_modification_token":1687727505574.8386}},"quantum_convolutional":{"code_id":"quantum_convolutional","physical":"qubits","logical":"qubits","name":"Quantum convolutional code","introduced":"\\cite{arxiv:quant-ph/0304189,arxiv:quant-ph/0401134}","description":"One-dimensional translationally invariant qubit stabilizer code whose whose stabilizer group can be partitioned into constant-size subsets of constant support and of constant overlap between neighboring sets.\nInitially formulated as a quantum analogue of convolutional codes, which were designed to protect a continuous and never-ending stream of information.\nPrecise formulations sometimes begin with a finite-dimensional lattice, with the intent to take the thermodynamic limit; logical dimension can be infinite as well.\n\nQuantum convolutional codes, like their classical counterparts, can also be understood in terms of frames. Let each encoding frame take in \\(n\\) qubits, carry \\(m\\) qubits of information between frames, and act on them with \\(n-k\\) Pauli generators. Each generator, countably infinite in length, must commute with each \\(n\\) register shift of itself, but need not commute with the other generators \\cite{arxiv:quant-ph/0703182}. The \\(m\\) qubits of information carried between each frame are also stabilized by additional memory Pauli operators. It is known that the minimal value for \\(m\\) is given by \\(\\text{dim}(M)-\\frac{1}{2}\\text{rank}(M)\\), with \\(M\\) being the matrix containing the required commutation relations of the memory qubits \\cite{arxiv:1105.0649,arxiv:1011.5535,arxiv:0804.1404}. These operators can be efficiently determined \\cite{arxiv:2206.13040}.","features":{"encoders":["Encoding is efficient and uses only Clifford gates. Some encoders yield \\textit{catastrophic} errors, i.e., errors that require a circuit of infinite depth to correct \\cite[Def. 4.1]{arxiv:quant-ph/0401134}."],"decoders":["ML decoder \\cite{arxiv:quant-ph/0304189}."]},"notes":["See Refs. \\cite{arxiv:quant-ph/0304189,arxiv:quant-ph/0511016,arxiv:quant-ph/0602129,arxiv:quant-ph/0703181} for explicit and simple examples.","See Ref. \\cite{doi:10.1017/CBO9781139034807.011} for an introduction to quantum convolutional codes."],"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"translationally_invariant_stabilizer","detail":"Quantum convolutional codes are translationally-invariant stabilizer codes on an semi-infinite or infinite lattice in one dimension \\cite{arxiv:1305.6973}. Some notions may be extendable to non-stabilizer codes \\cite[Sec. 4]{arxiv:quant-ph/0401134}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-04"},{"user_id":"LaneGGunderman","date":"2023-01-04"}]},"_zoodb":{"id":"quantum_convolutional","source_file_path":"codes/quantum/qubits/stabilizer/topological/convolutional/quantum_convolutional.yml","source_file_modification_token":1681484685086.2957}},"stab_5_1_2_convolutional":{"code_id":"stab_5_1_2_convolutional","physical":"qubits","logical":"qubits","name":"\\((5,1,2)\\)-convolutional code","introduced":"\\cite{arxiv:quant-ph/0304189}","description":"Quantum convolutional code with the stabilizer generators\n\\begin{align}\n  \\begin{array}{cccccccc}\n  X & Z & I & I & I & I & I & \\cdots\\\\\n  Z & X & X & Z & I & I & I & \\cdots\\\\\n  I & Z & X & X & Z & I & I & \\cdots\\\\\n  I & I & Z & X & X & Z & I & \\cdots\\\\\n  \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\ddots\n  \\end{array}\n\\end{align}","relations":{"parents":[{"code_id":"quantum_convolutional"}],"cousins":[{"code_id":"stab_5_1_3","detail":"The \\((5,1,2)\\)-convolutional code is an infinite-qubit version of the five-qubit perfect code, with the former's lattice-translation symmetry being the extension of the latter's cyclic permutation symmetry."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-04"}]},"_zoodb":{"id":"stab_5_1_2_convolutional","source_file_path":"codes/quantum/qubits/stabilizer/topological/convolutional/stab_5_1_2_convolutional.yml","source_file_modification_token":1681484685086.3699}},"haah_cubic":{"code_id":"haah_cubic","physical":"qubits","logical":"qubits","name":"Haah cubic code","introduced":"\\cite{arXiv:1101.1962}","description":"Class of stabilizer codes on a length-\\(L\\) cubic lattice with one or two qubits per site. We also require that the stabilizer group \\(\\mathsf{S}\\) is translation invariant and generated by two types of operators with support on a cube. In the non-CSS case, these two are related by spatial inversion. For CSS codes, we require that the product of all corner operators is the identity. We lastly require that there are no non-trival ''string operators'', meaning that single-site operators are a phase, and any period one logical operator \\(l \\in \\mathsf{S}^{\\perp}\\) is just a phase. Haah showed in his original construction that there is exactly one non-CSS code of this form, and 17 CSS codes \\cite{arXiv:1101.1962}. The non-CSS code is labeled code 0, and the rest are numbered from 1 - 17. Codes 1-4, 7, 8, and 10 do not have string logical operators \\cite{arXiv:1101.1962,arXiv:1908.08049}.\n\nStraightforward generalizations of the above codes exist to modular qudits, oscillators, and rotors \\cite{manual:{J. Haah, Two generalizations of the cubic code model, \\href{https://online.kitp.ucsb.edu/online/qinfo_c17/haah/}{KITP Conference: Frontiers of Quantum Information Physics, UCSB, Santa Barbara, CA.}},arXiv:1709.04460}.\n","protection":"Cubic codes protect against simultaneous independent Pauli errors on different sites (not qubits, since there can be 2 qubits per site). Codes 0-4 are known to have distance \\(d \\ge L\\), meaning they can achieve macroscopic code distance as \\(L\\to\\infty\\).","features":{"threshold":["The encoding rate depends on the code implemented, but code 0 has been shown to have \\(k \\ge L\\) (on a periodic finite cubic lattice of side length \\(L\\). In general we expect the number of logical bits to scale as \\(k \\sim L\\)."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"fracton","detail":"Haah cubic codes are the first examples of Type-II fracton phases \\cite{arxiv:2001.01722}."}],"cousins":[{"code_id":"color","detail":"The color and cubic code families both include 3D codes that do not admit string-like operators."},{"code_id":"higher_dimensional_surface","detail":"The energy of any partial implementation of code 1 is proportional to the boundary length similar to the 4D toric code, which can potentially surpress the effects of thermal errors, but it is currently an open problem."},{"code_id":"lifted_product","detail":"A lifted-product code for the ring \\(R=\\mathbb{F}_2[x,y,z]/(x^L-1,y^L-1,z^L-1)\\) is the cubic code \\cite[Appx. B]{arXiv:2111.03654}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-11"},{"user_id":"SiddharthTaneja","date":"2021-12-19"}]},"_zoodb":{"id":"haah_cubic","source_file_path":"codes/quantum/qubits/stabilizer/topological/fracton/haah_cubic.yml","source_file_modification_token":1681484685086.619}},"xcube":{"code_id":"xcube","physical":"qubits","logical":"qubits","name":"X-cube model code","introduced":"\\cite{arxiv:1603.04442}","description":"A Type-I fracton code supporting a subextensive number of logical qubits.\n","features":{"decoders":["Parallelized matching decoder \\cite{arxiv:1901.08061}."],"code_capacity_threshold":["Independent \\(X,Z\\) noise: \\(\\sim 7.5\\%\\), higher than 3D surface code and color code \\cite{arXiv:2112.05122}."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"fracton"}]},"_meta":{"changelog":[{"user_id":"KeLiu","date":"2023-03-31"},{"user_id":"VictorVAlbert","date":"2023-03-31"}]},"_zoodb":{"id":"xcube","source_file_path":"codes/quantum/qubits/stabilizer/topological/fracton/xcube.yml","source_file_modification_token":1681484685087.3457}},"matching":{"code_id":"matching","physical":"qubits","logical":"qubits","name":"Matching code","introduced":"\\cite{arxiv:1501.07779}","description":"Member of a class of qubit stabilizer codes based on the abelian phase of the Kitaev honeycomb model.","realizations":["Braiding of defects has been demonstrated for a five-qubit version of code \\cite{arxiv:1609.07774}."],"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"quantum_double_abelian","detail":"Matching codes were inspired by the \\(\\mathbb{Z}_2\\) topological order phase of the Kitaev honeycomb model \\cite{arXiv:cond-mat/0506438}."}],"cousins":[{"code_id":"kitaev_honeycomb","detail":"Matching codes were inspired by the \\(\\mathbb{Z}_2\\) topological order phase of the Kitaev honeycomb model \\cite{arXiv:cond-mat/0506438}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-29"}]},"_zoodb":{"id":"matching","source_file_path":"codes/quantum/qubits/stabilizer/topological/matching.yml","source_file_modification_token":1681484685087.5024}},"clifford-deformed_surface":{"code_id":"clifford-deformed_surface","physical":"qubits","logical":"qubits","name":"Clifford-deformed surface code (CDSC)","short_name":"CDSC","introduced":"\\cite{arxiv:2201.07802}","description":"A generally non-CSS derivative of the surface code defined by applying a constant-depth Clifford circuit to the original (CSS) surface code. Unlike the surface code, CDSCs include codes whose thresholds and subthreshold performance are enhanced under noise biased towards dephasing. Examples of CDSCs include the XY code, XZZX code, and random CDSCs.","protection":"As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).","features":{"fault_tolerance":["In order to leverage the benefits of CDSCs into practical universal computation, we have to implement syndrome measurement circuits and fault-tolerant logical gates in a bias-preserving way."],"code_capacity_threshold":["A class of random CDSCs, parametrized by the probabilities \\(\\Pi_{XZ},~ \\Pi_{YZ}\\) of \\(X\\leftrightarrow Z\\) and \\(Y\\leftrightarrow Z\\) Pauli permutations, respectively, has \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.","Certain translation-invariant CDSCs such as the XY code and the XZZX code also have \\(50\\%\\) code capacity threshold at infinite \\(Z\\) bias.","XZZX code and the \\((0.5,\\Pi_{YZ})\\) random CDSCs have a \\(50\\%\\) code capacity threshold for noise infinitely biased towards either Pauli-\\(X\\), \\(Y\\), or \\(Z\\) errors."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"quantum_double_abelian","detail":"When treated as ground states of the code Hamiltonian, surface codewords realize \\(\\mathbb{Z}_2\\) topological order, a topological phase of matter that also exists in \\(\\mathbb{Z}_2\\) lattice gauge theory \\cite{doi:10.1063/1.1665530}. Local Clifford deformations preserve this topological order."}],"cousins":[{"code_id":"dynamic_gen","detail":"To create CDSCs, a dynamical process is applied on top of the surface code."},{"code_id":"quantum_random","detail":"Many useful CDSCs are constructed using random Clifford circuits."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-28"},{"user_id":"AleksanderKubica","date":"2022-09-28"},{"user_id":"LiangJiang","date":"2022-09-28"},{"user_id":"StevenTFlammia","date":"2022-09-28"},{"user_id":"MichaelGullans","date":"2022-09-28"},{"user_id":"VictorVAlbert","date":"2022-01-20"},{"user_id":"ArpitDua","date":"2022-01-19"}]},"_zoodb":{"id":"clifford-deformed_surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/clifford-deformed_surface/clifford-deformed_surface.yml","source_file_modification_token":1681484685093.7668}},"3d_surface":{"code_id":"3d_surface","physical":"qubits","logical":"qubits","name":"3D surface code","introduced":"\\cite{arxiv:quant-ph/0110143,arxiv:cond-mat/0411752}","description":"A variant of the Kitaev surface code on a 3D lattice. The closely related \\textit{solid code} \\cite{arxiv:1406.4227} consists of several 3D surface codes stitched together in a way that the distance scales faster than the linear size of the system.\n","features":{"decoders":["Flip decoder and its modification p-flip \\cite{arxiv:2212.06985}."],"threshold":["Phenomenological noise model for the 3D toric code: \\(2.90(2)\\%\\) under BP-OSD decoder \\cite{arXiv:2009.11790}, \\(7.1\\%\\) under improved BP-OSD \\cite{arxiv:2206.03122}, and \\(2.6\\%\\) under flip decoder \\cite{arXiv:2212.06985}. For 3D surface code: \\(3.08(4)\\%\\) under flip decoder \\cite{arXiv:2009.11790}."]},"relations":{"parents":[{"code_id":"higher_dimensional_surface"},{"code_id":"quantum_double_abelian"}]},"_meta":{"changelog":[{"user_id":"AleksanderKubica","date":"2022-05-16"},{"user_id":"VictorVAlbert","date":"2022-05-16"}]},"_zoodb":{"id":"3d_surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/higher_dim_surface/3d_surface.yml","source_file_modification_token":1681484685093.8528}},"fractal_surface":{"code_id":"fractal_surface","physical":"qubits","logical":"qubits","name":"Fractal surface code","introduced":"\\cite{arXiv:2108.00018,arXiv:2201.03568}","description":"Kitaev surface code on a fractal geometry, which is obtained by removing qubits from the surface code on a cubic lattice. Stub.","relations":{"parents":[{"code_id":"higher_dimensional_surface","detail":"Fractal surface codes are obtained by removing qubits from the surface code on a cubic lattice."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-12"}]},"_zoodb":{"id":"fractal_surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/higher_dim_surface/fractal_surface.yml","source_file_modification_token":1681484685093.9255}},"hemicubic":{"code_id":"hemicubic","physical":"qubits","logical":"qubits","name":"Hemicubic code","introduced":"\\cite{arXiv:1911.03069}","description":"Stub.\n","relations":{"parents":[{"code_id":"higher_dimensional_surface"}],"cousins":[{"code_id":"qltc","detail":"The hypersphere product code family has asymptotically diminishing soundness that scales as order \\(\\Omega(1/\\log n)\\), locality of stabilizer generators scaling as order \\(O(\\log n)\\), and distance \\(\\Theta(\\sqrt{n})\\). Application of the generalized distance balancing scheme \\cite{arxiv:2004.07935} using an asymptotically good classical code of length \\(t\\) yields \\(O(1/(\\log(n) t^2))\\) soundness and \\(\\Theta(\\sqrt{n}t)\\) distance while maintaining locality scaling and at the expense of a dimension scaling as \\(\\Theta(t^2)\\) \\cite{arxiv:2305.00689}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-26"}]},"_zoodb":{"id":"hemicubic","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/higher_dim_surface/hemicubic.yml","source_file_modification_token":1683978912610.0164}},"hypersphere_product":{"code_id":"hypersphere_product","physical":"qubits","logical":"qubits","name":"Hypersphere product code","introduced":"\\cite{arXiv:1608.05089}","description":"Stub.\n","relations":{"parents":[{"code_id":"higher_dimensional_surface"}],"cousins":[{"code_id":"qltc","detail":"The hypersphere product code family has asymptotically diminishing soundness that scales as order \\(O(1/\\log (n)^2)\\), locality of stabilizer generators scaling as order \\(O(\\log n/ \\log\\log n)\\), and distance \\(\\Theta(\\sqrt{n})\\). Application of the generalized distance balancing scheme \\cite{arxiv:2004.07935} using an asymptotically good classical code of length \\(t\\) yields \\(O(1/(\\log(n)^2 t^2))\\) soundness and \\(\\Theta(\\sqrt{n}t)\\) distance while maintaining locality scaling and at the expense of a dimension scaling as \\(\\Theta(t^2)\\) \\cite{arxiv:2305.00689}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-26"}]},"_zoodb":{"id":"hypersphere_product","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/higher_dim_surface/hypersphere_product.yml","source_file_modification_token":1683978912610.109}},"higher_dimensional_surface":{"code_id":"higher_dimensional_surface","physical":"qubits","logical":"qubits","name":"Generalized surface code","introduced":"\\cite{arxiv:quant-ph/0110143,doi:10.1201/9781420035377-13,doi:10.1007/978-3-642-01877-0_21}","description":"Also called the \\(D\\)\\textit{-dimensional surface} or \\(D\\)\\textit{-dimensional toric} code.\nCSS-type extenstion of the Kitaev surface code to arbitrary \\(D\\)-dimensional manifolds.\nThe 4D surface code serves as a self-correcting quantum memory, while surface codes in higher dimensions can have distances not possible in lower dimensions.\n\nGiven a cellulation of a manifold, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers\nare associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\((i+1)\\)-faces.\n","features":{"rate":"Rate depends on the underlying cellulation and manifold \\cite{arXiv:quant-ph/0110143,arXiv:1606.07116}.\nFor general 2D\nmanifolds, \\(kd^2\\leq c(\\log k)^2 n\\) for some constant \\(c\\)\n\\cite{arXiv:1301.6588}, meaning that (1) 2D surface codes with bounded\ngeometry have distance scaling at most as \\(O(\\sqrt{n})\\)\n\\cite{arXiv:0909.5200,doi:10.1063/1.4726034}, and (2) surface codes with\nfinite rate can only achieve an asymptotic minimum distance that is\nlogarithmic in \\(n\\).\nHigher-dimensional manifolds yield distances scaling more favorably.\nLoewner's theorem\nprovides an upper bound for any bounded-geometry surface code\n\\cite{doi:10.1201/9781420035377-13}.\n","decoders":["Improved BP-OSD decoder \\cite{arxiv:2206.03122}."],"threshold":["Phenomenological noise model for the 4D toric code: \\(4.3\\%\\) under improved BP-OSD decoder \\cite{arxiv:2206.03122}."]},"notes":["2D and 3D surface code \\href{http://gui.quantumcodes.io/}{visualization\ntool}.\n"],"relations":{"parents":[{"code_id":"qubit_css"},{"code_id":"generalized_homological_product_css","detail":"The generalized surface code is constructed from chain complexes arising from cell complexes of the underlying manifold. Such complexes are not necessarily products of two non-trivial complexes, but the manifolds are picked so that their homology ensures favorable code properties."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-12"}]},"_zoodb":{"id":"higher_dimensional_surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/higher_dimensional_surface.yml","source_file_modification_token":1681484685094.0962}},"four_dimensional_hyperbolic":{"code_id":"four_dimensional_hyperbolic","physical":"qubits","logical":"qubits","name":"Guth-Lubotzky code","introduced":"\\cite{arXiv:1310.5555}","description":"Hyperbolic surface code based on cellulations of certain four-dimensional manifolds. The manifolds are shown to have good homology and systolic properties for the purposes of code construction, with corresponding codes exhibiting linear rate.\n\nGuth and Lubotzky \\cite{arXiv:1310.5555} show that there exists \\(\\epsilon\\), a four-dimensional hyperbolic manifold \\(M\\), and a sequence of manifolds \\(M_i\\) such that\neach \\(M_i\\) is a finite sheeted \\href{https://en.wikipedia.org/wiki/Covering_space}{covering} of \\(M\\), and the four-dimensional volumes of the manifolds \\(\\text{Vol}_4(M_i)\\) of the sequence tend to infinity.\nAlso, the dimension of the second homology and size of systoles are bounded by \\(H_2(M_i, Z_2) \\geq \\frac{\\text{Vol}_4(M_i)}{100}\\) and \\(\\text{Sys}_2(M_i) \\geq \\text{Vol}_4(M_i)^\\epsilon\\), respectively.\n\nThen given any cellulation of \\(M\\), it can naturally be extended to cellulations for each of the manifolds \\(M_i\\) and used to define CSS codes via the homological construction by choosing the size three chain complex consisting of the \\(3,2\\) and \\(1\\)-cells of the cellulations.\n\nFor dense cellulations (i.e. large \\(n\\)) the number of physical qubits for these codes will scale with the volume of the manifolds.\nTherefore, bounds on the dimension of the second homology and size of systoles are achieved in terms of \\(n\\) for large \\(n\\).\n","protection":"Protection stems from the relationship between properties of manifolds and CSS codes derived from their cellulation. The number of physical \\(k\\) qubits and distance \\(d\\) of the code will scale as \\(\\Omega(n)\\) and \\(\\Omega(n^\\epsilon)\\), respectively.","relations":{"parents":[{"code_id":"hyperbolic_surface"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-29"},{"user_id":"SeyedSajjadNezhadi","date":"2021-12-15"}]},"_zoodb":{"id":"four_dimensional_hyperbolic","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/hyperbolic/four_dimensional_hyperbolic.yml","source_file_modification_token":1681484685094.1814}},"freedman_meyer_luo":{"code_id":"freedman_meyer_luo","physical":"qubits","logical":"qubits","name":"Freedman-Meyer-Luo code","introduced":"\\cite{doi:10.1201/9781420035377-13}","description":"Hyperbolic surface code constructed using cellulation of a Riemannian Manifold \\(M\\) exhibiting systolic freedom \\cite{doi:10.2140/gtm.1999.2.113}. Codes derived from such manifolds can achieve distances scaling better than \\(\\sqrt{n}\\), something that is impossible using closed 2D surfaces or 2D surfaces with boundaries \\cite{doi:10.1063/1.4726034}. Improved codes are obtained by studying a weak family of Riemann metrics on closed 4-dimensional manifolds \\(S^2\\otimes S^2\\) with the \\(Z_2\\)-homology.\n","protection":"Four-dimensional manifolds with weak systolic freedom yield \\([[n,2,\\Omega(\\sqrt{n \\sqrt{\\log n}})]]\\) surface codes.","features":{"rate":"Codes held a 20-year record the best lower bound on asymptotic scaling of the minimum code distance, \\(d=\\Omega(\\sqrt{n \\sqrt{\\log n}})\\), broken by Ramanujan tensor-product codes."},"notes":["See thesis by Fetaya for pedagogical exposition \\cite{arxiv:1108.2886}."],"relations":{"parents":[{"code_id":"hyperbolic_surface"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-03"},{"user_id":"XinyuanZheng","date":"2021-12-18"}]},"_zoodb":{"id":"freedman_meyer_luo","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/hyperbolic/freedman_meyer_luo.yml","source_file_modification_token":1681484685094.2456}},"golden_code":{"code_id":"golden_code","physical":"qubits","logical":"qubits","name":"Golden code","introduced":"\\cite{arXiv:1712.08578}","description":"Variant of the Guth-Lubotzky hyperbolic surface code that uses regular tessellations for 4-dimensional hyperbolic space.\n","protection":"Nonvanishing rate and asymptotic distance lower bounded by \\(n^0.1\\).","relations":{"parents":[{"code_id":"four_dimensional_hyperbolic"}]},"_meta":{"changelog":[{"user_id":"MicahShaw","date":"2022-08-03"}]},"_zoodb":{"id":"golden_code","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/hyperbolic/golden.yml","source_file_modification_token":1681484685094.3054}},"hyperbolic_surface":{"code_id":"hyperbolic_surface","physical":"qubits","logical":"qubits","name":"Hyperbolic surface code","description":"An extension of the Kitaev surface code construction to hyperbolic manifolds.\nGiven a cellulation of a manifold, qubits are put on \\(i\\)-dimensional faces, \\(X\\)-type stabilizers are associated with \\((i-1)\\)-faces, while \\(Z\\)-type stabilizers are associated with \\(i+1\\)-faces.\n","protection":"Constructions (see code children below) have yielded distances scaling favorably with the number of qubits. The use of hyperbolic surfaces allows one to circumvent bounds on surface code parameters that are valid for surfaces with bounded geometry.","relations":{"parents":[{"code_id":"higher_dimensional_surface"}],"cousins":[{"code_id":"holographic","detail":"Both holographic and hyperbolic surface codes utilize tesselations of hyperbolic surfaces. Encodings for the former are hyperbolically tiled tensor networks, while the latter is defined on hyperbolically tiled physical-qubit lattices."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-07"}]},"_zoodb":{"id":"hyperbolic_surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/hyperbolic/hyperbolic_surface.yml","source_file_modification_token":1681484685094.362}},"real_projective_plane":{"code_id":"real_projective_plane","physical":"qubits","logical":"qubits","name":"Projective-plane surface code","introduced":"\\cite{arXiv:quant-ph/9810055}","description":"A family of Kitaev surface codes on the non-orientable 2-dimensional compact manifold \\(\\mathbb{R}P^2\\) (in contrast to a genus-\\(g\\) surface). Whereas genus-\\(g\\) surface codes require \\(2g\\) logical qubits, qubit codes on \\(\\mathbb{R}P^2\\) are made from a single logical qubit.","protection":"If \\(\\mathcal{C}\\) is a cellulation of \\(\\mathbb{R}P^2\\), then the bit-flip distance \\(d_X\\) is the shortest cycle in \\(\\mathcal{C}\\), and the phase-flip distance \\(d_Z\\) is the shortest cycle in the dual cellulation \\(\\mathcal{C}^*\\).","features":{"rate":"The rate is \\(1/n\\), where \\(n\\) is the number of edges of the particular cellulation."},"relations":{"parents":[{"code_id":"higher_dimensional_surface"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"EricKubischta","date":"2021-12-15"}]},"_zoodb":{"id":"real_projective_plane","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/real_projective_plane.yml","source_file_modification_token":1681484685094.4395}},"rotated_surface":{"code_id":"rotated_surface","physical":"qubits","logical":"qubits","name":"Rotated surface code","introduced":"\\cite{arxiv:quant-ph/0703272,arXiv:1107.3502,arXiv:1202.0928,arXiv:1404.3747}","description":"Also called a \\textit{checkerboard code}. CSS variant of the surface code defined on a square lattice that has been rotated 45 degrees such that qubits are on vertices, and both \\(X\\)- and \\(Z\\)-type check operators occupy plaquettes in an alternating checkerboard pattern.","protection":"The \\([[L^2,1,L]]\\) variant \\cite{arXiv:quant-ph/0703272} includes the \\([[9,1,3]]\\) \\hyperref[code:surface-17]{surface-17} code, named as such because 8 ancilla qubits are used for check operator measurements alongside the 9 physical qubits.","features":{"decoders":["Local neural-network using 3D convolutions, combined with a separate global decoder \\cite{arxiv:2208.01178}."],"fault_tolerance":["A particular choice of CNOT gates during syndrome extraction is required to be fault-tolerant to syndrome qubit errors \\cite{arXiv:quant-ph/0110143,arXiv:1208.0928,arXiv:1404.3747}."]},"relations":{"parents":[{"code_id":"surface","detail":"Rotated surface codes can be obtained using the same procedure as for the original surface codes but considering slightly different combinatorial surfaces \\cite{arXiv:quant-ph/0703272,arXiv:1606.07116} than those considered in the original proposal."},{"code_id":"quantum_tanner","detail":"Specializing the quantum Tanner construction to the surface code yields the rotated surface code \\cite{manual:{Nikolas P. Breuckmann, private communication, 2022},manual:{Anthony Leverrier, \\href{https://github.com/errorcorrectionzoo/eczoo_data/files/9210173/rotated.pdf}{Mapping the toric code to the rotated toric code}, 2022.}}."},{"code_id":"hierarchical","detail":"Hierarchical code is a concatenation of a constant-rate QLDPC code with a rotated surface code."}],"cousins":[{"code_id":"hypergraph_product","detail":"Rotated code can be obtained from hypergraph product of two cyclic binary cyclic codes with palindromic generator polynomial (\\cite{arxiv:1202.0928}, Ex. 7)."},{"code_id":"heavy_hex","detail":"A rotated surface code can be mapped onto a heavy square lattice, resulting in a code similar to the heavy-hexagon code \\cite{arxiv:1907.09528}."}]},"_meta":{"changelog":[{"user_id":"MarcusPS","date":"2023-03-20"},{"user_id":"VictorVAlbert","date":"2022-07-30"}]},"_zoodb":{"id":"rotated_surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/rotated_surface.yml","source_file_modification_token":1681484685094.4976}},"stellated_dodecahedron_css":{"code_id":"stellated_dodecahedron_css","physical":"qubits","logical":"qubits","name":"Bring's code","introduced":"\\cite{arXiv:1712.07666}","description":"Also called a \\textit{small stellated dodecahedron code}. A \\([[30,8,3]]\\) hyperbolic surface code on a quotient of the \\(\\{5,5\\}\\) hyperbolic tiling called Bring's curve.\nIts qubits and stabilizer generators lie on the vertices of the small stellated dodecahedron. Admits a set of weight-five stabilizer generators.\n","relations":{"parents":[{"code_id":"two_dimensional_hyperbolic_surface"},{"code_id":"small_distance"}],"cousins":[{"code_id":"polytope","detail":"The stellated dodecahedron quantum code and related codes listed in \\cite[Table 1]{arXiv:1712.07666} arranges qubits and stabilizer generators on polytopes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-02-05"}]},"_zoodb":{"id":"stellated_dodecahedron_css","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/stellated_dodecahedron_css.yml","source_file_modification_token":1681484685094.8262}},"surface":{"code_id":"surface","physical":"qubits","logical":"qubits","name":"Kitaev surface code","introduced":"\\cite{doi:10.1070/RM1997v052n06ABEH002155,doi:10.1007/978-1-4615-5923-8_19,arXiv:quant-ph/9707021}\n","alternative_names":["Kitaev toric code"],"description":"A family of abelian topological \\hyperref[code:css]{CSS stabilizer} codes\nwhose generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings\nassociated to the stars and plaquettes, respectively, of a cellulation of a\ntwo-dimensional surface (with a qubit located at each edge of the\ncellulation).\n\\textit{Toric code} often either refers to the construction on\nthe two-dimensional torus or is an alternative name for the general\nconstruction.\nThe construction on surfaces with boundaries is often called the\n\\textit{planar code} \\cite{arXiv:quant-ph/9810055,arXiv:quant-ph/9811052,arXiv:1606.07116}.\nCodewords correspond to ground states of the surface code Hamiltonian, and error operators create or annihilate pairs of anyonic charges or vortices.\n\nThe stabilizers of the surface code on the 2-dimensional torus are generated\nby star operators \\(A_v\\) and plaquette operators \\(B_p\\).  Each star operator\nis a product of four Pauli-\\(X\\) operators on the edges adjacent to a vertex\n\\(v\\) of the lattice; each plaquette operator is a product of four Pauli-\\(Z\\)\noperators applied to the edges adjacent to a face, or plaquette, \\(p\\) of the\nlattice (\\ref{figure:toric-code-operators}).\n\n\\begin{figure}\n  \\includegraphics{toric-code-operators}\n  \\caption{Stabilizer generators and logical operators of the 2D surface\n    code on a torus.  The star operators \\(A_v\\) and the plaquette operators\n    \\(B_p\\) generate the stabilizer group of the toric code.  The logical\n    operators are strings that wrap around the torus.}\n  \\label{figure:toric-code-operators}\n\\end{figure}\n\nThe two-dimensional toric code encodes two logical qubits.  We denote by\n\\(\\overline{X}_i,\\overline{Z}_i\\) the logical Pauli-\\(X\\) and Pauli-\\(Z\\)\noperator of the \\(i\\)-th logical qubit.  They can are represented by strings\nof Pauli-\\(X\\) operators or Pauli-\\(Z\\) operators that wrap around the torus\nas shown in \\ref{figure:toric-code-operators}.\n","protection":"Toric code on an \\(L\\times L\\) torus is a \\([[2L^2,2,L]]\\) CSS code.\nThe original planar code on a square-lattice patch with different boundary conditions on the vertical and horizontal edges is a \\([[L^2+(L-1)^2,1,L]]\\) CSS code \\cite{arXiv:quant-ph/9810055}.\nCode size \\(k = 2^{2g}\\) for a torus of genus \\(g\\), and such higher genus surfaces have been investigated \\cite{arxiv:2307.04418}.\n\nCoherent physical errors are expected to become incoherent logical errors under syndrome measurement; see corroborating numerical studies performed via the Majorana mapping \\cite{arxiv:1710.02270} as well as analytical bounds \\cite{arxiv:1912.04319}.\n","features":{"rate":"Both the planar and toric codes saturate the BPT bound, which states that \\(k d^2 = O(L^2)\\) for codes on a 2D lattice of length \\(O(L)\\).\n","encoders":["A depth-\\(L^2\\) circuit that grows the code out of a small patch on an \\(L\\times L\\) square lattice using CNOT gates (i.e., \"local moves\") \\cite{arxiv:quant-ph/0110143,arxiv:0712.0348}.","Graph-state based adaptive circuit \\cite{arxiv:quant-ph/0703143,arxiv:1105.2111}.","For an \\(L\\times L\\) lattice, deterministic state preparation can be done with a geometrically local unitary \\(O(L)\\)-depth circuit \\cite{arXiv:2002.00362,arxiv:2110.02020} or an \\(O(\\log{L})\\)-depth unitary circuit with non-local two-qubit gates \\cite{arXiv:0712.0348,arxiv:0806.4583,arXiv:1207.0253} (matching lower bounds \\cite{arxiv:quant-ph/0603121,arXiv:1810.03912}).","Lindbladian-based dissipative encoding for the toric code \\cite{arXiv:1310.1036} that does not give a speedup relative to circuit-based encoders \\cite{arxiv:1310.1037}.","Stabilizer measurement-based circuit of linear depth \\cite{arXiv:quant-ph/0110143,arXiv:1404.2495}.","Any geometrically local unitary circuit on a lattice \\(\\Lambda\\) that prepares a state whose energy density with respect to the surface code Hamiltonian is \\(\\epsilon\\) must have depth of order \\(\\Omega(\\min(\\sqrt{|\\Lambda|},1/\\epsilon^{\\frac{1-\\alpha}{2}}))\\) for any \\(\\alpha>0\\) \\cite{arxiv:2210.06796}.","Single-shot state preparation \\cite{arxiv:1904.01502}."],"transversal_gates":"Transversal Pauli gates exist and are based on non-trivial loops on surface.\nTransversal Clifford gates can be done on folded surface codes \\cite{arxiv:1603.02286}.\n","general_gates":["Clifford gates can be implemented via lattice surgery\n\\cite{arXiv:1111.4022,arXiv:1709.02318,arXiv:1808.02892,arXiv:2109.02746},\ntwist-based lattice surgery \\cite{arxiv:2201.05678}, or braiding defects\n\\cite{arxiv:0704.2540,arxiv:1004.1838,arXiv:1104.5047,arXiv:1208.0928,arXiv:1508.04166,arXiv:1609.04673,arXiv:2103.08381}.\n","Non-Clifford gates require magic state distillation\n\\cite{arXiv:1905.06903}, Dehn twists \\cite{arxiv:1806.06078}, or\njust-in-time decoding \\cite{arXiv:1903.11634}.\n","Non-stabilizer surface-code states can be prepared by augmenting the code with a quantum double model \\cite{arxiv:1811.06738}.\n","ZX calculus \\cite{doi:10.1007/978-3-540-70583-3_25,arxiv:0906.4725} can be used to reduce the complexity of surface-code lattice surgery diagrams \\cite{arxiv:1704.08670} and\nto reduce T-gate counts in magic-state distillation protocols \\cite{arxiv:1812.01238,arxiv:1905.08916}.\n"],"fault_tolerance":["Transversal (non-Clifford) CCZ gate by bringing 2D surface codes together and using just-in-time decoding \\cite{arxiv:1903.11634}. Gate can be simulated by taking 2D slices out of 3D surface codes \\cite{arXiv:2012.08536}.","Homomorphic measurement protocols for arbitrary surface codes \\cite{arxiv:2211.03625}.","Non-geometrically local connectivity can reduce overhead cost \\cite{arxiv:2211.15465}.","Fault-tolerant post-selection framework yields magic states with low overhead \\cite{arxiv:2212.00813}.","Framework of fault tolerance utilizing ZX calculus \\cite{doi:10.1007/978-3-540-70583-3_25,arxiv:0906.4725} that is applicable to MBQC, FBQC, and conventional computation versions of the surface code \\cite{arxiv:2303.08829}.","Single-shot state preparation \\cite{arxiv:1904.01502} and MWPM decoding \\cite{arxiv:2209.09774}.","Syndrome extraction circuits consisting of CNOT gates and ancillary measurements \\cite{arxiv:1208.0928}, two-body measurements based on the Majorana mapping \\cite{arxiv:2007.00307,arxiv:2206.12780}. Circuits can be optimized to specific architectures \\cite{arxiv:2302.02192} using spacetime circuit codes and ZX calculus \\cite{doi:10.1007/978-3-540-70583-3_25,arxiv:0906.4725}."],"decoders":["Degenerate maximum-likelihood (ML) \\cite{arxiv:quant-ph/0110143}, which takes time of order \\(O(n^2)\\) under independent \\(X,Z\\) noise for the surface code \\cite{arxiv:1405.4883}.","Minimum weight perfect-matching (MWPM) \\cite{arXiv:quant-ph/0110143,arXiv:1307.1740} (based on work by Edmonds on finding a matching in a graph \\cite{doi:10.4153/CJM-1965-045-4,doi:10.6028/jres.069B.013}), which takes time up to polynomial in \\(n\\) for the surface code. For the case of the surface code, minimum-weight decoding reduces to MWPM \\cite{arxiv:quant-ph/0110143,doi:10.4153/CJM-1965-045-4,doi:10.1088/0305-4470/15/2/033}.","Modified MWPM decoders: pipeline MWPM (accounting for correlations between events) \\cite{arXiv:1310.0863,arXiv:2205.09828}, parity blossom MWPM and fusion blossom MWPM \\cite{arxiv:2305.08307}, and a modification utilizing the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) \\cite{arxiv:2107.13589}.","Belief perfect matching is a combination of belief-propagation and MWPM \\cite{arxiv:2203.04948}.","Renormalization group (RG) \\cite{arXiv:0911.0581,arXiv:1304.6100,arXiv:1411.3028}.","Markov-chain Monte Carlo \\cite{arXiv:1302.2669}.","Tensor network \\cite{arXiv:1405.4883}.","Cellular automaton \\cite{doi:10.7907/AHMQ-EG82,arXiv:1511.05579}.","Neural network \\cite{arXiv:1610.04238,arXiv:1802.06441,arXiv:1810.07207,arxiv:2208.05758} and reinforcement learning \\cite{arxiv:2212.11890}.","Union-find \\cite{arXiv:1709.06218}. A subsequent modification utilizes the continuous signal obtained in the physical implementation of the stabilizer measurement (as opposed to discretizing the signal into a syndrome bit) \\cite{arxiv:2107.13589}. Belief union find is a combination of belief-propagation and union-find \\cite{arxiv:2203.04948}. Strictly local (as opposed to partially local) union find \\cite{arxiv:2305.18534} has a worst-case runtime of order \\(O(d^3)\\) in the distance \\(d\\).","Decoders can be augmented with a pre-decoder \\cite{arXiv:2001.11427,arXiv:2208.04660}, which can allow for some processing to be done inside the cryogenic environment of the quantum system \\cite{arxiv:2208.08547}.","Sliding-window \\cite{arxiv:2209.09219,arxiv:2209.08552} and parallel-window \\cite{arxiv:2209.09219} parallelizable decoders can be combined with many inner decoders, such as MWPM or union-find.","Generalized belief propagation (GBP) \\cite{arxiv:2212.03214} based on a classical version \\cite{manual:{J. S. Yedidia, W. T. Freeman, and Y. Weiss, Generalized belief propagation, in NIPS, Vol. 13 (2000) pp. 689–695.}}. See Ref. \\cite{doi:10.1109/MBITS.2023.3285848} for a review of BP decodes.","Color-code decoder \\cite{arxiv:2306.16476}."],"code_capacity_threshold":["Independent \\(X,Z\\) noise: \\(p_X = 10.31\\%\\) under MWPM decoding \\cite{arxiv:quant-ph/0207088} (see also Ref. \\cite{arxiv:1405.4883}), \\(9.9\\%\\) under BP-OSD decoding \\cite{arxiv:2005.07016}, and \\(8.9\\%\\) under GBP decoding \\cite{arxiv:2212.03214}. The threshold under ML decoding corresponds to the value of critical point of the two-dimensional random-bond Ising model on the Nishimori line \\cite{doi:10.1143/JPSJ.55.3305,arxiv:quant-ph/0110143} (see also \\cite{arxiv:2301.05689}), calculated to be \\(10.94 \\pm 0.02\\%\\) in Ref. \\cite{arXiv:cond-mat/0010143}, \\(10.93(2)\\%\\) in Ref. \\cite{arxiv:cond-mat/0106023}, and estimated to be between \\(10.9\\%\\) and \\(11\\%\\) in Ref. \\cite{arxiv:1405.4883}. Above values are for one type of noise only, and ML threshold for combined \\(X\\) and \\(Z\\) noise is \\(2p_X - p_X^2 \\approx 20.6\\%\\).","Depolarizing noise: between \\(17\\%\\) and \\(18.5\\%\\) under tensor-network decoding \\cite{arxiv:1405.4883}, \\(14\\%\\) under GBP decoding \\cite{arxiv:2212.03214}, \\(16.5\\%\\) under recursive MWPM \\cite{arxiv:2212.11632}, and between \\(15\\%\\) and \\(16\\%\\) under RG \\cite{arXiv:0911.0581}, Markov-chain \\cite{arXiv:1302.2669}, or MWPM \\cite{arXiv:0905.0531} decoding. The threshold under ML decoding corresponds to the value of critical point in the disordered eight-vertex Ising model, calculated to be \\(18.9(3)\\%\\) \\cite{arXiv:1202.1852} (see also APS Physics viewpoint \\cite{doi:10.1103/Physics.5.50}).","Erasure noise: \\(50\\%\\) for square tiling \\cite{arXiv:0904.3556}. There is an inverse relationship between coordination number of the syndrome graph, with the threshold corresponding to a percolation transition \\cite{arxiv:1810.09621}."],"threshold":["\\(1.8\\%\\) for circuit-level depolarizing noise under optimal decoder \\cite{arxiv:1609.06373}. \\(0.57\\%\\) for depolarizing noise on data and syndrome qubits as well initialization, gate, and measurement errors under MPWM decoding \\cite{arxiv:1208.0928}. For this model, a logical qubit with a \\(10^{-14}\\) logical error rate requires between \\(10^3\\) to \\(10^4\\) physical qubits and a target gate fidelity above \\(99.9\\%\\). Later work showed that arbitrarily large computations are possible for a physical error rate of approximately \\(10^{-4}\\) \\cite{arxiv:1206.0800}.","\\(0.35\\%\\) for circuit-level independent \\(X,Z\\) noise under optimal decoder \\cite{arxiv:1609.06373}.","Phenomenological noise: \\(3.3\\%\\) for square tiling \\cite{arXiv:quant-ph/0401101}.","Phenomenological noise model for the 2D toric code: \\(2.93(2)\\%\\) using several rounds of syndrome measurement \\cite{arxiv:quant-ph/0207088}.","\\(0.5-2.9\\%\\) for various noise models \\cite{arxiv:0811.0464} (see also Refs. \\cite{arXiv:quant-ph/0207088,arXiv:1311.5003})."]},"notes":["Hardware requirements for implementing surface code QEC can be reduced by utilizing structure in the time slices of the QEC circuits \\cite{arxiv:2209.06673}.\n","\\textit{Surfmap} framework provides a way to stitch the surface code to various superconducting-circuit geometries by assigning each superconducting qubit to be either a physical or ancilla qubit, designing stabilizer measurement circuits, and scheduling stabilizer measurements \\cite{arxiv:2111.13729}.","Tutorials from error-correction perspective by\n\\href{https://boulderschool.yale.edu/2018/boulder-school-2018-lecture-notes}{J. Haah}\nand condensed-matter perspective by\n\\href{https://boulderschool.yale.edu/2016/boulder-school-2016-lecture-notes}{M. Levin\nand C. Nayak}.\n"],"realizations":["One cycle of syndrome readout on 19-qubit planar and 24-qubit toric codes realized in two-dimensional Rydberg atomic arrays \\cite{arxiv:2112.03923}.\n","Signatures of corresponding topological phase of matter detected in superconducting circuits \\cite{arxiv:2104.01180} and two-dimensional Rydberg atomic arrays \\cite{arXiv:2104.04119}.\n","Ground state of the toric code has been implemented with and without twists, and the non-Abelian braiding behavior of the twists, which realize Ising anyons, has been demonstrated \\cite{arxiv:2211.09802}.\n"],"relations":{"parents":[{"code_id":"higher_dimensional_surface","detail":"The surface-code CSS stabilizer generator prescription is extendable to higher-dimensional manifolds."},{"code_id":"clifford-deformed_surface","detail":"CDSC codes are deformations of the surface code via constant-depth Clifford circuits that may not be CSS."},{"code_id":"hypergraph_product","detail":"Planar (toric) code can be obtained from hypergraph product of two repetition (cyclic) codes \\cite[Ex. 6]{arxiv:1202.0928}."},{"code_id":"lifted_product","detail":"A lifted-product code for the ring \\(R=\\mathbb{F}_2[x,y]/(x^L-1,y^L-1)\\) is the toric code \\cite[Appx. B]{arXiv:2111.03654}."},{"code_id":"qudit_surface","detail":"The modular-qudit surface code for \\(q=2\\) reduces to the surface code."},{"code_id":"galois_topological","detail":"The surface code has been extended to Galois qudits."}],"cousins":[{"code_id":"majorana_stab","detail":"The Majorana mapping can be used to construct efficient algorithms for simulating rounds of error correction for the surface code \\cite{arxiv:1710.02270}."},{"code_id":"quantum_double","detail":"A quantum-double model with \\(G=\\mathbb{Z}_2\\) is the surface code. Non-stabilizer surface-code states can be prepared by augmenting the surface code with a quantum double model \\cite{arxiv:1811.06738}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-29"},{"user_id":"MarcusPS","date":"2023-03-20"},{"user_id":"VictorVAlbert","date":"2022-09-20"},{"user_id":"VictorVAlbert","date":"2022-06-15"},{"user_id":"TonyLau","date":"2022-04-02"},{"user_id":"HassanShapourian","date":"2022-04-01"},{"user_id":"VictorVAlbert","date":"2022-02-15"},{"user_id":"PhilippeFaist","date":"2022-02-11"},{"user_id":"VictorVAlbert","date":"2021-11-05"},{"user_id":"PhilippeFaist","date":"2021-11-03"},{"user_id":"MichaelVasmer","date":"2021-11-02"}]},"_zoodb":{"id":"surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/surface/surface.yml","source_file_modification_token":1689550329219.7432}},"surface-17":{"code_id":"surface-17","physical":"qubits","logical":"qubits","name":"Surface-17 code","introduced":"\\cite{arXiv:1404.3747}","description":"A \\([[9,1,3]]\\) rotated surface code named for the sum of its 9 data qubits and 8 syndrome qubits. It uses the smallest number of qubits to perform error correction on a surface code with parallel syndrome extraction.","protection":"Independent correction of single-qubit \\(X\\) and \\(Z\\) errors. Correction for some two-qubit \\(X\\) and \\(Z\\) errors.","features":{"transversal_gates":"Pauli gates, CNOT gate, and \\(H\\) gate (with relabeling).","decoders":["Lookup table \\cite{arxiv:1404.3747}."]},"notes":["Subject of various numerical studies examining the system for noises and architectures specific to trapped ions \\cite{arXiv:1404.3747,arXiv:1710.01378,arxiv:1910.08495} and superconducting circuits \\cite{arxiv:1612.08208,arxiv:1703.04136,arxiv:2002.07119}"],"realizations":["Implemented at ETH Zurich by the Wallraff group\n\\cite{arxiv:2112.03708} and on the Zuchongzhi 2.1 superconducting quantum processor \\cite{arxiv:2112.13505}.\nBoth experimental error rates are above the pseudothreshold for this code relative to a single qubit; see Physics viewpoint for a summary \\cite{doi:10.1103/Physics.15.103}.\nMagic state have been created on the latter processor \\cite{arxiv:2305.15972}.\n"],"relations":{"parents":[{"code_id":"rotated_surface"}]},"_meta":{"changelog":[{"user_id":"KennethRBrown","date":"2022-06-12"},{"user_id":"VictorVAlbert","date":"2022-06-12"}]},"_zoodb":{"id":"surface-17","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/surface-17.yml","source_file_modification_token":1687727505574.952}},"two_dimensional_hyperbolic_surface":{"code_id":"two_dimensional_hyperbolic_surface","physical":"qubits","logical":"qubits","name":"Two-dimensional hyperbolic surface code","introduced":"\\cite{arXiv:1506.04029}","description":"Hyperbolic surface codes based on a tessellation of a closed 2D manifold with a hyperbolic geometry (i.e., non-Euclidean geometry, e.g., saddle surfaces when defined on a 2D plane).\n\nFor a tessellation involving regular polygons with \\( r \\) sides and \\( s \\) polygons meeting at each edge, the number of logical qubits is given by \\( k = (1-2/r - 2/s) n + 2 \\). Some possible tilings are \\( {r,s}: {7,3}, {5,4} \\). The weight of the stabilizer generators are dependent on the tiling, with \\({5,4}\\) having lower weight than \\({7,3}\\).\n","protection":"Protects against Pauli errors with distance \\( d \\propto \\log(n) \\). Code parameters are \\( [[n, (1-2/r - 2/s)  n + 2, O(\\log n) ]] \\)","features":{"rate":"Two-dimensional hyperbolic surface codes have an asymptotically constant encoding rate \\( k/n \\) with a distance scaling logarithmically with \\( n\\) when the surface is closed. The encoding rate depends on the tiling \\( {r,s} \\) and is given by \\( k/n = (1-2/r - 2/s) + 2/n \\), which approaches a constant value as the number of physical qubits grows. The weight of the stabilizers is \\( r \\) for \\( Z \\)-checks and \\( s \\) for \\( X \\)-checks. For open boundary conditions, the code reduces to constant distnace.","decoders":["Due to the symmetries of hyperbolic surface codes, optimal measurement schedules of the stabilizers can be found \\cite{arXiv:2010.09626}."],"threshold":["1\\(\\%\\) - 5\\(\\%\\) for a \\({5,4}\\) tiling under minimum-weight decoding \\cite{doi:10.1103/PhysRevA.87.020304}. For larger tilings, the lower bound on the distance decreases, suggesting the threshold will also decrease."]},"notes":["See Sec III A of Ref. \\cite{arXiv:2103.06309} for a description of this code.","Connection to percolation theory as shown in \\cite{arXiv:1205.7036}."],"relations":{"parents":[{"code_id":"hyperbolic_surface"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-29"},{"user_id":"ElizabethRBennewitz","date":"2021-12-12"}]},"_zoodb":{"id":"two_dimensional_hyperbolic_surface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/two_dimensional_hyperbolic_surface.yml","source_file_modification_token":1681484685099.36}},"xysurface":{"code_id":"xysurface","physical":"qubits","logical":"qubits","name":"XY surface code","introduced":"\\cite{arxiv:1708.08474}","description":"Also called the \\textit{tailored surface code (TSC)}. Non-CSS derivative of the surface code whose generators are \\(XXXX\\)  and \\(YYYY\\), obtained by mapping \\(Z \\to Y\\) in the surface code.","protection":"As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).","features":{"threshold":["\\(6.32(3)\\%\\) for infinite \\(Z\\) bias, and thresholds of \\(\\sim 5\\%\\) for \\(Z\\) bias around \\(\\eta = 100\\) using a variant of the minimum-weight perfect matching decoder \\cite{arXiv:1907.02554}."],"code_capacity_threshold":["\\(50\\%\\) at infinite \\(Z\\) bias with maximum-likelihood decoder \\cite{arxiv:1812.08186}.","\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder \\cite{arxiv:1812.08186}."]},"relations":{"parents":[{"code_id":"clifford-deformed_surface","detail":"XY code is obtained from the surface code by applying \\(H\\sqrt{Z}H\\) to all qubits, thereby exchaning \\(Z\\leftrightarrow Y\\)."}],"cousins":[{"code_id":"heavy_hex","detail":"XY surface code can be adapted for a heavy-hexagonal lattice \\cite{arxiv:2211.14038}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-20"},{"user_id":"ArpitDua","date":"2022-01-19"}]},"_zoodb":{"id":"xysurface","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/xysurface.yml","source_file_modification_token":1681484685099.4128}},"xzzx":{"code_id":"xzzx","physical":"qubits","logical":"qubits","name":"XZZX surface code","introduced":"\\cite{arxiv:quant-ph/0205004,arXiv:2009.07851,arxiv:1108.5490}","description":"Non-CSS variant of the rotated surface code whose generators are \\(XZXZ\\) Pauli strings associated, clock-wise, to the vertices of each face of a two-dimensional lattice (with a qubit located at each vertex of the tessellation).","protection":"As a stabilizer code, \\([[n=O(d^2), k=O(1), d]]\\).","features":{"threshold":["\\(\\sim 4.5\\%\\) using minimum-weight perfect matching decoder for depolarizing noise (bias \\(\\eta=0.5\\)); \\(\\sim 10\\%\\) for infinite \\(Z\\) bias."],"code_capacity_threshold":["\\(50\\%\\) threshold for noise infinitely biased towards \\(X\\) or \\(Y\\) or \\(Z\\) errors using a maximum-likelihood decoder.","For large but finite \\(X\\)- or \\(Z\\)-biased noise, the code's thresholds exceed the zero-rate hashing bound.  The difference of the threshold from the hashing bound exceeds \\(2.9\\%\\) at a \\(Z\\) or \\(X\\) bias of 300.","\\(18.7\\%\\) for standard depolarising noise with maximum-likelihood decoder.","\\(0.817\\%\\) and \\(0.940\\%\\) with minimum-weight perfect matching and belief-matching decoder, respectively, for biased circuit-level noise \\cite{arxiv:2203.04948}.","\\(4.15\\%\\) when \\(98\\%\\) of depolarizing errors are coverted into erasure errors with union-find decoder on a planar code, vs. \\(0.937\\%\\) for pure depolarizing noise. In Rydberg atomic devices, erasure conversion during gates is promising because the dominant source of noise is spontaneous decay into detectable energy levels outside of the computational subspace \\cite{arxiv:2201.03540}."],"decoders":["Minimum-weight perfect matching decoder, which can be used for \\(X\\) and \\(Z\\) noise. For \\(Y\\) noise, a variant of the matching decoder could be used like it is used for the XY code in Ref. \\cite{arXiv:1907.02554}."]},"realizations":["Distance-five 25-qubit code implemented on a superconducting quantum processor by Google Quantum AI \\cite{arxiv:2207.06431}. This code outperformed the average of several instances of the smaller distance-three 9-qubit \\(XZZX\\) variant of the \\hyperref[code:surface-17]{surface-17} code realized on the same device, both in terms of logical error probability over 25 cycles and in terms of logical error per cycle. This increase in error-correcting capabilities while using more physical qubits supports the notion of an error threshold. Braiding of defects has been demonstrated for the distance-five code \\cite{arxiv:2210.10255}. Leakage errors have been handled in a separate work in a distance-three code \\cite{arxiv:2211.04728}."],"notes":["A single \\(X\\) or \\(Z\\) error gives rise to two nearby defects, which can be viewed as endpoints of a string. That way, multiple \\(Z\\) errors can be decomposed into a combination of diagonal strings.","Originally formulated as an example of \\(\\mathbb{Z}_2\\) topological order in the Wen plaquette model \\cite{arxiv:quant-ph/0205004}."],"relations":{"parents":[{"code_id":"clifford-deformed_surface","detail":"XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\)."}],"cousins":[{"code_id":"rotated_surface","detail":"XZZX code is obtained from the rotated surface code by applying Hadamard gates on a subset of qubits such that \\(XXXX\\) and \\(ZZZZ\\) generators are both mapped to \\(XZXZ\\)."},{"code_id":"fracton","detail":"Subsystem symmetries play a role in finite-bias decoders for both codes \\cite{arXiv:1901.08061}."},{"code_id":"quantum_double_abelian","detail":"Example of \\(\\mathbb{Z}_2\\) topological order as manifest in the Wen plaquette model \\cite{arxiv:quant-ph/0205004}."},{"code_id":"heavy_hex","detail":"XZZX surface code can be adapted for a heavy-hexagonal lattice \\cite{arxiv:2211.14038}."},{"code_id":"cluster_state","detail":"XZZX surface code can be foliated for a noise-bias preserving MBQC \\cite{arxiv:2201.10566} or FBQC \\cite{arxiv:2303.16122} protocol."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-15"},{"user_id":"VictorVAlbert","date":"2022-03-24"},{"user_id":"ArpitDua","date":"2022-01-19"},{"user_id":"MariannaPodzorova","date":"2021-12-13"}]},"_zoodb":{"id":"xzzx","source_file_path":"codes/quantum/qubits/stabilizer/topological/surface/two_dim/xzzx.yml","source_file_modification_token":1681484685099.4854}},"three_fermion":{"code_id":"three_fermion","physical":"qubits","logical":"qubits","name":"Three-fermion (3F) model code","short_name":"3F model","introduced":"\\cite{arxiv:2011.04693}","description":"A 3D topological code whose low-energy excitations realize the three-fermion anyon theory \\cite{arxiv:0712.1377,arxiv:0811.0911,arxiv:1103.4606} and that can be used as a resource state for fault-tolerant MBQC \\cite{arxiv:2011.04693}.\n","features":{"general_gates":["Clifford gates can be performed by braiding and fusing symmetry defects in the MBQC model."],"fault_tolerance":["Fault-tolerant MBQC protocol by encoding in, braiding, and fusing symmetry defects."]},"relations":{"parents":[{"code_id":"qubit_stabilizer"},{"code_id":"walker_wang","detail":"The Walker-Wang model code reduces to the 3F model code when the input category \\(\\mathcal{C}=3F\\) \\cite{arxiv:2011.04693}."},{"code_id":"topological_abelian","detail":"When treated as ground states of the code Hamiltonian, 3F model code states realize 3F topological order, which is chiral and modular."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-03-28"}]},"_zoodb":{"id":"three_fermion","source_file_path":"codes/quantum/qubits/stabilizer/topological/three_fermion.yml","source_file_modification_token":1681484685099.5464}},"xyz_hexagonal":{"code_id":"xyz_hexagonal","physical":"qubits","logical":"qubits","name":"XYZ\\(^2\\) hexagonal stabilizer code","introduced":"\\cite{arxiv:2109.13308,arXiv:2112.06036}","description":"An instance of the matching code based on the Kitaev honeycomb model. It is described on a hexagonal lattice with \\(XYZXYZ\\) stabilizers on each hexagonal plaquette. Each vertical pair of qubits has an \\(XX\\), \\(YY\\), or \\(ZZ\\) link stabilizer depending on the orientation of the plaquette stabilizers.","protection":"As a stabilizer code with boundaries, protects a single qubit with parameters \\([[2 d^2, 1, d]]\\).","features":{"decoders":["Maximum-likelihood decoding using the EWD decoder \\cite{arxiv:2112.01977}."],"code_capacity_threshold":["\\(50\\%\\) for pure \\(Z\\), \\(Y\\), or \\(Z\\) noise under maximum-likelihood decoding.","Threshold matches that of the \\(XZZX\\) code for various bias levels of \\(X\\), \\(Y\\), or \\(Z\\) biased noise  under maximum-likelihood decoding.","\\(\\sim 18\\%\\) for depolarizing noise under maximum-likelihood decoding."]},"notes":["Isolated \\(X\\), \\(Y\\), and \\(Z\\) errors lead to unidirectional pairs of plaquette defects along the three directions of the triangular lattice."],"relations":{"parents":[{"code_id":"matching"}]},"_meta":{"changelog":[{"user_id":"BasudhaSrivastava","date":"2022-03-16"},{"user_id":"VictorVAlbert","date":"2022-03-16"}]},"_zoodb":{"id":"xyz_hexagonal","source_file_path":"codes/quantum/qubits/stabilizer/topological/xyz_hexagonal.yml","source_file_modification_token":1681484685099.6042}},"bacon_shor":{"code_id":"bacon_shor","physical":"qubits","logical":"qubits","name":"Bacon-Shor code","introduced":"\\cite{doi:10.1103/PhysRevA.52.R2493,arxiv:quant-ph/0506023}","description":"CSS subsystem stabilizer code defined on an \\(m_1 \\times m_2\\) lattice of qubits. It is said to be symmetric when \\(m_1=m_2\\). The \\(X\\)-type and \\(Z\\)-type stabilizers defined as \\(X\\) and \\(Z\\) operators acting on all qubits on adjacent columns and rows, respectively. Let \\(O_{i,j}\\) denote an operator acting on the qubit at a position \\((i,j)\\) on the lattice, with \\(i\\in\\{0,1,\\ldots ,m_1-1\\}\\) and \\(j\\in\\{0,1,\\ldots,m_2-1\\}\\). The code's stabilizer group is\n\\begin{align}\n\\mathsf{S}=\\langle X_{i,*}X_{i+1,*},Z_{*,j}Z_{*,j+1}\\rangle~,\n\\end{align}\nwith generators expressed as products of nearest-neightbour 2-qubit gauge operators,\n\\begin{align}\n\\begin{split}\nX_{i,*}X_{i+1,*}= \\bigotimes_{k=0}^{m_2-1} X_{i,k}X_{i+1,k} \\\\\nZ_{*,j}Z_{*,j+1}=\\bigotimes_{k=0}^{m_1-1} Z_{k,j}Z_{k,j+1}~.\n\\end{split}\n\\end{align}\nSyndrome extraction can be done by measuring these gauge operators, which are on fewer qubits and local.\n\nThe shortest error-correcting Bacon-Shor code is \\([[9,1,3]]\\) with four stabilizer generators\n\\begin{align}\n  \\begin{array}{ccccccccc}\n    X & X & X & X & X & X & I & I & I\\\\\n    I & I & I & X & X & X & X & X & X\\\\\n    Z & Z & I & Z & Z & I & Z & Z & I\\\\\n    I & Z & Z & I & Z & Z & I & Z & Z\n  \\end{array}~,\n\\end{align}\nwhich generate the gauge group with the help of eight additional generators\n\\begin{align}\n  \\begin{array}{ccccccccc}\n  X & I & I & X & I & I & I & I & I\\\\\n  I & X & I & I & X & I & I & I & I\\\\\n  I & I & I & X & I & I & X & I & I\\\\\n  I & I & I & I & X & I & I & X & I\\\\\n  Z & Z & I & I & I & I & I & I & I\\\\\n  I & I & I & Z & Z & I & I & I & I\\\\\n  I & Z & Z & I & I & I & I & I & I\\\\\n  I & I & I & I & Z & Z & I & I & I\n  \\end{array}~.\n\\end{align}\nIf the physical qubits are arranged in a three-by-three square, the \\(Z\\)-type (\\(X\\)-type) gauge operators are supported on qubits in the same row (column). The code reduces to the \\hyperref[code:shor_nine]{Shor code} for a particular gauge configuration.\n","protection":"The \\([[m_1 m_2,1,min(m_1,m_2)]]\\) variant has distance \\(d=min(m_1,m_2)\\). In a symmetric 3-dimensional case (defined on a cubic lattice) with \\(L^3\\) qubits, the code has the parameters \\([[L^3,1,L]]\\).","features":{"rate":"A non-LDPC family of Bacon-Shor codes achieves a distance of \\(\\Omega(n^{1-\\epsilon})\\) with sparse gauge operators.","transversal_gates":"Logical Hadamard is transversal in symmetric Bacon-Shor codes up to a qubit permutation \\cite{arxiv:quant-ph/0610063} and can be implemented with teleportation \\cite{arXiv:quant-ph/0002039}. Bacon-Shor codes on an \\(m \\times mk\\) lattice admit transversal \\(k\\)-qubit-controlled \\(Z\\) gates \\cite{arXiv:1705.01686}.","general_gates":["Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively \\cite{manual:{Yoder, Theodore., \\emph{DSpace@MIT} Practical Fault-Tolerant Quantum Computation (2018)}}."],"fault_tolerance":["Piecably fault-tolerant circuits can be employed to construct non-transversal gates effectively \\cite{manual:{Yoder, Theodore., \\emph{DSpace@MIT} Practical Fault-Tolerant Quantum Computation (2018)}}."],"threshold":["The number of check operators scales sublinearly with system size, so the Bacon-Shor codes alone do not exhibit a threshold \\cite{arxiv:1903.03937}. However, a threshold can be obtained from concatenated Bacon-Shor codes restricted to planar geometries, whose recovery circuit is a subset of a circuit used by a larger bona-fide Bacon-Shor code \\cite{arxiv:2305.12046}.","A lower bound of \\(1.94 \\times 10^{-4}\\) for the accuracy threshold was proved for Bacon-Shor code with 5 levels of concatenation, using Steane method of FTEC \\cite{arxiv:quant-ph/0610063}.","The three dimensional version offers the possibility of being a self-correcting quantum memory \\cite{doi:10.1103/PhysRevA.73.012340}."],"decoders":["While check operators are few-body, stabilizer weights scale with the number of qubits, and stabilizer expectation values are obtained by taking products of gauge-operator expectation values. It is thus not clear how to extract stabilizer values in a fault-tolerant manner \\cite{arxiv:2009.03921,arXiv:2107.02194}."]},"realizations":["Trapped-ion qubits: state preparation, logical measurement, and stabilizer measurement for nine-qubit Bacon-Shor code demonstrated on a 13-qubit device by M. Cetina and C. Monroe groups \\cite{arxiv:2009.11482}."],"notes":["See \\cite[Sec. III.C1]{arxiv:1302.3428} for an exposition."],"relations":{"parents":[{"code_id":"bravyi_bacon_shor"},{"code_id":"subsystem_quantum_parity"}],"cousins":[{"code_id":"hamiltonian","detail":"The 2D Bacon-Shor code Hamiltonian is the compass model \\cite{doi:10.1070/PU1982v025n04ABEH004537,arxiv:cond-mat/0501708}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-31"},{"user_id":"MazinKarjikar","date":"2022-06-28"},{"user_id":"VictorVAlbert","date":"2022-03-15"},{"user_id":"SrilekhaGandhari","date":"2022-01-20"},{"user_id":"VictorVAlbert","date":"2021-12-03"}]},"_zoodb":{"id":"bacon_shor","source_file_path":"codes/quantum/qubits/subsystem/bacon_shor.yml","source_file_modification_token":1689550329219.8643}},"bravyi_bacon_shor":{"code_id":"bravyi_bacon_shor","physical":"qubits","logical":"qubits","name":"Bravyi-Bacon-Shor (BBS) code","short_name":"BBS","introduced":"\\cite{arxiv:1008.1029}","description":"An \\([[n,k,d]]\\) CSS subsystem stabilizer code generalizing Bacon-Shor codes to a larger set of qubit geometries. Defined through a binary matrix \\(A\\) such that physical qubits live on sites \\((i,j)\\) whenever \\(A_{i,j}=1\\). The gauge group is generated by 2-qubit operators, including \\(XX\\) interations between any two qubits sharing a column in \\(A\\), and \\(ZZ\\) interations between two qubits sharing a row. The code parameters are: \\(n=\\sum_{i,j}A_{i,j}\\), \\(k=\\text{rank}(A)\\), and the distance is the minimum weight of any row or column.","protection":"Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits, where \\(d\\) is the minimum weight of a row or column in \\(A\\) \\cite{arXiv:2002.06257}.","relations":{"parents":[{"code_id":"subsystem_stabilizer"}],"cousins":[{"code_id":"subsystem_quantum_parity","detail":"The BBS code construction can utilize different classical codes in different rows and columns of \\(A\\), while the subsystem construction does not; see \\cite[pg. 4]{arxiv:1008.1029}"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-20"},{"user_id":"SrilekhaGandhari","date":"2021-12-13"}]},"_zoodb":{"id":"bravyi_bacon_shor","source_file_path":"codes/quantum/qubits/subsystem/bravyi_bacon_shor.yml","source_file_modification_token":1677058672669.014}},"subsystem_quantum_parity":{"code_id":"subsystem_quantum_parity","physical":"qubits","logical":"qubits","name":"Subsystem QPC","introduced":"\\cite{arXiv:quant-ph/0610088}","description":"Subsystem version of the QPC which has the same parameters as the subspace version, but requires significantly fewer stabilizer measurements, resulting in a much simpler error recovery routine.\n\nThis \\([[n_1n_2,k_1k_2,\\min(d_1,d_2)]]\\) code can be defined \\cite{arxiv:0903.0566} via the CSS construction applied to two binary linear codes, \\(C_X\\) and \\(C_Z\\), satisfying \\(C_X^{\\perp}\\subset C_Z\\).\nThese codes are in turn constructed from two more binary linear codes, \\(C_1 = [n_1, k_1, d_1]\\) and \\(C_2 = [n_2, k_2, d_2]\\), with parity-check matrices \\(H_{1,2}\\) and generator matrices \\(G_{1,2}\\), respectively.\nThe parity-check matrices of \\(C_X\\) and \\(C_Z\\) are then\n\\begin{align}\n\\begin{split}\nH_X &= H_1 \\otimes I_{n_2}\\\\\nH_Z &= G_1 \\otimes H_2~.\n\\end{split}\n\\end{align}\n\nBased on the above construction, the Hilbert space on \\(n_1n_2\\) qubits can be decomposed into a multiple direct sums of multiple tensor products of Hilbert spaces of lower dimensions, as outlined in \\cite{arXiv:quant-ph/0506023}.\n","features":{"decoders":["In a \\([[n_1n_2, k_1k_2, min(d_1, d_2)]]\\) QPC, error correction is achieved by measuring \\((n_1−k_1)n_2+(n_2−k_2)\\) stabilizer generators \\cite{arXiv:quant-ph/0508131}. The subsystem QPC achieves the same degree of correctability, but requires only \\((n_1−k_1)k_2+k_1(n_2−k_2)\\) stabilizer measurements."]},"relations":{"parents":[{"code_id":"subsystem_stabilizer","detail":"The subsystem QPC is a CSS subsystem stabilizer code."}],"cousins":[{"code_id":"quantum_parity"},{"code_id":"hypergraph_product","detail":"The subsystem QPC and hypergraph-product code constructions yield the same dimension and minimum distance, but the former does not yield QLDPC codes; see \\cite[pg. 18]{arxiv:0903.0566}."}]},"_meta":{"changelog":[{"user_id":"SarahMengLi","date":"2022-02-21"},{"user_id":"VictorVAlbert","date":"2022-02-21"}]},"_zoodb":{"id":"subsystem_quantum_parity","source_file_path":"codes/quantum/qubits/subsystem/subsystem_quantum_parity.yml","source_file_modification_token":1680994436850.6685}},"subsystem_stabilizer":{"code_id":"subsystem_stabilizer","physical":"qubits","logical":"qubits","name":"Subsystem qubit stabilizer code","introduced":"\\cite{arXiv:quant-ph/0508131}","description":"Also called a \\textit{gauge stabilizer code}.\nA stabilizer code with some of its logical qubits denoted as \\textit{gauge} qubits and not used for storage of logical information.\nNote that this doesnt lead to new codes but does lead to new error correction and fault tolerance procedures. Subsystem codes are denoted by \\([[n,k,r,d]]\\), similar to stabilizer codes, but with an extra parameter \\(r\\) denoting the number of gauge qubits.\n\nTo create these codes proceed as follows.\nChoose \\(2n\\) operators \\(\\{ \\tilde{X}_j,\\tilde{Z}_j\\}_{j=1}^n\\) from \\(\\mathsf{P}_n\\), the Pauli group on \\(n\\) qubits, such that they obey the same commutation relations as the regular \\(n\\)-qubit Pauli generators \\( \\{X_j,Z_j\\}_{j=1}^n \\) (the subscript on these latter operators indicates the single qubit the Pauli matrix acts on).\nThe tilde operators might act on more than one physical (or \\textit{bare}) qubit but they behave as if they acted only on a single qubit.\nWLOG we can choose a stabilizer group as \\( \\mathsf{S} = \\langle Z_1,\\dots,Z_s \\rangle \\). It follows that the normalizer of \\(\\mathsf{S} \\) is \\( N(\\mathsf{S}) = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_n, \\tilde{X}_{s+1},\\dots, \\tilde{X}_n \\rangle \\).\nWe now choose a gauge group as \\( \\mathsf{G} = \\langle i, \\tilde{Z}_1,\\dots, \\tilde{Z}_s, \\tilde{X}_{s+1}, \\tilde{Z}_{s+1}, \\dots, \\tilde{X}_{s+r}, \\tilde{Z}_{s+r} \\rangle \\) with \\( s + r \\leq n \\).\nThe logical group is chosen as \\( \\mathsf{L} = N(\\mathsf{S})/\\mathsf{G} \\simeq \\langle \\tilde{X}_{s+r+1},\\tilde{Z}_{s+r+1}, \\dots, \\tilde{X}_n,\\tilde{Z}_n \\rangle \\).\nNow the codespace \\( C \\) is as usual the \\(+1\\) eigenspace of the stabilizer \\( \\mathsf{S} \\).\nBut the gauge and logical groups have further decomposed this space into \\( C = A \\otimes B \\simeq (\\mathbb{C}^2)^{\\otimes k} \\otimes (\\mathbb{C}^2)^{\\otimes r} \\).\nThus the Hilbert space is partitioned into 3 sets; \\(k\\) logical qubits, \\(r\\) gauge qubits, and \\(s\\) stabilizer qubits, with \\(s+r+k=n\\).\n","protection":"Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits. More generally, a set of errors \\( \\{ E_a \\} \\) is correctable iff \\( E_aE_b \\not\\in N(\\mathsf{S}) \\setminus \\mathsf{G} \\) for all pairs \\(a,b\\). The distance of the code is the minimal weight of operators in \\( N(\\mathsf{S}) \\setminus \\mathsf{G}\\).\n\nThere is an upper bound of \\(d = O(L^{D-1})\\) on the distance \\cite{arXiv:0810.1983} of geometrically local subsystem stabilizer codes arranged in a \\(D\\)-dimensional lattice of length \\(L\\) with \\(n=L^D\\). More generally, there is a tradeoff theorem \\cite{arxiv:1011.3529} stating that, for any logical operator, there is an equivalent logical operator with weight \\(\\tilde{d}\\) such that \\(\\tilde{d}d^{1/(D-1)}=O(L^{D})\\).\n","features":{"general_gates":["Logical Clifford gates can be implemented fault-tolerantly for subsystem codes of distance at least three \\cite{arxiv:2210.14074}."],"code_capacity_threshold":["For correlated Pauli noise, bounds can be obtained by mapping the effect of noise on the code to a statistical mechanical model \\cite{arXiv:1809.10704}."],"fault_tolerance":["Logical Clifford gates can be implemented fault-tolerantly for subsystem codes of distance at least three \\cite{arxiv:2210.14074}."]},"notes":["When the gauge group \\( \\mathsf{G} \\) is abelian, the above is reduced to the standard stabilizer formalism."],"relations":{"parents":[{"code_id":"qubit_stabilizer","detail":"Subsystem stabilizer codes reduce to stabilizer codes when there are no gauge qubits."},{"code_id":"qudit_subsystem_stabilizer","detail":"Subsystem modular-qudit stabilizer codes reduce to subsystem qubit stabilizer codes for qudit dimension \\(q=2\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-03-17"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"EricKubischta","date":"2021-12-14"}]},"_zoodb":{"id":"subsystem_stabilizer","source_file_path":"codes/quantum/qubits/subsystem/subsystem_stabilizer.yml","source_file_modification_token":1687727505575.3506}},"3d_subsystem_surface":{"code_id":"3d_subsystem_surface","physical":"qubits","logical":"qubits","name":"3D subsystem surface code","introduced":"\\cite{arxiv:2106.02621}","description":"Subsystem generalization of the surface code on a 3D cubic lattice with stabilizer generators of weight at most three.\n","relations":{"parents":[{"code_id":"subsystem_stabilizer"},{"code_id":"single_shot","detail":"The 3D subsystem surface code is a single-shot code \\cite{arxiv:2106.02621}."}],"cousins":[{"code_id":"3d_surface"},{"code_id":"self_correct","detail":"The 3D subsystem surface code is not a self-correcting quantum memory despite being a single-shot code \\cite{arxiv:2305.06389}."},{"code_id":"quantum_double_abelian","detail":"The 3D subsystem surface code Hamiltonian phase diagram exhibits \\(\\mathbb{Z}_2\\) topological order \\cite{arxiv:2305.06389}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-12"}]},"_zoodb":{"id":"3d_subsystem_surface","source_file_path":"codes/quantum/qubits/subsystem/topological/3d_subsystem_surface.yml","source_file_modification_token":1683978912610.377}},"doubled_color":{"code_id":"doubled_color","physical":"qubits","logical":"qubits","name":"Doubled color code","introduced":"\\cite{arxiv:1509.03239}","description":"Family of \\([[2t^3+8t^2+6t-1,1,2t+1]]\\) subsystem color codes (with \\(t\\geq 1\\)), constructed using a generalization of the doubling transformation \\cite{arxiv:1012.4134}, that admit a Clifford + \\(T\\) transversal gate set using gauge fixing.\n","features":{"transversal_gates":"Doubled color codes are triply-even, so they yield a transversal \\(T\\) gate \\cite{arxiv:1509.03239}. Using gauge fixing, the codes admit a Clifford + \\(T\\) transversal gate set."},"relations":{"parents":[{"code_id":"subsystem_color"}],"cousins":[{"code_id":"divisible","detail":"Doubled color codes are constructed using a generalization of the doubling transformation \\cite{arxiv:1012.4134} that combine doubly-even codes to make triply-even codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-24"}]},"_zoodb":{"id":"doubled_color","source_file_path":"codes/quantum/qubits/subsystem/topological/doubled_color.yml","source_file_modification_token":1680994436851.0293}},"heavy_hex":{"code_id":"heavy_hex","physical":"qubits","logical":"qubits","name":"Heavy-hexagon code","introduced":"\\cite{arXiv:1907.09528}","description":"Subsystem stabilizer code on the heavy-hexagonal lattice that combines Bacon-Shor and surface-code stabilizers. Encodes one logical qubit into \\(n=(5d^2-2d-1)/2\\) physical qubits with distance \\(d\\). The heavy-hexagonal lattice allows for low degree (at most 3) connectivity between all the data and ancilla qubits, which is suitable for fixed-frequency transom qubits subject to frequency collision errors.\n\nData qubits and ancillas of the code are placed on a heavy-hexagonal lattice (vertices and edges of a tilling of hexagons). A subset of the ancilla qubits are flag qubits used for detecting high-weight errors arising from fewer faults. The code stabilizers for detecting \\(X\\)-type errors are measured by measuring weight-two \\(Z\\)-type gauge operators whose product produces stabilizers of the surface code. \\(X\\)-type stabilizers are column operators corresponding to stabilizers of the Bacon-Shor code, which are measured by taking products of weight-four and weight-two \\(X\\)-type gauge operators.\n","protection":"Protects against Pauli noise. The code has no threshold for \\(Z\\)-type Pauli errors since they are detected by Bacon-Shor-type stabilizers.","features":{"rate":"\\(1/n\\) for a distance-\\(d\\) heavy-hexagon code on \\(n = (5d^2-2d-1)/2\\) qubits.","encoders":["For a logical-zero state, prepare all data qubits in the physical-zero state and then measure the \\(X\\)-type Bacon-Shor stabilizers. For logical-plus state, prepare all data qubits in the physical-plus state and then measure \\(Z\\)-type surface code stabilizers.","Stabilizer measurement encoding circuits have a constant depth of 10 time steps (excluding ancilla state preparation and measurement)."],"transversal_gates":"CNOT gates are transveral for this code. However, for most architectures, all logical gates would be implemented using lattice surgery methods.","general_gates":["Universal gate set achieved with magic state injection and lattice surgery."],"decoders":["Any graph-based decoder can be used, such as MWPM and Union Find. However, edge weights must be dynamically renormalized using flag-qubit measurement outcomes after each syndrome measurement round.","Machine-learning decoder \\cite{arxiv:2210.09730}."],"fault_tolerance":["All logical gates can be fault-tolerantly implemented using lattice surgery and magic state injection.","Stabilizer measurements are measured fault-tolerantly using one-flag circuits since some single-fault events can result in weight-two data qubit errors which are parallel to the code's logical operators. Hence, using information from the flag-qubit measurements is crucial to fault-tolerantly measure the code stabilizers."],"threshold":["\\(0.45\\%\\) for \\(X\\) errors under a full circuit-level depolarizing noise model (obtained from Monte Carlo simulations).","\\(Z\\)-errors have no threshold given the \\(X\\)-type Bacon-Shor stabilizers."]},"realizations":["Logical state preparation and flag-qubit error correction realized in superconducting-circuit devices (specifically, fixed-frequency transmon qubit architectures) by IBM for \\(d=2\\) \\cite{arXiv:1705.09259,arXiv:2110.04285} and \\(d=3\\) \\cite{arxiv:2203.07205}."],"relations":{"parents":[{"code_id":"subsystem_stabilizer"}],"cousins":[{"code_id":"surface","detail":"Surface code stabilizers are used to measure the Z-type stabilizers of the code."},{"code_id":"bacon_shor","detail":"Bacon-Shor stabilizers are used to measure the X-type stabilizers of the code."},{"code_id":"stab_4_2_2","detail":"The \\(d=2\\) heavy-hexagonal code is closely related to the \\([[4,1,2]]\\) subcode."}]},"_meta":{"changelog":[{"user_id":"ChristopherChamberland","date":"2022-03-17"},{"user_id":"VictorVAlbert","date":"2022-03-17"}]},"_zoodb":{"id":"heavy_hex","source_file_path":"codes/quantum/qubits/subsystem/topological/heavy_hex.yml","source_file_modification_token":1687727505575.472}},"kitaev_honeycomb":{"code_id":"kitaev_honeycomb","physical":"qubits","logical":"qubits","name":"Kitaev honeycomb code","introduced":"\\cite{arxiv:cond-mat/0506438,arxiv:1701.05052}","description":"Code whose logical subspace is labeled by different fusion outcomes of Ising anyons present in the nonabelian topological phase of the Kitaev honeycomb model \\cite{arXiv:cond-mat/0506438}.\nEach logical qubit is constructed out of four Majorana operators, which admit braiding-based gates due to their nonabelian statistics and which can be used for topological quantum computation.\n\nThe Kitaev honeycomb model can be formulated as a qubit subsystem stabilizer code based on the \\(\\mathbb{Z}_2^{(1)}\\) abelian anyon theory, which is non-chiral and non-modular \\cite[Sec. 7.3]{arxiv:2211.03798}.\nThe model realizes all anyon theories of the 16-fold way, i.e., all minimal modular extensions of the \\(\\mathbb{Z}_2^{(1)}\\) anyon theory \\cite{arxiv:cond-mat/0506438}\\cite[Footnote 25]{arXiv:2211.03798}.\n\nThe Kitaev honeycomb code utilizes the nonabelian Ising-anyon topological order of the Kitaev honeycomb model \\cite{arXiv:cond-mat/0506438} (a.k.a. \\(p+ip\\) superconducting phase \\cite{arxiv:1104.5485}) as well as abelian \\(\\mathbb{Z}_2\\) topological order.\nMore generally, the Hamiltonian realizes all anyon theories of the 16-fold way, i.e., all minimal modular extensions of the \\(\\mathbb{Z}_2^{(1)}\\) abelian non-chiral non-modular anyon theory \\cite{arxiv:cond-mat/0506438}\\cite[Footnote 25]{arXiv:2211.03798}.\n","features":{"encoders":["Anyon initialization via quantum control \\cite{arxiv:2205.10114}."],"general_gates":["Clifford gates can be performed by braiding Majorana operators and Pauli measurements can be performed by measuring certain Majorana operators \\cite{arxiv:1701.05052}.","CPHASE gate or a \\(\\pi/8\\) rotation with the help of ancilla states completes a universal gate set \\cite{arxiv:1701.05052}."]},"relations":{"parents":[{"code_id":"majorana_stab","detail":"While the Kitaev honeycomb model is bosonic, a fermionic mapping is useful for solving and understanding the model. Logical subspace of the Kitaev honeycomb code can be formulated as a joint eigenspace of certain Majorana operators \\cite[Sec. 4.1]{arxiv:1701.05052}. Logical Paulis are also be constructed out of Majorana operators."},{"code_id":"qudit_znone","detail":"The Kitaev honeycomb model can be formulated as a qubit subsystem stabilizer code based on the \\(\\mathbb{Z}_{q=2}^{(1)}\\) abelian anyon theory, which is non-chiral and non-modular \\cite[Sec. 7.3]{arxiv:2211.03798}."}],"cousins":[{"code_id":"surface","detail":"The Kitaev honeycomb model can be formulated as a qubit subsystem stabilizer code. This code can be obtained from the square-lattice surface code by \\hyperref[topic:gauging-out]{gauging out} the anyon \\(em\\) \\cite[Sec. 7.3]{arxiv:2211.03798}. During this process, the square lattice is effectively expanded to a hexagonal lattice \\cite[Fig. 12]{arxiv:2211.03798}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-06"}]},"_zoodb":{"id":"kitaev_honeycomb","source_file_path":"codes/quantum/qubits/subsystem/topological/kitaev_honeycomb.yml","source_file_modification_token":1680994436851.3662}},"subsystem_color":{"code_id":"subsystem_color","physical":"qubits","logical":"qubits","name":"Subsystem color code","introduced":"\\cite{arxiv:0908.4246,arxiv:1311.0879}","description":"Stub.\n","relations":{"parents":[{"code_id":"subsystem_stabilizer"}],"cousins":[{"code_id":"color"},{"code_id":"symmetry_protected_self_correct","detail":"A particular gauge-fixed version of this code on a 3D lattice yields a self-correcting memory protected by one-form symmetries (see Sec. IV D of Ref. \\cite{arXiv:1805.01474}). The symmetric energy barrier grows linearly with the length of a side of the lattice. When the system is coupled locally to a thermal bath respecting the symmetry and below a critical temperature, the memory time grows exponentially with the side length. The gauge color code is not a self-correcting quantum memory if symmetry protection is removed \\cite{arxiv:2305.06389}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-18"},{"user_id":"YiTingRickTu","date":"2022-04-23"},{"user_id":"VictorVAlbert","date":"2022-01-01"}]},"_zoodb":{"id":"subsystem_color","source_file_path":"codes/quantum/qubits/subsystem/topological/subsystem_color.yml","source_file_modification_token":1683978912610.5044}},"subsystem_rotated_surface":{"code_id":"subsystem_rotated_surface","physical":"qubits","logical":"qubits","name":"Subsystem rotated surface code","introduced":"\\cite{arxiv:1903.03937}","description":"Subsystem version of the rotated surface code.\n\nFor example, a \\([[3d^2-2d,1,d]]\\) family admits weight-six \\(X,Z\\)-type stabilizer generators on hexagonal plaquettes and weight-three gauge generators on bow-tie shaped regions on the dual lattice.\n","relations":{"parents":[{"code_id":"subsystem_stabilizer"}],"cousins":[{"code_id":"subsystem_surface"},{"code_id":"rotated_surface"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-12-01"}]},"_zoodb":{"id":"subsystem_rotated_surface","source_file_path":"codes/quantum/qubits/subsystem/topological/subsystem_rotated_surface.yml","source_file_modification_token":1680994436851.6543}},"subsystem_surface":{"code_id":"subsystem_surface","physical":"qubits","logical":"qubits","name":"Subsystem surface code","introduced":"\\cite{arxiv:1207.1443}","description":"Subsystem version of the surface code defined on a square lattice with qubits placed at every vertex and center of everry edge.\n\nFor example, a \\([[3L^2,2,L]]\\) family has weight-six \\(X,Z\\)-type stabilizers supported on two of the four triangles of each plaquette.\n","features":{"fault_tolerance":["Gauge fixing and changing the order in which check operators are measured yields a fault-tolerant decoder \\cite{arxiv:2010.09626}."],"code_capacity_threshold":["Independent \\(X,Z\\) noise: the threshold under ML decoding corresponds to the value of critical point of the two-dimensional hexagonal-lattice random-bond Ising model on the Nishimori line \\cite{doi:10.1143/JPSJ.55.3305,arxiv:1207.1443}, calculated to be around \\(7\\%\\) in Ref. \\cite{arXiv:cond-mat/0510816}."],"threshold":["\\(0.81\\%\\) threshold for circuit-level depolarizing noise under a variant of MWPM and using gauge-fixing and specific measurement schedules \\cite{arxiv:2010.09626}, improving the \\(0.67\\%\\) threshold for standard measurement schedules \\cite{arxiv:1207.1443}.","\\(2.22\\%\\) threshold for circuit-level infinitely biased noise under a variant of MWPM and using gauge-fixing and specific measurement schedules \\cite{arxiv:2010.09626}, improving the \\(0.52\\%\\) threshold with standarn measurement schedules."]},"notes":["See \\cite[Sec. III.C3]{arxiv:1302.3428} for an exposition."],"relations":{"parents":[{"code_id":"subsystem_stabilizer"}],"cousins":[{"code_id":"surface"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-10-11"}]},"_zoodb":{"id":"subsystem_surface","source_file_path":"codes/quantum/qubits/subsystem/topological/subsystem_surface.yml","source_file_modification_token":1683978912610.5718}},"subsystem_three_fermion":{"code_id":"subsystem_three_fermion","physical":"qubits","logical":"qubits","name":"Three-fermion (3F) subsystem code","short_name":"3F subsystem","introduced":"\\cite{arxiv:0811.0911,arXiv:2211.03798}","description":"2D subsystem stabilizer code whose low-energy excitations realize the three-fermion anyon theory \\cite{arxiv:0712.1377,arxiv:0811.0911,arxiv:1103.4606}.\nOne version uses two qubits at each site \\cite{arXiv:2211.03798}, while other manifestations utilize a single qubit per site and only two-body interactions \\cite{arxiv:0811.0911,arxiv:0908.4246}.\nAll are expected to be equivalent to each other under local Clifford transformations.\n","relations":{"parents":[{"code_id":"subsystem_stabilizer"},{"code_id":"topological_abelian","detail":"The 3F code is a subsystme code characterized by 3F topological order \\cite{arxiv:2211.03798}, which is chiral and modular."}],"cousins":[{"code_id":"surface","detail":"One version of the 3F subsystem code can be obtained from two copies of the square-lattice surface code by \\hyperref[topic:gauging-out]{gauging out} the anyons \\(e_1m_1e_2\\) and \\(e_2m_2\\) \\cite[Sec. 7.4]{arxiv:2211.03798}."},{"code_id":"three_fermion","detail":"The 3F model cluster-like state encodes the temporal gate operations on the 3F subsystem code into a third spatial dimension \\cite{arxiv:2011.04693}. In addition, one of possible 2D boundaries of the 3F model code is effectively a 2D 3F subsystem code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-29"}]},"_zoodb":{"id":"subsystem_three_fermion","source_file_path":"codes/quantum/qubits/subsystem/topological/subsystem_three_fermion.yml","source_file_modification_token":1687727505575.586}},"frobenius":{"code_id":"frobenius","physical":"qudits","logical":"qudits","name":"Frobenius code","introduced":"\\cite{arXiv:1011.5814}","description":"Let \\(C\\) be a quantum cyclic code on \\(n\\) prime-dimensional qudits. \\(C\\) is a Frobenius code if there exists a positive integer \\(t\\) such that \\(n\\) divides \\(p^t +1\\).","protection":"Protects against Pauli noise.","features":{"decoders":["Adapted from the Berlekamp decoding algorithm for classical BCH codes. There exists a polynomial time quantum algorithm to correct errors of weight at most \\(\\tau\\), where \\(\\delta=2\\tau+1\\) is the BCH distance of the code \\cite{arXiv:1011.5814}. "]},"notes":["Frobenius codes that are also stabilizer codes have been completely classified. No such codes exist when \\(t\\) is odd. All such codes with even \\(t\\) can be directly constructed."],"relations":{"parents":[{"code_id":"qudit_stabilizer"},{"code_id":"quantum_cyclic"}]},"_meta":{"changelog":[{"user_id":"NolanCoble","date":"2021-12-03"}]},"_zoodb":{"id":"frobenius","source_file_path":"codes/quantum/qudits/frobenius.yml","source_file_modification_token":1664458794305.581}},"polynomial":{"code_id":"polynomial","physical":"qudits","logical":"qudits","name":"Quantum Reed-Solomon code","short_name":"Quantum RS","introduced":"\\cite{arxiv:quant-ph/9910059}","description":"Also called \\textit{prime-qudit polynomial code (QPyC)}. Prime-qudit CSS code constructed using two Reed-Solomon codes.\n\nThe original construction \\cite{arxiv:quant-ph/9910059} was for a qubit code (\\(p=2\\)) by using a basis for a larger Galois field over \\(GF(2)\\), yielding an \\([[kN,k(N-2K),K+1]]\\) qubit code from a \\([N,K,\\delta]_{GF(2^k)}\\) RS code with \\(N=2^k-1\\) and \\(K=N-\\delta+1\\).\n\nAn alternative construction \\cite{preset:GottesmanBook} yields an \\([[n,k,d]]_{p>n}\\) prime-qudit CSS code with \\(d=\\min(n-g,g+2-k)\\) that is constructed using two Reed-Solomon codes over \\(GF(p)=\\mathbb{Z}_p\\).\nLet \\(\\{\\alpha_1,\\cdots,\\alpha_n\\}\\) be \\(n\\) distinct nonzero elements of \\(\\mathbb{Z}_p\\), and let \\(g\\) be a number satisfying \\(0\\leq k \\leq g < n\\). Then, define degree-\\(g\\) polynomials\n\\begin{align}\n  f_{\\mu\\cup c}\\left(x\\right)=\\mu_{0}+\\mu_{1}x+\\cdots+\\mu_{k-1}x^{k-1}+c_{k}x^{k}+\\cdots+c_{g}x^{g}\\,,\n\\end{align}\nwhere the first \\(k\\) coefficients are indexed by the coefficient vector \\(\\mu\\in\\mathbb{Z}_p^{ k}\\), and the remaining coefficients are indexed by the vector \\(c\\in\\mathbb{Z}_p^{ (g+1-k)}\\).\nLogical states, labeled by \\(\\mu\\), are superpositions of canonical basis states whose \\(i\\)th bit is \\(f_{\\mu\\cup c}\\), evaluated at \\(\\alpha_i\\) and summed over all possible vectors \\(c\\),\n\\begin{align}\n  |\\overline{\\mu}\\rangle=\\sum_{c\\in\\mathbb{Z}_{p}^{(g+1-k)}}|f_{\\mu\\cup c}(\\alpha_{1}),|f_{\\mu\\cup c}(\\alpha_{2}),\\cdots,|f_{\\mu\\cup c}(\\alpha_{n})\\rangle.\n\\end{align}\n","relations":{"parents":[{"code_id":"qudit_css"},{"code_id":"galois_polynomial","detail":"Galois-qudit RS codes for prime-dimensional qudits are quantum RS codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-23"},{"user_id":"VictorVAlbert","date":"2022-01-12"},{"user_id":"QingfengKeeWang","date":"2021-12-20"},{"user_id":"ManasiShingane","date":"2021-12-05"}]},"_zoodb":{"id":"polynomial","source_file_path":"codes/quantum/qudits/polynomial.yml","source_file_modification_token":1683723711001.9846}},"qudit_css":{"code_id":"qudit_css","physical":"qudits","logical":"qudits","name":"Modular-qudit CSS code","introduced":"\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029}","description":"An \\(((n,K,d))_q\\) modular-qudit stabilizer code admitting a set of stabilizer generators that\nare either \\(Z\\)-type or \\(X\\)-type Pauli strings.\nCodes can be defined from two classical codes and/or chain complexes over the ring \\(\\mathbb{Z}_q\\) via an extension of \\hyperref[topic:CSS-to-homology-correspondence]{qubit CSS-to-homology correspondence} to modular qudits.\nThe homology group of the logical operators has a torsion component because the chain complexes are defined over a ring, which yields codes whose logical dimension is not a power of \\(q\\).\n\nThe stabilizer generator matrix, taking values from \\(\\mathbb{Z}_q\\), is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityq}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commQ}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nFor composite \\(q\\), such codes need not encode an integer number of qudits. For prime \\(q=p\\), properties reminiscent of qubit CSS codes are restored: encoding is based on two related \\hyperref[code:q-ary_linear]{\\(p\\)-ary linear codes}, an \\([n,k_X,d_X]_p \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_p \\) code \\(C_Z\\),\nsatisfying \\(C_X^\\perp \\subseteq C_Z\\). The resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\).\nThe \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parityq} is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\eqref{eq:commQ}.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n","relations":{"parents":[{"code_id":"qudit_stabilizer"},{"code_id":"group_gkp","detail":"An \\(n\\) modular-qubit CSS code corresponds to the \\(\\mathbb{Z}_q^{k_1} \\subseteq \\mathbb{Z}_q^{k_2} \\subset \\mathbb{Z}_q^{n}\\) group construction, where \\(k=k_2/k_1\\)."}],"cousins":[{"code_id":"q-ary_linear","detail":"Construction for prime \\(q=p\\) uses two related \\(p\\)-ary linear codes \\(C_X\\) and \\(C_Z\\)."}]},"_meta":{"changelog":[{"user_id":"LeonidPryadko","date":"2022-02-16"},{"user_id":"VictorVAlbert","date":"2022-02-16"}]},"_zoodb":{"id":"qudit_css","source_file_path":"codes/quantum/qudits/qudit_css.yml","source_file_modification_token":1681484685099.7183}},"qudit_hamming_css":{"code_id":"qudit_hamming_css","physical":"qudits","logical":"qudits","name":"\\([[2^r-1, 2^r-2r-1, 3]]_p\\) prime-qudit CSS code","short_name":"\\([[2^r-1, 2^r-2r-1, 3]]_p\\)","introduced":"\\cite{arxiv:2110.11510}","description":"A family of CSS codes extending \\hyperref[code:quantum_hamming_css]{Hamming-based CSS codes} to prime qudits of dimension \\(p\\) by expressing the qubit code stabilizers in local-dimension-invariant (LDI) form \\cite{arxiv:2110.11510}.","relations":{"parents":[{"code_id":"qudit_css"},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-10"},{"user_id":"LaneGGunderman","date":"2022-02-10"}]},"_zoodb":{"id":"qudit_hamming_css","source_file_path":"codes/quantum/qudits/qudit_hamming_css.yml","source_file_modification_token":1679678315333.9448}},"qudit_stabilizer":{"code_id":"qudit_stabilizer","physical":"qudits","logical":"qudits","name":"Modular-qudit stabilizer code","introduced":"\\cite{arXiv:quant-ph/9705052}","description":"An \\(((n,K,d))_q\\) modular-qudit code whose logical subspace is the joint eigenspace of commuting qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA modular-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_{\\mathbb{Z}_q}\\) or \\([[n,k,d]]_{\\mathbb{Z}_q}\\). For composite \\(q\\), such codes need not encode an integer number of qudits, with \\(K=q^n/|\\mathsf{S}|\\) \\cite{arxiv:1101.1519}. This is because \\(|{\\mathsf{S}}|\\) need not be a power of \\(q\\), as group generators may have different orders. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\). \\textit{Prime-qudit} stabilizer codes, where \\(q=p\\) for some prime \\(p\\), do not suffer from this issue and encode \\(n-k\\) logical qudits, with \\(K=p^{n-k}\\).\n\nEach code can be represented by a \\textit{check matrix} (a.k.a. \\textit{stabilizer generator matrix}) \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(q\\)-ary symplectic representation of a stabilizer generator. The check matrix can be brought into standard form via Gaussian elimination \\cite{arxiv:1101.1519}.\n\nOne can switch between stabilizer codes by appending another abelian subgroup of the Pauli group to the stabilizer group and taking the center of the resulting larger group.\n\\begin{defterm}{Code switching}\n\\label{topic:code-switching}\nCode switching is a map between stabilizer codes that is done using a stabilizer group \\(\\mathsf{F}\\) of the \\(n\\)-qudit Pauli group,\n\\begin{align}\n\\mathsf{S}\\to\\mathsf{N}_{\\left\\langle \\mathsf{S},\\mathsf{F}\\right\\rangle }\\left(\\mathsf{F}\\right)~,\n\\end{align}\nwhere \\(\\mathsf{Z}\\) denotes taking the center of a group.\nIn the context of abelian topological stabilizer codes, code switching implements \\textit{anyon condensation} of any anyons represented by operators in the group \\(\\mathsf{F}\\).\n\\end{defterm}\n","protection":"Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. More generally, define the normalizer \\(\\mathsf{N(S)}\\) of \\(\\mathsf{S}\\) to be the set of all Pauli operators that commute with all \\(S\\in\\mathsf{S}\\). A stabilizer code can correct a Pauli error set \\({\\mathcal{E}}\\) if and only if \\(E^\\dagger F \\notin \\mathsf{N(S)}\\setminus \\mathsf{S}\\) for all \\(E,F \\in {\\mathcal{E}}\\).","features":{"decoders":["The structure of stabilizer codes allows for \\textit{syndrome-based decoding}, where errors are corrected based on the results of stabilizer measurements (\\textit{syndromes}).","Trellis decoder for prime-dimensional qudits, which builds a compact representation of the algebraic structure of the normalizer \\(\\mathsf{N(S)}\\) \\cite{arXiv:2106.08251}."]},"notes":["A standardized definition of the qudit stabilizer group is developed in \\cite{arXiv:1101.1519}.","The number of modular-qudit stabilizer codes was determined in Ref. \\cite{arxiv:2209.01449}."],"relations":{"parents":[{"code_id":"qudits_into_qudits"},{"code_id":"stabilizer"},{"code_id":"quantum_lego","detail":"Modular-qudit stabilizer codes are quantum Lego codes built out of atomic blocks such as the 2-qudit repetition code, single-qudit trivial stabilizer codes, and tensor-products of the \\(|0\\rangle\\) state."}],"cousins":[{"code_id":"q-ary_over_zq","detail":"Modular-qudit stabilizer codes are the closest quantum analogues of additive codes over \\(\\mathbb{Z}_q\\) because addition in the ring corresponds to multiplication of stabilizers in the quantum case."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-19"},{"user_id":"VictorVAlbert","date":"2022-02-16"},{"user_id":"LeonidPryadko","date":"2022-02-16"},{"user_id":"QingfengKeeWang","date":"2022-01-07"},{"user_id":"VictorVAlbert","date":"2021-11-02"}]},"_zoodb":{"id":"qudit_stabilizer","source_file_path":"codes/quantum/qudits/qudit_stabilizer.yml","source_file_modification_token":1689550329219.9685}},"qudits_into_qudits":{"code_id":"qudits_into_qudits","physical":"qudits","logical":"qudits","name":"Modular-qudit code","description":"Also called a \\(\\mathbb{Z}_q\\)\\textit{-qudit code}. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the group \\(\\mathbb{Z}_q\\) of integers \\textit{modulo} \\(q\\). Usually denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined, and with \\(q=p\\) when the dimension is prime.\n","protection":"A convenient and often considered error set is the modular-qudit analogue \\cite{arxiv:quant-ph/9802007,arxiv:2302.07966} of the Pauli string basis for \\hyperref[code:qubits_into_qubits]{qubit} codes. For a single qudit, this set consists of products of powers of the qudit Pauli matrices \\(X\\) and \\(Z\\), which act on computational basis states \\(|k\\rangle\\) for \\(k\\in\\mathbb{Z}_q\\) as\n\\begin{align}\n  X\\left|k\\right\\rangle =\\left|k+1\\right\\rangle \\,\\,\\text{ and }\\,\\,Z\\left|k\\right\\rangle =e^{i\\frac{2\\pi}{q}k}\\left|k\\right\\rangle ~,\n\\end{align}\nwith addition performed modulo \\(q\\). For multiple qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis \\cite{arxiv:quant-ph/9608048,arxiv:quant-ph/9608049,arxiv:quant-ph/0010082}. The distance associated with this set is often the minimum weight of a qudit Pauli string that implements a nontrivial logical operation in the code.\n","features":{"decoders":["For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}."]},"notes":["See Refs. \\cite{arxiv:quant-ph/9802007,arxiv:quant-ph/0408190} for descriptions of the qudit Clifford group.","Weight distribution of a code depends on the average entanglement of codewords \\cite{arXiv:quant-ph/0310137,arxiv:2209.07607}."],"relations":{"parents":[{"code_id":"block_quantum"},{"code_id":"qecc_finite"},{"code_id":"group_quantum","detail":"Group quantum codes whose physical spaces are constructed using modular-integer groups \\(\\mathbb{Z}_q\\) are modular-qudit codes."},{"code_id":"category_quantum","detail":"Category quantum codes whose physical spaces are constructed using \\(\\mathbb{Z}_q\\) as the category are modular-qudit codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-07"},{"user_id":"VictorVAlbert","date":"2021-10-29"}]},"_zoodb":{"id":"qudits_into_qudits","source_file_path":"codes/quantum/qudits/qudits_into_qudits.yml","source_file_modification_token":1678726895517.823}},"qudit_5_1_3":{"code_id":"qudit_5_1_3","physical":"qudits","logical":"qudits","name":"\\([[5,1,3]]_{\\mathbb{Z}_q}\\) modular-qudit code","short_name":"\\([[5,1,3]]_{\\mathbb{Z}_q}\\)","introduced":"\\cite{arXiv:quant-ph/9702033,arxiv:quant-ph/9703048}","description":"Modular-qudit stabilizer code that generalizes the five-qubit perfect code using properties of the multiplicative group \\(\\mathbb{Z}_q\\) \\cite{arXiv:quant-ph/9702033}; see also \\cite[Thm. 13]{arxiv:quant-ph/9703048}. It has four stabilizer generators consisting of \\(X Z Z^\\dagger X^\\dagger I\\) and its cyclic permutations.\nA concise expression for a set of codewords can be found in \\cite[Sec. VI.B]{arxiv:1902.07714}.\n","protection":"Protects against a single error on any one qudit. Detects two-qudit errors.","features":{"encoders":["Generalized CNOT, Toffoli, and quantum Fourier transform gates."]},"relations":{"parents":[{"code_id":"qudit_stabilizer"},{"code_id":"quantum_cyclic"},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"SarahMengLi","date":"2022-02-21"},{"user_id":"VictorVAlbert","date":"2022-02-21"},{"user_id":"VictorVAlbert","date":"2023-01-14"}]},"_zoodb":{"id":"qudit_5_1_3","source_file_path":"codes/quantum/qudits/small/qudit_5_1_3.yml","source_file_modification_token":1679678315334.1177}},"stab_3_1_2":{"code_id":"stab_3_1_2","physical":"qudits","logical":"qudits","name":"Three-qutrit code","short_name":"\\([[3,1,2]]_3\\)","introduced":"\\cite{arXiv:quant-ph/9901025}","description":"A \\([[3,1,2]]_3\\) prime-qudit CSS code that is the smallest qutrit stabilizer code to detect a single-qutrit error.\nwith stabilizer generators \\(ZZZ\\) and \\(XXX\\). The code defines a quantum secret-sharing scheme and serves as a minimal model for the AdS/CFT holographic duality. It is also the smallest non-trivial instance of a quantum maximum distance separable code (QMDS), saturating the quantum Singleton bound. The codewords are\n\\begin{align}\n  \\begin{split}\n    | \\overline{0} \\rangle &= \\frac{1}{\\sqrt{3}} (| 000 \\rangle + | 111 \\rangle + | 222 \\rangle) \\\\\n    | \\overline{1} \\rangle &= \\frac{1}{\\sqrt{3}} (| 012 \\rangle + | 120 \\rangle + | 201 \\rangle) \\\\\n    | \\overline{2} \\rangle &= \\frac{1}{\\sqrt{3}} (| 021 \\rangle + | 102 \\rangle + | 210 \\rangle)~.\n  \\end{split}\n\\end{align}\nThe elements in the superposition of each logical codeword are related to each other via cyclic permutations.\n","protection":"Detects single qutrit errors and protects against a single-qutrit erasure. It is the smallest single-erasure correcting qudit code for \\(q>2\\), and there does not exist a three-qubit code with analogous properties.\n\nThe code is an example of a \\( ((n = 3, k = 2)) \\) threshold scheme where a secret (the quantum information) is split into \\( n \\) shares and can be reconstructed by \\( k \\) pieces.\n\nThey key property of this code is that the reduced density matrix of any single qutrit is maximally mixed, meaning no information can be extracted from that qutrit. Therefore, a single qutrit tells you nothing about the encoded message, but access to any two pairs of qutrits will reveal the secret.\n","features":{"encoders":["In addition to thinking about the encoding of states, it is also interesting to look at the trasformation of operators from the physical space into the logical space. Due to the unique structure and recovery protocol of the three qutrit code, the representation of a logical operator \\( \\overline{O} \\) is not unique. Instead, \\( \\overline{O} \\) can be constructed from unitary matricies with support on only two out of the three qutrits. Therefore, the logical operator has valid representations constructed from support on different sets of two qutrits. This operator construction is directly analogous to the construction of operators in the bulk (at the center) of the AdS\\(_3\\)-Rindler reconstruction. The three-qutrit code can then be used to describe how these local bulk operators are protected against localized boundary errors \\cite{arXiv:1411.7041}.","This construction is related to the cleaning lemma \\cite{arXiv:0810.1983}, which was introduced in the context of constructing self-correcting quantum memories from stabilizer codes with geometrically-local generators. In this lemma, subspaces can be \\textit{cleaned out} by removing operators with support on a subset of qutrits."],"decoders":["The quantum information (the secret) can be recovered from a unitary transformation acting on only two qutrits, \\( U_{ij} \\otimes I \\), where \\(U_{ij}\\) acts on qutrits \\(i,j\\) and \\(I\\) is the identity on the remaining qutrit. By the cyclic structure of the codewords, this unitary transformation performs a permutation that recovers the information and stores it in one of the two qutrits involved in recovery."]},"notes":["Connections to Ads/CFT from the perspetive of how arbitrary operators are encoded into the logical space. This encoding is analagous and helps explain why operators acting on the bulk are protected against localized boundary errors \\cite{arXiv:1411.7041}."],"relations":{"parents":[{"code_id":"polynomial","detail":"The three-qutrit code is the smallest member of a family of \\([[2m-1,1,m]]_{p}\\) prime-qudit quantum Reed-Solomon codes for \\(p=3\\) and \\(m=2\\) \\cite{arxiv:quant-ph/9901025}."},{"code_id":"holographic","detail":"Three-qutrit code is a minimal model for holography \\cite{arxiv:1411.7041,arXiv:1607.03901}."},{"code_id":"quantum_mds","detail":"The three-qutrit code is the smallest nontrivial quantum MDS code."},{"code_id":"small_distance"}],"cousins":[{"code_id":"quantum_secret_sharing","detail":"Three-qutrit code defines a minimal secret-sharing scheme \\cite{arXiv:quant-ph/9901025} that is substantially generalized by approximate secret-sharing codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-08-12"},{"user_id":"FelixHuber","date":"2022-08-12"},{"user_id":"VictorVAlbert","date":"2021-12-29"},{"user_id":"ElizabethRBennewitz","date":"2021-12-03"}]},"_zoodb":{"id":"stab_3_1_2","source_file_path":"codes/quantum/qudits/small/stab_3_1_2.yml","source_file_modification_token":1684508734559.1543}},"stab_9_1_3":{"code_id":"stab_9_1_3","physical":"qudits","logical":"qudits","name":"\\([[9,1,3]]_{\\mathbb{Z}_q}\\) modular-qudit code","introduced":"\\cite{arXiv:quant-ph/9610023}","description":"Modular-qudit CSS code that generalizes the \\([[9,1,3]]\\) Shor code using properties of the multiplicative group \\(\\mathbb{Z}_q\\).\n","protection":"Protects against any quantum error arising from any one of the nine quantum registers.","features":{"encoders":["Generalized CNOT, Toffoli, and quantum Fourier transform gates."]},"relations":{"parents":[{"code_id":"qudit_surface","detail":"The qudit Shor code is a small qudit surface code on a Möbius strip with smooth boundary, which is obtained from removing a face of the tesselation of the projective plane \\(\\mathbb{R}P^2\\) \\cite[Fig. 4]{arxiv:quant-ph/9810055}."},{"code_id":"small_distance"}],"cousins":[{"code_id":"real_projective_plane","detail":"The qudit Shor code is a small qudit surface code on a Möbius strip with smooth boundary, which is obtained from removing a face of the tesselation of the projective plane \\(\\mathbb{R}P^2\\) \\cite[Fig. 4]{arxiv:quant-ph/9810055}."}]},"_meta":{"changelog":[{"user_id":"SarahMengLi","date":"2022-02-21"},{"user_id":"VictorVAlbert","date":"2022-02-21"}]},"_zoodb":{"id":"stab_9_1_3","source_file_path":"codes/quantum/qudits/small/stab_9_1_3.yml","source_file_modification_token":1681484685099.8254}},"qudit_subsystem_stabilizer":{"code_id":"qudit_subsystem_stabilizer","physical":"qudits","logical":"qudits","name":"Subsystem modular-qudit stabilizer code","description":"Also called a \\textit{gauge stabilizer code}.\nModular-qudit generalization of a subsystem qubit stabilizer code.\nCan be obtained by taking a modular qudit stabilizer code and assigning some of its logical qubits to be gauge qubits.\nFor composite qudit dimensions, such codes need not encode an integer number of qudits.\n\nSubsystem stabilizer codes are defined by a gauge group \\(\\mathsf{G}\\) and a stabilizer group \\(\\mathsf{S}\\), both subgroups of the \\(n\\)-qudit Pauli group \\(\\mathsf{P}_n\\) that satisfy \\(\\mathsf{Z}(\\mathsf{G})=\\mathsf{S}\\), where \\(\\mathsf{Z}\\) denotes taking the center of a group.\n\nA code can be constructed by starting with either group.\nGiven an \\(\\mathsf{S}\\), one can pick any \\(\\mathsf{G}\\) satisfying \\(\\mathsf{S}\\subseteq\\mathsf{G}\\subseteq\\mathsf{N(S)}\\), where \\(\\mathsf{N(S)}\\) is the normalizer of the stabilizer group within \\(\\mathsf{P}_n\\).\nAlternatively, given a \\(\\mathsf{G}\\), one defines \\(\\mathsf{S}\\) to be the center of the gauge group.\n\nThe logical Pauli group is \\(\\mathsf{N(G)/S}\\).\nAs such, the case when \\(\\mathsf{G}=\\mathsf{S}\\) reduces to an ordinary stabilizer code, while the case \\(\\mathsf{G}=\\mathsf{N(S)}\\) reduces to a trivial code.\n\nOne can gauge fix \\cite{arxiv:quant-ph/0508131} an Abelian subgroup of the gauge group by adding it to the stabilizer group.\n\\begin{defterm}{Gauge fixing}\n\\label{topic:gauge-fixing}\nGauge fixing is a map between subsystem codes that is done using an abelian subgroup \\(\\mathsf{F}\\subseteq\\mathsf{G}\\),\n\\begin{align}\n\\begin{split}\n  \\mathsf{S}&\\to\\left\\langle \\mathsf{S},\\mathsf{F}\\right\\rangle \\\\\n  \\mathsf{G}&\\to\\mathsf{N}_{\\mathsf{G}}\\left(\\mathsf{F}\\right)~,\n\\end{split}\n\\end{align}\nwhere \\(\\mathsf{N}_{\\mathsf{G}}\\left(\\mathsf{F}\\right)\\) is the normalizer of the stabilizer group within \\(\\mathsf{G}\\).\n\\end{defterm}\nGauge fixing can be used to switch between different stabilizer codes that yield different gauge sets in a process known as \\textit{gauge switching}.\nGauge fixing also encompasses lattice surgery and code deformation \\cite{arxiv:1810.10037}.\n\nOne can also gauge out a subgroup \\(\\mathsf{F}\\) of the Pauli group by adding it to the gauge group.\n\\begin{defterm}{Gauging out}\n\\label{topic:gauging-out}\nGauging out is a map between subsystem codes that is done using a subgroup \\(\\mathsf{F}\\subseteq\\mathsf{P}_n\\),\n\\begin{align}\n\\begin{split}\n  \\mathsf{S}&\\to\\mathsf{Z}\\left(\\left\\langle \\mathsf{G},\\mathsf{F}\\right\\rangle \\right)\\\\\n  \\mathsf{G}&\\to\\left\\langle \\mathsf{G},\\mathsf{F}\\right\\rangle ~.\n\\end{split}\n\\end{align}\nWhen \\(\\mathsf{F}\\) is a subgroup of the logical Pauli group, this is also called \\textit{gauging}.\nIf \\(\\mathsf{F}\\) is itself a Pauli group of \\(m\\) logical qubits of the original subsystem code, then gauging those qubits is equivalent to treating them as gauge qubits.\n\\end{defterm}\n","features":{"decoders":["Syndrome measurements are obtained by first measuring gauge operators of the code and taking their products, which give the stabilizer measurement outcomes. The order in which gauge operators are measured is important since they do not commute. There is a sufficient condition for inferring the stabilizer syndrome from the measurements of the gauge generators \\cite[Appendix]{arxiv:1012.0425}."]},"relations":{"parents":[{"code_id":"qudit_stabilizer","detail":"Subsystem modular-qudit stabilizer codes reduce to modular-qudit stabilizer codes when there are no gauge qudits."},{"code_id":"oecc"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-09"}]},"_zoodb":{"id":"qudit_subsystem_stabilizer","source_file_path":"codes/quantum/qudits/subsystem/qudit_subsystem_stabilizer.yml","source_file_modification_token":1687727505575.8315}},"qudit_znone":{"code_id":"qudit_znone","physical":"qudits","logical":"qudits","name":"\\(\\mathbb{Z}_q^{(1)}\\) subsystem code","introduced":"\\cite{arxiv:1405.1780,arXiv:2211.03798}","description":"Modular-qudit subsystem code, based on the Kitaev honeycomb model \\cite{arxiv:cond-mat/0506438} and its generalization \\cite{arxiv:1405.1780}, that is characterized by the \\(\\mathbb{Z}_q^{(1)}\\) anyon theory \\cite{doi:10.7907/5NDZ-W890}, which is modular for odd prime \\(q\\) and non-modular otherwise. Encodes a single \\(q\\)-dimensional qudit when put on a torus for odd \\(q\\), and a \\(q/2\\)-dimensional qudit for even \\(q\\). This code can be constructed using geometrically local gauge generators, but does not admit geometrically local stabilizer generators. For \\(q=2\\), the code reduces to the subsystem code underlying the Kitaev honeycomb model code as well as the honeycomb Floquet code.","relations":{"parents":[{"code_id":"topological_abelian","detail":"The \\(\\mathbb{Z}_q^{(1)}\\) subsystem code is characterized by the \\(\\mathbb{Z}_q^{(1)}\\) anyon theory \\cite{doi:10.7907/5NDZ-W890}. The anyon theory has a single generator \\(a \\in \\mathbb Z_N\\) with \\(\\theta(a) =e^{\\frac{2\\pi i}{N}a^2}\\). It is modular for odd prime \\(q\\) and non-modular otherwise."}],"cousins":[{"code_id":"qudit_surface","detail":"The \\(\\mathbb{Z}_q^{(1)}\\) subsystem code can be obtained from the \\(\\mathbb{Z}_q\\) square-lattice surface code by \\hyperref[topic:gauging-out]{gauging out} the anyon \\(e^{-1} m\\) and applying single-qubit Clifford gates \\cite[Sec. 7.3]{arxiv:2211.03798}. During this process, the square lattice is effectively expanded to a hexagonal lattice \\cite[Fig. 12]{arxiv:2211.03798}."},{"code_id":"double_semion","detail":"The anyonic exchange statistics of \\(\\mathbb{Z}_4^{(1)}\\) subsystem code resemble those of the double semion code, but its fusion rules realize the \\(\\mathbb{Z}_4\\) group."}]},"_meta":{"changelog":[{"user_id":"nathanan","date":"2023-04-08"},{"user_id":"VictorVAlbert","date":"2023-04-08"},{"user_id":"VictorVAlbert","date":"2023-02-07"}]},"_zoodb":{"id":"qudit_znone","source_file_path":"codes/quantum/qudits/subsystem/topological/qudit_znone.yml","source_file_modification_token":1687727505575.9316}},"semion":{"code_id":"semion","physical":"qudits","logical":"qudits","name":"Chiral semion subsystem code","introduced":"\\cite{arXiv:2211.03798}","description":"Modular-qudit subsystem stabilizer code with qudit dimension \\(q=4\\) that is characterized by the chiral semion topological phase.\nAdmits a set of geometrically local stabilizer generators on a torus.\n","features":{"encoders":["Unitary encoder applied to a 3D stack of 2D surface codes, realizing chiral semion topological order at one of its surfaces \\cite{arxiv:1907.02075,arxiv:2202.05442}."]},"relations":{"parents":[{"code_id":"topological_abelian","detail":"The semion code is a subsystem code characterized by the chiral semion topological phase."}],"cousins":[{"code_id":"double_semion","detail":"The semion code can be obtained from the double-semion stabilizer code by \\hyperref[topic:gauging-out]{gauging out} the anyon \\(\\bar{s}\\) \\cite[Fig. 15]{arxiv:2211.03798}."},{"code_id":"qudit_znone","detail":"The semion code can be obtained from the \\(\\mathbb{Z}_4^{(1)}\\) subsystem code by \\hyperref[topic:code-switching]{condensing} the anyon \\(s^2\\) \\cite[Fig. 15]{arxiv:2211.03798}."}]},"_meta":{"changelog":[{"user_id":"nathanan","date":"2023-04-08"},{"user_id":"VictorVAlbert","date":"2023-04-08"},{"user_id":"VictorVAlbert","date":"2021-12-29"}]},"_zoodb":{"id":"semion","source_file_path":"codes/quantum/qudits/subsystem/topological/semion.yml","source_file_modification_token":1687727505576.0247}},"topological_abelian":{"code_id":"topological_abelian","physical":"qudits","logical":"qudits","name":"Abelian topological code","description":"Code whose codewords realize topological order associated with an Abelian anyon theory, equivalently, a unitary braided fusion category which is an Abelian group under fusion \\cite{arxiv:2004.12048}.\n\nA theory is defined by an Abelian group \\(A\\) of anyon types whose multiplication relations define the fusion rules, and a set of exchange statistics \\(\\theta(a)\\in U(1)\\) obtained by exchanging two anyons of type \\(a\\in A\\).\nThe exchange statistics in turn define braiding relations,\n\\begin{align}\n  B(a,b) = \\frac{\\theta(ab)}{\\theta(a)\\theta(b)}~,\n\\end{align}\nbetween all anyon pairs \\(a,b\\).\n\nAll 2D abelian topological orders can be understood within the subsystem stabilizer formalism \\cite{arxiv:2211.03798}.\nAs such, many of the operations one can perform on such codes have both a stabilizer and a topological-phase interpretation.\nStabilizer generators of 2D topological codes acting on 1D loops of qubits can be interpreted as one-form symmetries of the underlying phase realized by the code.\nIdentification of an anyon \\(a\\) with the vacuum is equivalent to adding string excitation operators corresponding to \\(a\\) to the stabilizer group and taking the center to get another stabilizer group.\nCode states of this new stabilizer code correspond to a \\hyperref[topic:code-switching]{condensed phase} of the parent topological phase.\nThe remaining unidentified parent-phase anyons behave differently with respect to the new condensed-phase state.\nSome become \\textit{confined} while the remaining ones pick up new braiding relations.\n","protection":"Topological order cannot be stabilized via weight-two or weight-three stabilizer generators on nearly Euclidean geometries of qubits or qutrits \\cite{arxiv:quant-ph/0308021,arXiv:1102.0770}.","features":{"encoders":["Any local quantum circuit connecting ground states of topological orders with non-isomorphic Abelian groups must have depth that is at least linear in the diameter of the system \\cite{arXiv:1407.2926}."],"general_gates":["Clifford gates can be implemented by braiding defects; for qubit-based stabilizer codes realizing Abelian topological phases, see Refs. \\cite{arxiv:1305.7203,arxiv:2210.09282}. Most of such designs focus on the surface code \\cite{arxiv:1004.1838,arXiv:1104.5047,arXiv:1208.0928,arXiv:1508.04166,arXiv:1609.04673,arXiv:2103.08381}."],"fault_tolerance":["Fault-tolerant logical operations can be interpreted as anyon \\hyperref[topic:code-switching]{condensation} events \\cite{arxiv:2212.00042}.","Modular decoding applicable to all fault-tolerant protocols based on topological qubit stabilizer codes \\cite{arxiv:2303.04846}."],"code_capacity_threshold":["Noise thresholds can be formulated as anyon \\hyperref[topic:code-switching]{condensation} transitions in a topological field theory \\cite{arxiv:2301.05687}, generalizing the mapping of the effect of noise on a code state to a statistical mechanical model \\cite{arxiv:quant-ph/0110143,arXiv:1208.2317,arXiv:1311.7688,arXiv:1809.10704}."]},"relations":{"parents":[{"code_id":"qudit_subsystem_stabilizer","detail":"All Abelian topological orders can be realized as modular-qudit subsystem stabilizer codes by starting with an abelian quantum double model (slightly different from that of Ref. \\cite{arxiv:2112.11394}) along with a family of Abelian TQDs that generalize the double semion anyon theory and \\hyperref[topic:gauging-out]{gauging out} certain bosonic anyons \\cite{arxiv:2211.03798}. The stabilizer generators of the new subsystem code may no longer be geometrically local."},{"code_id":"topological","detail":"All Abelian topological orders can be realized as modular-qudit subsystem stabilizer codes \\cite{arxiv:2211.03798}. Nonabelian topological orders are purported not to be realizable with Pauli stabilizer codes \\cite{arxiv:1605.03601}."}],"cousins":[{"code_id":"hamiltonian","detail":"Subsystem stabilizer code Hamiltonians described by an Abelian anyon theory do not always realize the corresponding anyonic topological order in their ground-state subspace and may exhibit a rich phase diagram. For example, the Kitaev honeycomb Hamiltonian admits the anyon theories of the 16-fold way, i.e., all minimal modular extensions of the \\(\\mathbb{Z}_2^{(1)}\\) abelian non-chiral non-modular anyon theory \\cite{arxiv:cond-mat/0506438}\\cite[Footnote 25]{arXiv:2211.03798}."},{"code_id":"walker_wang","detail":"Any abelian anyon theory \\(A\\) can be realized at one of the surfaces of a 3D Walker-Wang model whose underlying theory is an abelian TQD containing \\(A\\) as a subtheory \\cite{arxiv:1907.02075,arxiv:2202.05442}\\cite[Appx. H]{arxiv:2211.03798}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-02-08"}]},"_zoodb":{"id":"topological_abelian","source_file_path":"codes/quantum/qudits/subsystem/topological/topological_abelian.yml","source_file_modification_token":1687727505576.1274}},"zthree_znine":{"code_id":"zthree_znine","physical":"qudits","logical":"qudits","name":"\\(\\mathbb{Z}_3\\times\\mathbb{Z}_9\\)-fusion subsystem code","introduced":"\\cite{arXiv:2211.03798}","description":"Modular-qudit 2D subsystem stabilizer code whose low-energy excitations realize a non-modular anyon theory with \\(\\mathbb{Z}_3\\times\\mathbb{Z}_9\\) fusion rules.\nEncodes two qutrits when put on a torus.\n","relations":{"parents":[{"code_id":"topological_abelian","detail":"The \\(\\mathbb{Z}_q^{(1)}\\) subsystem code is characterized by a non-modular anyon theory with \\(\\mathbb{Z}_3\\times\\mathbb{Z}_9\\) fusion rules."}],"cousins":[{"code_id":"quantum_double_abelian","detail":"The \\(\\mathbb{Z}_3\\times\\mathbb{Z}_9\\)-fusion subsystem code can be obtained from a stack of \\(q=3\\) and \\(q=9\\) square-lattice qudit surface codes by \\hyperref[topic:gauging-out]{gauging out} the anyons \\(m_1^{-1}e_2^3\\) and \\(m_2^{-1}\\) \\cite[Sec. 7.5]{arxiv:2211.03798}."}]},"_meta":{"changelog":[{"user_id":"nathanan","date":"2023-04-08"},{"user_id":"VictorVAlbert","date":"2023-04-08"},{"user_id":"VictorVAlbert","date":"2021-12-29"}]},"_zoodb":{"id":"zthree_znine","source_file_path":"codes/quantum/qudits/subsystem/topological/zthree_znine.yml","source_file_modification_token":1680994436863.75}},"double_semion":{"code_id":"double_semion","physical":"qudits","logical":"qudits","name":"Double-semion stabilizer code","introduced":"\\cite{arXiv:cond-mat/0404617,arxiv:2112.11394}","description":"Modular-qudit stabilizer code with qudit dimension \\(q=4\\) that is characterized by the double semion topological phase. The code can be obtained from the \\(\\mathbb{Z}_4\\) surface code by \\hyperref[topic:code-switching]{condensing} the anyon \\(e^2 m^2\\) \\cite{arxiv:2211.03798}.\nOriginally formulated as a non-stabilizer qubit code \\cite{arXiv:cond-mat/0404617}.\n","relations":{"parents":[{"code_id":"tqd_abelian","detail":"When treated as ground states of the code Hamiltonian, the code states realize double-semion topological order, a topological phase of matter that also exists in twisted \\(\\mathbb{Z}_2\\) gauge theory \\cite{doi:10.1007/BF02096988}."}],"cousins":[{"code_id":"surface","detail":"The double semion phase also has a realization in terms of qubits \\cite{arXiv:cond-mat/0404617} that can be compared to the qubit surface code. There is a logical basis for both the toric and double-semion codes where each codeword is a superposition of states corresponding to all noncontractible loops of a particular homotopy type. The superposition is equal for the toric code, whereas some loops appear with a \\(-1\\) coefficient for the double semion."},{"code_id":"qudit_surface","detail":"The anyon fusion rules for the double-semion code and the \\(\\mathbb{Z}_4\\) surface code are the same, but exchange statistics are different. The double-semion code can be obtained from the \\(\\mathbb{Z}_4\\) surface code by \\hyperref[topic:code-switching]{condensing} the anyon \\(e^2 m^2\\) \\cite{arxiv:2211.03798} or by \\hyperref[topic:gauging-out]{gauging out} the one-form symmetry associated with said anyon \\cite[Footnote 18]{arxiv:2211.03798}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-29"}]},"_zoodb":{"id":"double_semion","source_file_path":"codes/quantum/qudits/topological/double_semion.yml","source_file_modification_token":1687727505576.2278}},"quantum_double_abelian":{"code_id":"quantum_double_abelian","physical":"qudits","logical":"qudits","name":"Abelian quantum double stabilizer code","introduced":"\\cite{arXiv:quant-ph/9707021}","description":"Modular-qudit stabilizer code whose codewords realize 2D modular gapped Abelian topological order with trivial cocycle.\nThe corresponding anyon theory is defined by an abelian group.\nAll such codes can be realized by a stack of modular-qudit surface codes because all abelian groups are Kronecker products of cyclic groups.\n","protection":"Error-correcting properties established in Ref. \\cite{arxiv:1804.03203} using operator algebra theory.","relations":{"parents":[{"code_id":"tqd_abelian","detail":"The anyon theory corresponding to abelian quantum double codes is defined by an abelian group and trivial cocycle. All Abelian TQD codes can be realized as modular-qudit stabilizer codes by starting with an abelian quantum double model along with a family of Abelian TQDs that generalize the double semion anyon theory and \\hyperref[topic:code-switching]{condensing} certain bosonic anyons \\cite{arxiv:2211.03798}. Upon gauging, Type-I and II \\(\\mathbb{Z}_2^3\\) TQDs realize the same topological order as certain abelian quantum double models \\cite{arxiv:hep-th/9511195,arxiv:1508.03468,arxiv:2112.12757}."},{"code_id":"quantum_double","detail":"The anyon theory corresponding to (abelian) quantum double codes is defined by an (abelian) group."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-06"}]},"_zoodb":{"id":"quantum_double_abelian","source_file_path":"codes/quantum/qudits/topological/quantum_double_abelian.yml","source_file_modification_token":1687727505576.3198}},"qudit_surface":{"code_id":"qudit_surface","physical":"qudits","logical":"qudits","name":"Modular-qudit surface code","introduced":"\\cite{arXiv:quant-ph/9707021,arxiv:quant-ph/0609070,arxiv:2211.00299}","description":"Also known as the \\(\\mathbb{Z}_q\\) \\textit{surface code}. Extension of the surface code to prime-dimensional \\cite{arXiv:quant-ph/9707021,arxiv:quant-ph/0609070} and more general modular qudits \\cite{arxiv:2211.00299}. Stabilizer generators are few-body \\(X\\)-type and \\(Z\\)-type Pauli strings associated to the stars and plaquettes, respectively, of a tessellation of a two-dimensional surface. Since qudits have more than one \\(X\\) and \\(Z\\)-type operator, various sets of stabilizer generators can be defined. Ground-state degeneracy and the associated phase depends on the qudit dimension and the stabilizer generators.","features":{"decoders":["Renormalization-group decoder \\cite{arxiv:1311.4895}."]},"notes":["The simplest \\href{https://citizensciencegames.com/games/decodoku/}{Decodoku game} is based on the qudit surface code with \\( q=10\\). See related \\href{https://github.com/quantumjim/qec_lectures}{Qiskit tutorial}."],"relations":{"parents":[{"code_id":"quantum_double_abelian","detail":"Modular-qudit surface code Hamiltonians admit topological phases associated with \\(\\mathbb{Z}_q\\) \\cite{arXiv:quant-ph/0609070}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-02"},{"user_id":"VictorVAlbert","date":"2022-01-05"},{"user_id":"IanTeixeira","date":"2021-12-19"}]},"_zoodb":{"id":"qudit_surface","source_file_path":"codes/quantum/qudits/topological/qudit_surface.yml","source_file_modification_token":1680994436864.0012}},"tqd_abelian":{"code_id":"tqd_abelian","physical":"qudits","logical":"qudits","name":"Abelian TQD stabilizer code","introduced":"\\cite{arxiv:1008.0654,arxiv:1211.3695,arxiv:2107.13091}","description":"Modular-qudit stabilizer code whose codewords realize 2D modular gapped Abelian topological order.\nThe corresponding anyon theory is defined by an abelian group and a Type-III group cocycle that can be decomposed as a product of Type-I and Type-II group cocycles; see \\cite[Sec. IV.A]{arXiv:2112.11394}.\n","relations":{"parents":[{"code_id":"qudit_stabilizer","detail":"All Abelian TQD codes can be realized as modular-qudit stabilizer codes by starting with an abelian quantum double model along with a family of Abelian TQDs that generalize the double semion anyon theory and \\hyperref[topic:code-switching]{condensing} certain bosonic anyons \\cite{arxiv:2211.03798}."},{"code_id":"topological_abelian","detail":"Abelian TQDs realize all modular gapped Abelian topological orders \\cite{arxiv:2112.11394}. Conversely, every abelian anyon theory is a subtheory of some TQD \\cite[Sec. 6.2]{arxiv:2211.03798}. Any abelian anyon theory \\(A\\) can be realized at one of the surfaces of a 3D Walker-Wang model whose underlying theory is an abelian TQD containing \\(A\\) as a subtheory \\cite{arxiv:1907.02075,arxiv:2202.05442}\\cite[Appx. H]{arxiv:2211.03798}."},{"code_id":"tqd","detail":"The anyon theory corresponding to (abelian) TQD codes is defined by an (abelian) group and a Type III cocycle."}],"cousins":[{"code_id":"quantum_double_dihedral","detail":"Upon gauging, a Type-III \\(\\mathbb{Z}_2^3\\) TQD realizes the same topological order as the \\(G=D_4\\) quantum double model \\cite{arxiv:hep-th/9511195,arxiv:1508.03468,arxiv:2112.12757}."},{"code_id":"double_semion","detail":"All Abelian TQD codes can be realized as modular-qudit stabilizer codes by starting with an abelian quantum double model along with a family of Abelian TQDs that generalize the double semion anyon theory and \\hyperref[topic:code-switching]{condensing} certain bosonic anyons \\cite{arxiv:2211.03798}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-04-06"}]},"_zoodb":{"id":"tqd_abelian","source_file_path":"codes/quantum/qudits/topological/tqd_abelian.yml","source_file_modification_token":1687727505576.406}},"binary_quantum_goppa":{"code_id":"binary_quantum_goppa","physical":"galois","logical":"galois","name":"Binary quantum Goppa code","introduced":"\\cite{arxiv:quant-ph/0501074,doi:10.1007/s11128-006-0047-9}","description":"Also known as a \\textit{quantum AG code}. Binary quantum Goppa codes are a family of \\( [[n,k,d]]_q \\) CSS codes for \\( q=2^m \\), generated using classical Goppa codes.\n\nLet \\( F/GF(q) \\) be an algebraic function field of one variable, \\(\\sigma \\) be an automorphism of order 2\nof \\(F\\) which leaves \\(GF(q)\\) invariant, and \\(P_1, \\cdots, P_n \\) be pairwise distinct places of degree one such that \\( \\sigma P_i = P_j\\) for all\n\\(i,j = 1, \\cdots, n\\). A place \\( P_i \\) of \\( F/ GF(q) \\) is the unique maximal ideal of a discrete valuation ring of the function field. Let \\( \\nu \\) be a  differential\nthat satisfies the properties guaranteed by  the strong approximation theorem of discrete evaluations. Let \\(G\\) be a divisor such that \\( \\sigma G = G \\) and the\ndiscrete valuation corresponding to place \\(P_i \\) of \\(G\\) and the discrete valuation corresponding to place \\(\\sigma P_i \\) of \\(G\\) are both 0 for all \\(i\\). Then we can define\na code \\( C(G)  = \\{ f(P_1), \\cdots, f(P_n), f(\\sigma P_1), \\cdots , f(\\sigma P_n) | f \\in \\mathcal{L}(G)\\} \\subset GF(q^{2n})\\) and\na code \\(C(H)\\) where \\(H = (P_1 + \\cdots + P_n + \\sigma P_1 + \\cdots + \\sigma P_n) - G + \\nu \\). Then the dual of \\(C(G)\\) with respect to the weighted symplectic inner\nproduct with weights \\(s_i\\) on \\( GF(q^n) \\) is equivalent to \\(C(H)\\). Therefore, the orthogonal code of \\(C(G)\\) is generated by \\(H\\). Using these properties and the assumption\nthat \\(H\\) is a subgroup of \\(G\\), we can construct a classical Goppa code \\(C(D,G)\\), where \\(D\\) is the sum of all \\(P_i\\). Using \\(C(D,G)\\), we can construct a \\([[n,k,d]]_q\\) quantum stabilizer code such that\n\\(k  = \\text{dim} G - \\text{dim}(G-P_1 - \\cdots - P_n - \\sigma P_1 - \\cdots  - \\sigma P_n) - n~.\\)\n","protection":"Protects against weight \\(t\\) errors where \\( 0 < t \\leq  \\lfloor \\frac{d^*-g-1}{2} \\rfloor \\) where \\( d^* = \\text{deg} G + 2 -2g \\) and \\(g\\) is the genus of the function field and \\(d \\geq n - \\lfloor \\frac{deg G}{2} \\rfloor\\).","features":{"encoders":["Encoding defined in Ref. \\cite{arxiv:quant-ph/0107129} uses a technique from Ref. \\cite{arxiv:quant-ph/0005008} to encode quantum stabilizer codes."],"decoders":["Farran algorithm \\cite{arxiv:math/9910151}."]},"relations":{"parents":[{"code_id":"galois_css","detail":"Goppa codes can be realized in the CSS code construction \\cite{doi:10.1007/s11128-006-0047-9}."}],"cousins":[{"code_id":"goppa","detail":"Classical Goppa codes are used to construct their quantum versions."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-15"},{"user_id":"ManasiShingane","date":"2021-12-14"}]},"_zoodb":{"id":"binary_quantum_goppa","source_file_path":"codes/quantum/qudits_galois/evaluation/binary_quantum_goppa.yml","source_file_modification_token":1679678315334.9858}},"galois_bch":{"code_id":"galois_bch","physical":"galois","logical":"galois","name":"Galois-qudit BCH code","short_name":"Galois-qudit BCH","introduced":"\\cite{arxiv:quant-ph/0501126,arxiv:quant-ph/0604102,doi:10.1109/TIT.2006.890730,doi:10.26421/QIC13.1-2-3,doi:10.1103/PhysRevA.80.042331,arxiv:2007.13309}","description":"True Galois-qudit stabilizer code constructed from BCH codes via either the Hermitian construction or the Galois-qudit CSS construction.\n","notes":["See Ref. \\cite{doi:10.1017/CBO9781139034807.014} for an overview of quantum BCH codes."],"relations":{"parents":[{"code_id":"galois_true_stabilizer","detail":"Galois-qudit BCH codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes."}],"cousins":[{"code_id":"q-ary_bch"},{"code_id":"galois_css","detail":"Some Galois-qudit BCH codes are CSS."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"}]},"_zoodb":{"id":"galois_bch","source_file_path":"codes/quantum/qudits_galois/evaluation/galois_bch.yml","source_file_modification_token":1681484685099.942}},"galois_fqrs":{"code_id":"galois_fqrs","physical":"galois","logical":"galois","name":"Folded quantum Reed-Solomon (FQRS) code","short_name":"FQRS","introduced":"\\cite{arxiv:2212.09935}","description":"CSS code on \\(q^m\\)-dimensional Galois-qudits that is constructed from folded Reed-Solomon (FRS) codes via the Galois-qudit CSS construction.\nThis code is used to construct Singleton-bound approaching approximate quantum codes.\n\nMore technically, an \\(m\\)-folded quantum Reed-Solomon code is a member of the \\([[n/m, R \\cdot n/m, d/m]]_{q^m}\\) CSS code family for any \\(0<R<1\\).\nSee \\cite[Defn. 3.8]{arxiv:2212.09935} for an expression of the codewords.\nA folded quantum generalized RS (GRS) code can be defined in similar fashion from GRS codes \\cite[Sec. 3]{arxiv:2212.09935}.\n","features":{"decoders":["Quantum list decodable \\cite{arxiv:2212.09935}."]},"relations":{"parents":[{"code_id":"galois_css","detail":"Folding an quantum polynomial code on \\(q\\)-dimensional Galois qudits yields an FQRS code on \\(q^m\\)-dimensional Galois qudits."}],"cousins":[{"code_id":"folded_reed_solomon"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-08"},{"user_id":"SamGunn","date":"2022-01-08"}]},"_zoodb":{"id":"galois_fqrs","source_file_path":"codes/quantum/qudits_galois/evaluation/galois_fqrs.yml","source_file_modification_token":1679678315335.1135}},"galois_grs":{"code_id":"galois_grs","physical":"galois","logical":"galois","name":"Galois-qudit GRS code","short_name":"Galois GRS","introduced":"\\cite{arxiv:quant-ph/9906129,arxiv:1311.3009}","description":"True \\(q\\)-Galois-qudit stabilizer code constructed from generalized Reed-Solomon (GRS) codes via either the Hermitian construction \\cite{arxiv:1311.3009,doi:10.1142/S0219749919500060,doi:10.1109/TIT.2010.2054174} or the Galois-qudit CSS construction \\cite{arxiv:quant-ph/9906129,arxiv:0812.4514}.\n","relations":{"parents":[{"code_id":"galois_true_stabilizer","detail":"Galois-qudit GRS codes constructed via the CSS construction are Galois-qudit CSS codes, and the rest are true stabilizer codes."}],"cousins":[{"code_id":"generalized_reed_solomon","detail":"Hermitian self-orthogonal GRS codes are used to construct Galois-qudit GRS codes in the Hermitian construction."},{"code_id":"quantum_mds","detail":"Some Galois-qudit GRS codes are quantum MDS \\cite{arxiv:1311.3009}."},{"code_id":"galois_css","detail":"Some Galois-qudit GRS codes are CSS."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"}]},"_zoodb":{"id":"galois_grs","source_file_path":"codes/quantum/qudits_galois/evaluation/galois_grs.yml","source_file_modification_token":1679678315335.1768}},"galois_polynomial":{"code_id":"galois_polynomial","physical":"galois","logical":"galois","name":"Galois-qudit RS code","short_name":"Galois RS","introduced":"\\cite{arxiv:quant-ph/9906129}","description":"Also called a \\textit{polynomial code (QPyC)}. An \\([[n,k,n-k+1]]_q\\) (with \\(q>n\\)) Galois-qudit CSS code constructed using two Reed-Solomon codes over \\(GF(q)\\).\n\nLet \\(C_1\\) be a \\([n,k_1,d_1]_q\\) Reed-Solomon code and \\(C_2^\\perp\\) be a \\([n,k_2,d_2]_q\\) Reed-Solomon code, modified such that \\(C_2^\\perp \\subseteq C_1\\) and \\(0\\le k_2 \\le k_1 \\le n\\). Then, a polynomial code is a non-degenerate \\([[n,k_2,d]]_q\\) Galois-qudit CSS code with \\(d=\\min(n-k_1+1,k_1-k_2+1)\\). The polynomial code is the span of the basis codewords over GF(\\(q\\))\n\\begin{align}\n|\\overline{\\beta_0,\\cdots,\\beta_{k_2-1}}\\rangle\n=\n\\sum_{(\\beta_{k_2},\\cdots,\\beta_{k_1-1})\\in GF(q) }\n\\bigotimes_{i=1}^{n}\n\\left| \\sum_{j=0}^{k_1-1} \\beta_j \\alpha_i^j \\right\\rangle,\n\\end{align}\nwhere \\((\\alpha_1, \\cdots, \\alpha_n)\\) are \\(n\\) distinct points chosen for code \\(C_1\\) from \\(GF(q)\\setminus \\{0\\}\\).'\n","relations":{"parents":[{"code_id":"galois_grs"}],"cousins":[{"code_id":"galois_fqrs","detail":"A FQRS code with no extra grouping (\\(m=1\\)) reduces to a Galois-qudit RS code that is CSS."},{"code_id":"reed_solomon","detail":"Galois-qudit RS codes codes are CSS codes constructed from Reed-Solomon codes."},{"code_id":"quantum_mds","detail":"A polynomial code is a quantum MDS code when \\(n-k_1=k_1-k_2\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-10"},{"user_id":"QingfengKeeWang","date":"2021-12-20"}]},"_zoodb":{"id":"galois_polynomial","source_file_path":"codes/quantum/qudits_galois/evaluation/galois_polynomial.yml","source_file_modification_token":1679678315335.2393}},"galois_into_galois":{"code_id":"galois_into_galois","physical":"galois","logical":"galois","name":"Galois-qudit code","introduced":"\\cite{doi:10.1002/(SICI)1520-6610(2000)8:3<174::AID-JCD3>3.0.CO;2-T,arXiv:quant-ph/0508070}","description":"Also called a \\(GF(q)\\)\\textit{-} or \\(\\mathbb{F}_q\\)\\textit{-qudit code}. Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, with canonical qudit states \\(|k\\rangle\\) labeled by elements \\(k\\) of the \\textit{Galois field} \\(GF(q)\\) and with \\(q\\) being a power of a prime \\(p\\). A Galois field can be thought of as a vector space whose basis vectors are the \\(m\\) roots of some polynomial and whose coefficients (i.e., field) are \\(p\\)th roots of unity. Codes can be denoted as \\(((n,K))_q\\) or \\(((n,K,d))_q\\), whenever the code's distance \\(d\\) is defined. This notation differentiates between Galois-qudit and \\(((n,K,d))_{\\mathbb{Z}_q}\\) modular-qudit codes, although the same notation is usually used for both.","protection":"A convenient and often considered error set is the Galois-qudit analogue of the Pauli string set for \\hyperref[code:qubits_into_qubits]{qubit} codes. For a single Galois qudit, this set consists of products of \\(X\\)-type and \\(Z\\)-type operators labeled by elements \\(\\beta \\in GF(q)\\), which act on computational basis states \\(|\\gamma\\rangle\\) for \\(\\gamma\\in GF(q)\\) as\n\\begin{align}\n  X_{\\beta}\\left|\\gamma\\right\\rangle =\\left|\\gamma+\\beta\\right\\rangle \\,\\,\\text{ and }\\,\\,Z_{\\beta}\\left|\\gamma\\right\\rangle =e^{i\\frac{2\\pi}{p}\\text{tr}(\\beta\\gamma)}\\left|\\gamma\\right\\rangle~,\n\\end{align}\nwhere the trace maps elements of the field to elements of \\(\\mathbb{Z}_p\\) as\n\\begin{align}\n  \\text{tr}(\\gamma)=\\sum_{k=0}^{m-1}\\gamma^{p^{k}}~.\n\\end{align}\nFor multiple Galois qudits, error set elements are tensor products of elements of the single-qudit error set.\n\nThe Galois-qudit Pauli error set is a unitary basis for linear operators on the multi-qudit Hilbert space that is orthonormal under the Hilbert-Schmidt inner product; it is a nice error basis \\cite{arxiv:quant-ph/9608048,arxiv:quant-ph/9608049,arxiv:quant-ph/0010082}. The distance associated with this set is often the minimum weight of a Galois qudit Pauli string that implements a nontrivial logical operation in the code.\n","features":{"decoders":["For few-qudit codes (\\(n\\) is small), decoding can be based on a lookup table. For infinite code families, the size of such a table scales exponentially with \\(n\\), so approximate decoding algorithms scaling polynomially with \\(n\\) have to be used. The decoder determining the most likely error given a noise channel is called the \\textit{maximum-likelihood decoder}."]},"notes":["Introduction to Galois qudits by \\href{https://ethz.ch/content/vp/en/conferences/2014/qec/05_thursday/dab6ca18-7453-4197-aaaa-8b1964ece714.html}{Gottesman}.","Wigner function for Galois qudits \\cite{arxiv:quant-ph/0401155}."],"relations":{"parents":[{"code_id":"block_quantum"},{"code_id":"qecc_finite"},{"code_id":"group_quantum","detail":"A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits \\cite{doi:10.1109/18.959288}; see Sec. 5.3 of Ref. \\cite{arxiv:quant-ph/0501074}. Interpreted this way, Galois-qudit codes are group quantum codes whose physical spaces are constructed using Galois fields \\(GF(q)\\) as groups."},{"code_id":"category_quantum","detail":"Category quantum codes whose physical spaces are constructed using \\(GF(q)\\) as the category are Galois-qudit codes."}],"cousins":[{"code_id":"qudits_into_qudits","detail":"A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits \\cite{doi:10.1109/18.959288}; see Sec. 5.3 of Ref. \\cite{arxiv:quant-ph/0501074}. The two coincide when \\(q\\) is prime, and reduce to qubits when \\(q=2\\). However, Pauli matrices for the two types of qudits are defined differently."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-07"},{"user_id":"VictorVAlbert","date":"2021-12-03"}]},"_zoodb":{"id":"galois_into_galois","source_file_path":"codes/quantum/qudits_galois/galois_into_galois.yml","source_file_modification_token":1678726895518.0813}},"non_stabilizer":{"code_id":"non_stabilizer","physical":"galois","logical":"galois","name":"Galois-qudit non-stabilizer code","short_name":"Non-stabilizer","introduced":"\\cite{arxiv:quant-ph/0210097}","description":"The projection onto a stabilizer code is proportional to an equal sum over all elements of the stabilizer group \\(\\mathsf{S}\\).\nNon-stabilizer codes generalize stabilizer codes by modifying the code projection with elements of a subset \\(\\mathsf{B}\\subset\\mathsf{S}\\) called the \\textit{Fourier description} (see proof of Thm. 2.7 in Ref. \\cite{arxiv:quant-ph/0210097}). When \\(\\mathsf{B}\\) is a subgroup of \\(\\mathsf{S}\\), then the code reduces to an ordinary stabilizer code.\n\nThe following non-stabilizer codes were constructed in Ref. \\cite{arxiv:quant-ph/0210097}: \\(((33, 155, 3))\\), \\(((15, 8, 3))\\), \\(((n, \\lceil\\frac{q^n}{n(q^2-1)}\\rceil,2))_q\\) and \\(((n, 1+n(q-1),2))_q\\), where \\(n\\) is odd. The last code family is a Galois-qudit extension of the non-additive \\hyperref[code:qubit_5_6_2]{six-qubit CWS code}.\n","features":{"encoders":["The encoding circuit involves the application of quantum Fourier transform."],"decoders":["The decoding circuit involves the application of phase estimation."]},"relations":{"parents":[{"code_id":"galois_into_galois"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-13"},{"user_id":"JiaxinHuang","date":"2022-04-08"}]},"_zoodb":{"id":"non_stabilizer","source_file_path":"codes/quantum/qudits_galois/non_stabilizer.yml","source_file_modification_token":1678631058740.8896}},"balanced_product":{"code_id":"balanced_product","physical":"galois","logical":"galois","name":"Balanced product (BP) code","short_name":"BP","introduced":"\\cite{arXiv:2012.09271}","description":"Family of CSS quantum codes based on products of two classical codes which share common symmetries. The balanced product can be understood as taking the usual tensor/hypergraph product and then factoring out the symmetries factored. This reduces the overall number of physical qubits \\(n\\), while, under certain circumstances, leaving the number of encoded qubits \\(k\\) and the code distance \\(d\\) invariant. This leads to a more favourable encoding rate \\(k/n\\) and normalized distance \\(d/n\\) compared to the tensor/hypergraph product.","protection":"Taking balanced products of two classical LDPC codes which have a symmetry group which grows linearly in their block lengths were known to give QLDPC codes with a linear rate and which were conjectured to have linear distance \\cite{arXiv:2012.09271}. This conjecture was proved in Ref. \\cite{arXiv:2111.03654}.","features":{"rate":"A notable family of balanced product codes encode \\(k \\in \\Theta(n^{4/5})\\) logical qubits with distance \\(d \\in \\Omega(n^{3/5})\\) for any number of physical qubits \\(n\\). Additionally, it is known that the code constructed from the balanced product of two good classical LDPC codes over groups of order \\(\\Theta(n)\\) has a constant encoding rate \\cite{arxiv:2012.09271}.","decoders":["BP-OSD decoder \\cite{arXiv:1904.02703}."]},"relations":{"parents":[{"code_id":"galois_css"},{"code_id":"generalized_homological_product_css","detail":"Balanced product codes result from a tensor product of two classical-code chain complexes, followed by a factoring out of certain symmetries."}],"cousins":[{"code_id":"subsystem_stabilizer","detail":"Distance balancing is used to form balanced-product subsystem codes \\cite{arXiv:2012.09271}."},{"code_id":"distance_balanced","detail":"Distance balancing is used to form balanced-product subsystem codes \\cite{arXiv:2012.09271}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-03"},{"user_id":"FinneganVoichick","date":"2021-12-18"},{"user_id":"NikolasBreuckmann","date":"2021-12-14"}]},"_zoodb":{"id":"balanced_product","source_file_path":"codes/quantum/qudits_galois/qldpc/balanced_product.yml","source_file_modification_token":1681484685100.0508}},"distance_balanced":{"code_id":"distance_balanced","physical":"galois","logical":"galois","name":"Distance-balanced code","introduced":"\\cite{arxiv:1611.03790,arxiv:2004.07935}","description":"Galois-qudit CSS code constructed from a CSS code and a classical code using a distance-balancing procedure based on a generalized homological product.\nThe initial code is said to be \\textit{unbalanced}, i.e., tailored to noise biased toward either bit- or phase-flip errors, and the procedure can result in a code that is treats both types of errors on a more equal footing.\nThe original distance-balancing procedure \\cite{arxiv:1611.03790}, later generalized \\cite[Thm. 4.2]{arxiv:2004.07935}, can yield QLDPC codes \\cite[Thm. 1]{arxiv:1611.03790}.\n\nA related procedure called \\textit{weight reduction} \\cite{arXiv:1611.03790} takes in a CSS stabilizer code and outputs another CSS code that admits a set of stabilizer generators whose weight is independent of the number of qubits \\(n\\).\n","relations":{"parents":[{"code_id":"galois_css"},{"code_id":"generalized_homological_product_css"}],"cousins":[{"code_id":"homological_product","detail":"Distance balancing relies on taking a homological product of chain complexes corresponding to a classical and a quantum code."},{"code_id":"subsystem_stabilizer"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-20"}]},"_zoodb":{"id":"distance_balanced","source_file_path":"codes/quantum/qudits_galois/qldpc/distance_balanced.yml","source_file_modification_token":1683978912610.8315}},"expander_lifted_product":{"code_id":"expander_lifted_product","physical":"galois","logical":"galois","name":"Expander LP code","introduced":"\\cite{arXiv:2111.03654}","description":"Family of \\(G\\)-lifted product codes constructed using two random classical \\hyperref[code:tanner]{Tanner codes} defined on expander graphs \\cite{doi:10.1090/S0273-0979-06-01126-8}. For certain parameters, this construction yields the first asymptotically good QLDPC codes. Classical codes resulting from this construction are one of the first two families of \\(c^3\\)-LTCs.\n\nAn expander lifted-product code family is constructed as follows. First, take the Cayley graph of a finite group \\(G\\).\nSecond, take the double cover of the graph, resulting in a graph that satisfies the requirements of participating in a \\(G\\)-lifted product (i.e., the resulting graph is a free \\({\\mathbb{F}}_q G\\)-module). Third, create a \\hyperref[code:tanner]{Tanner code} out of the graph, in which parity-check supports are defined by the graph, and bitstrings satisfying a particular parity check are defined to be the codewords of a small classical code (chosen to be a random code in the construction). Fourth, take the \\(G\\)-lifted product of two copies of the \\hyperref[code:tanner]{Tanner code}.\n\nThe small classical codes used in the construction of good QLDPC codes are required to have a certain product-expansion property (Lemma 10 in Ref. \\cite{arXiv:2111.03654}); it is proven that random codes satisfy said property in the thermodynamic limit.\n","protection":"Code performance strongly depends on \\(G\\). Certain nonabelian groups yield asymptotically good QLDPC codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n)]]\\) \\cite{arXiv:2111.03654}. Abelian groups like \\(\\mathbb{Z}_{\\ell}\\) for \\(\\ell=\\Theta(n / \\log n)\\) yield constant-rate codes with parameters \\([[n, k = \\Theta(n), d = \\Theta(n / \\log n)]]\\) \\cite{arxiv:2012.04068}; this construction can be derandomized by being reformulated as a balanced product code \\cite{arXiv:2012.09271}.","features":{"rate":"Expander lifted-product codes include the first examples \\cite{arXiv:2111.03654} of (asymptotically) \\textit{good QLDPC codes}, i.e., codes with asymptotically constant rate and linear distance. The existence of such codes proves the QLDPC conjecture \\cite{arXiv:2103.06309}. Another notable family encodes \\(k \\in \\Theta(n^\\alpha \\log n)\\) logical qubits with distance \\(d \\in \\Omega(n^{1 - \\alpha} / \\log n)\\) for any number of physical qubits \\(n\\) and any real parameter \\(0 \\leq \\alpha < 1\\) \\cite{arxiv:2012.04068}.","decoders":["Linear-time decoder \\cite{arxiv:2206.07571}.","Logarithmic-time subroutine \\cite{arxiv:2208.05537}."]},"notes":["Construction outlined in talk by \\href{https://www.youtube.com/watch?v=k7LuOiOBYyQ}{R. O'Donnell}.","Popular summary in \\href{https://www.quantamagazine.org/qubits-can-be-as-safe-as-bits-researchers-show-20220106}{Quanta Magazine}."],"relations":{"parents":[{"code_id":"lifted_product"}],"cousins":[{"code_id":"good_qldpc","detail":"Lifted products of certain classical Tanner codes are the first asymptotically good QLDPC codes."},{"code_id":"q-ary_ltc","detail":"Classical codes resulting from the expander lifted-product construction are one of the first two families of \\(c^3\\)-LTCs."},{"code_id":"tanner","detail":"Expander lifted-product codes are products of regular \\(q\\)-ary Tanner codes defined on expander graphs \\cite{doi:10.1090/S0273-0979-06-01126-8}."},{"code_id":"random","detail":"Expander lifted-product codes are quantum CSS codes that utilize short classical codes in their construction which need to satisfy some properties (Ref. \\cite{arXiv:2111.03654}, Lemma 10). It is shown that such codes exist, but they are not explicitly constructed. Such codes can be obtained by repeated random sampling or by performing a search of all codes of desired length. Nevertheless, since the length of the desired short codes does not scale with \\(n\\), this construction is effectively explicit."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-26"},{"user_id":"VictorVAlbert","date":"2022-01-19"},{"user_id":"PavelPanteleev","date":"2021-11-30"}]},"_zoodb":{"id":"expander_lifted_product","source_file_path":"codes/quantum/qudits_galois/qldpc/expander_lifted_product.yml","source_file_modification_token":1683723711002.4702}},"galois_topological":{"code_id":"galois_topological","physical":"galois","logical":"galois","name":"Galois-qudit topological code","introduced":"\\cite{arxiv:quant-ph/0609070,doi:10.1109/CIG.2010.5592860,arxiv:1202.3338}","description":"Abelian topological code, such as a surface \\cite{arxiv:quant-ph/0609070,arxiv:1202.3338} or color \\cite{doi:10.1109/CIG.2010.5592860} code, constructed on lattices of Galois qudits.\n","relations":{"parents":[{"code_id":"galois_css"},{"code_id":"topological"}],"cousins":[{"code_id":"quantum_double_abelian","detail":"A Galois qudit for \\(q=p^m\\) can be decomposed into a Kronecker product of \\(m\\) modular qudits \\cite{doi:10.1109/18.959288}; see Sec. 5.3 of Ref. \\cite{arxiv:quant-ph/0501074}. Galois-qudit topological surface and color codes yield abelian quantum-double codes via this decomposition."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-27"}]},"_zoodb":{"id":"galois_topological","source_file_path":"codes/quantum/qudits_galois/qldpc/galois_topological.yml","source_file_modification_token":1680994436864.4587}},"generalized_bicycle":{"code_id":"generalized_bicycle","physical":"galois","logical":"galois","name":"Generalized bicycle (GB) code","short_name":"GB","introduced":"\\cite{arxiv:1212.6703,arxiv:2203.17216}","description":"A quasi-cyclic Galois-qudit CSS code constructed using a generalized version of the bicycle ansatz \\cite{arXiv:quant-ph/0304161} from a pair of equivalent index-two quasi-cyclic linear codes.\n\nThe stabilizer generator matrix of a \\([[ n=2\\ell,k,d]]\\) GB\\((a,b)\\) code over \\(GF(q)\\), constructed from polynomials \\(a(x)\\) and \\(b(x)\\), can be refined to the form\n\\begin{align}\n  H_{X}=(A|B), H_{Z}^{T}=\\begin{pmatrix}A\\\\-B\\end{pmatrix}~,\n\\end{align}\nwhere \\(\\ell\\times\\ell\\) are circulant matrices \\(A=a(P)\\) and \\(B=b(P)\\), and \\(P\\) is the permutation matrix of a one-step length-\\(\\ell\\) cyclic shift.\n\nWith any GB\\((a,b)\\) code, there is an associated \\(q\\)-ary cyclic classical code \\(C_{h(x)}^{perp}=C_{g(x)}\\) of length \\(\\ell\\), with the check and generating polynomials\n\\begin{align}\n  h(x)=\\text{gcd}(a(x),b(x),x^{\\ell}-1) \\text{and} g(x)=\\frac{x^{\\ell}-1}{h(x)}~,\n\\end{align}\nrespectively.\nThe number of qudits encoded in such a GB code is \\(k=2\\text{deg}h(x)\\), twice the dimension of the underlying classical code \\cite{arxiv:1904.02703}.\n\nTwo codes GB\\((a,b)\\) and GB\\((a',b')\\) of the same size \\(n=2\\ell\\) are equivalent if the following five conditions are satisfied \\cite{arxiv:2203.17216}:\n(1)\t\\(a'(x)=a(x^{m})\\) mod \\(x^{\\ell}-1\\), \\(b'(x)=b(x^{m})\\) mod \\(x^{\\ell}-1\\) for some \\(m\\) mutually prime with \\(\\ell\\), gcd\\((m,\\ell)=1\\);\n(2)\t\\(a'(x)=b(x), b'(x)=a(x)\\);\n(3)\t\\(a'(x)\\) and \\(b'(x)\\) are the reciprocal polynomials of \\(a(x)\\) and \\(b(x)\\), respectively;\n(4)\t\\(a'(x)=\\delta a(x), b'(x)=b(x)\\), for some \\(0\\neq\\delta\\in GF(q)\\);\n(5)\t\\(a'(x)=f(x)a(x), b'(x)=f(x)b(x)\\), for some polynomial \\(f(x)\\in GF(q)[x]\\) such that gcd\\((f,x^{\\ell}-1)=1\\).\n\nThe following modified construction yields \\textit{asymmetric bicycle (AB) codes}: \\(\\mathcal{Q}'=\\text{CSS}(H'_{X},H_{Z})\\) has \\(H'_{X}=(A_{1}|B_{1}),A_{1}=a_{1}(P),B_{1}=b{1}(P)\\), where \\(a_{1}=\\frac{a(x)}{\\text{gcd}(a,b)},b_{1}=\\frac{b(x)}{\\text{gcd}(a,b)}\\).\n","protection":"Given the parameters \\([[n_{0}=2\\ell,k_{0},d_{0}]]_q\\) of the classical linear quasi-cyclic code QC\\((a,b)\\), the quantum CSS code GB\\((a,b)\\) has parameters \\([[ 2\\ell,2k_{0}-2\\ell,d]]_q\\)  where \\(d\\geq d_{0}\\).\n\nConsider a quasi-cyclic QC\\((a,b)\\) in the special case \\(a(x)=f(x)h(x),b(x)=h(x)\\), where for some polynomial \\(r(x)\\), \\(\\text{gcd}(a(x),b(x),x^{\\ell}-1)=p(x)\\) is a factor of the generating polynomial, \\(g(x)=p(x)q(x)\\). Then the distance of the QC code satisfies the following two bounds:\n(a)\tIf \\(r(x)=0,d_{0}\\geq\\text{min}{d[q],1+d[q]}\\);\n(b)\tOtherwise, if gcd\\((a(x),b(x),x^{\\ell}-1)=1\\), then \\(d_{0}\\text{min}{2d[q],d[q]/\\text{wgt}(r)}\\).\nHere, \\(h(x)=\\text{gcd}(a(x),b(x),x^{\\ell}-1)\\) and \\(g(x)=\\frac{x^{\\ell}-1}{h(x)}\\), and \\(d[q]\\) is the distance of the linear cyclic code generated by \\(q(x)\\) \\cite{arxiv:2203.17216}.\n\nLet \\(x^{\\ell}-1=g(x)h(x)\\) with \\(g(x)\\in GF(q)[x]\\) irreducible, and\n\\begin{align}\n\\label{eq:gb_gv}\n  d_{GV}=\\text{max }d:\\sum_{s=1}^{d-1}(q-1)^{s}\\left[\\begin{pmatrix}2\\ell\\\\\n  s \\end{pmatrix}-\\begin{pmatrix}\\ell\\\\ s\n  \\end{pmatrix}\\right]\\,.\n\\end{align}\nThen, there exists \\(f(x)\\in GF(q)[x]\\) such that the length-\\(2\\ell\\) quasi-cyclic code QC\\((hf,h)\\) has distance \\(d\\geq\\text{min}(d[g],d_{GV})\\), where \\(d[g]\\) is the distance of the cyclic code generated by \\(g(x)\\) \\cite{arxiv:2203.17216}.\n\n\\subsection{GB codes with linear distance}\nLet \\(\\ell\\) be such that \\(\\text{ord}_{\\ell}-1=\\ell-1\\), where \\(\\text{ord}_{\\ell}(q)\\) is the multiplicative order function of \\(q\\) modulo \\(\\ell\\).\nThis ensures that \\(x^{\\ell}-1\\) has only two irreducible factors in \\(GF(q)[x]\\), \\(h(x)=1-x\\), and \\(g(x)=1+x+\\cdots+x^{\\ell-1}\\).\nThen, there is a GB code with parameters \\([[ 2\\ell,2,d\\geq d_{GV}]]_q\\) \\cite{arxiv:2203.17216}.\n\nAn incommensurate GB code with row weight \\(w\\) and parameters \\([[ n=2\\ell,k,d]]_p\\) is equivalent to a CSS code local in \\(D\\leq w-1\\) dimensions (\\(D\\leq w-1\\) if \\(\\ell\\) is prime). Its parameters satisfy the inequalities \\(d\\leq\\mathcal{O}(n^{1-1/D})\\) and \\(kd^{2/(D-1)}\\leq\\mathcal{O}(n)\\) \\cite{arxiv:2203.17216}.\n\nA weight-four GB code of an odd distance \\(d=2r+1\\) must have length \\(n\\geq 1+d^{2}\\).\nFor an even distance \\(d=2r\\), the length \\(n\\geq d^{2}\\) \\cite{arxiv:2203.17216}.\n","features":{"rate":"GB codes can achieve an asymptotic rate of  1/4 \\cite{arxiv:2203.17216}.\nFor an odd prime \\(\\ell\\), let a prime \\(p\\) be a quadratic residue modulo \\(\\ell\\), i.e. \\(p=m^{2}\\text{mod}\\ell\\) for some integer \\(m\\).\nThen, \\(x^{\\ell}-1\\) has only three irreducible factors in \\(GF(q)(x)\\), and there is a quadratic-residue cyclic code \\([\\ell,(\\ell+1)/2, d]_p\\) with \\(d\\geq\\sqrt{\\ell}\\) and an irreducible generator polynomial CITE BibID: 2487773.\nUsing the GV distance \\(d_{GV}\\), a prime-field GB code with parameters \\([[ 2\\ell,(\\ell-1)/2,d\\geq \\ell^{1/2}]]_p\\) exists.\n","decoders":["BP-OSD decoder \\cite{arXiv:1904.02703}."]},"relations":{"parents":[{"code_id":"galois_css","detail":"A GB code is a Galois-qudit CSS code constructed from a pair of equivalent index-two quasi-cyclic linear codes."},{"code_id":"quantum_quasi_cyclic","detail":"An index-\\(m\\) quasi-cyclic (QC) code of length \\(n=m\\ell\\) is usually defined as a linear-code invariant under the \\(m\\)-step shift permutation \\(T_{n}^{m}\\)."}],"cousins":[{"code_id":"sc_qldpc","detail":"Qubit GB stabilizer generator matrices can be used as sub-matrices to define a 1D SC-QLDPC code \\cite{arxiv:2305.00137}."},{"code_id":"qldpc","detail":"A code GB\\((a,b)\\) is given by the sum of weights of polynomials \\(a(x)\\) and \\(b(x)\\). The GB code ansatz is convenient for designing quantum LDPC codes."},{"code_id":"single_shot","detail":"In some GB error-correcting schemes, localized syndrome measurement errors only give rise to localized errors in the correction stage. Then, a single round of measurements is enough, and fault-tolerant error correction is quantum-local \\cite{arxiv:1404.5504}."},{"code_id":"quantum_cyclic","detail":"Given a canonical generating polynomial \\(g(x)\\) of a cyclic quantum code \\([[n,k,d]]\\), its generator matrix is a cyclic matrix \\(G=g(P)\\). Here \\(P\\) is the permutation matrix of one-step length-\\(n\\) cyclic shift."},{"code_id":"hypergraph_product","detail":"An arbitrary GB code of length \\(2\\ell\\) is equivalent to a rotated quantum hypergraph-product code with periodicity vectors \\(\\vec{L}_{1}\\) and \\(\\vec{L}_{2}\\) such that \\(\\lvert{\\vec{L}_{1}\\times\\vec{L}_{2}=\\ell}\\rvert\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-02"},{"user_id":"LeonidPryadko","date":"2023-05-02"},{"user_id":"RenyuWang","date":"2023-05-02"}]},"_zoodb":{"id":"generalized_bicycle","source_file_path":"codes/quantum/qudits_galois/qldpc/generalized_bicycle.yml","source_file_modification_token":1683978912620.5525}},"lifted_product":{"code_id":"lifted_product","physical":"galois","logical":"galois","name":"Lifted-product (LP) code","short_name":"LP","introduced":"\\cite{arxiv:1904.02703,arXiv:2111.03654}","description":"Also called a \\textit{Panteleev-Kalachev (PK)} code. Code that utilizes the notion of a lifted product in its construction. Lifted products of certain classical Tanner codes are the first (asymptotically) \\textit{good QLDPC codes}.\n\nA \\textit{lifted product over} a ring \\(R\\) is a product of two chain complexes whose chains are free modules over \\(R\\). An interesting case is when \\(R=\\mathbb{F}_q G\\), the group-\\(G\\) algebra over the finite field \\({\\mathbb{F}}_q = GF(q)\\); in this case, the product can be called a \\(G\\)-\\textit{lifted product}. Just like its further generalization the balanced product, a lifted product code generalizes a hypergraph product code in that a reduction of symmetry is exploited to decrease the number of physical qubits required.\n\nThe key operation behind the \\(G\\)-lifted product is the \\(G\\)-\\textit{lift}, a group-algebraic version of the \\hyperref[topic:lifting]{lifting} procedure of protograph LDPC codes.\nA \\(G\\)-lift of a \\(\\mathbb{F}_q\\)-valued matrix \\(A\\) substitutes matrix elements of \\(A\\) with matrices forming the regular representation of the group algebra \\({\\mathbb{F}}_q G\\) according to some rule.\nA combination of the lift and the usual hypergraph product yields lifted-product codes.\nThe two operations commute: one can first take the usual hypergraph product of two chain complexes, and then lift the resulting product complex; equivalently, one can take the hypergraph product of the two lifted complexes.\n","protection":"Code performance strongly depends on the group \\(G\\) used in the product \\cite{arxiv:2012.04068}.","features":{"rate":"There is no known simple way to compute the logical dimension \\(k\\) in the general case \\cite{arxiv:2012.04068}."},"notes":["Formerly known as \\textit{generalized hypergraph product codes} \\cite{arXiv:1904.02703}, and later renamed to lifted-product codes \\cite{arXiv:2012.04068,doi:10.1103/PRXQuantum.2.040101}."],"relations":{"parents":[{"code_id":"balanced_product"}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-01-17"},{"user_id":"FinneganVoichick","date":"2021-12-14"},{"user_id":"PavelPanteleev","date":"2021-11-30"}]},"_zoodb":{"id":"lifted_product","source_file_path":"codes/quantum/qudits_galois/qldpc/lifted_product.yml","source_file_modification_token":1683723711002.672}},"galois_5_1_3":{"code_id":"galois_5_1_3","physical":"galois","logical":"galois","name":"\\([[5,1,3]]_q\\) Galois-qudit code","introduced":"\\cite{preset:GottesmanBook}","description":"True stabilizer code that generalizes the five-qubit perfect code to Galois qudits of prime-power dimension \\(q=p^m\\). It has \\(4(m-1)\\) stabilizer generators expressed as \\(X^{\\gamma} Z^{\\gamma} Z^{-\\gamma} X^{-\\gamma} I\\) and its cyclic permutations, with \\(\\gamma\\) iterating over basis elements of \\(GF(q)\\) over \\(GF(p)\\).\n","notes":["This code is described in a talk by \\href{https://ethz.ch/content/vp/en/conferences/2014/qec/05_thursday/dab6ca18-7453-4197-aaaa-8b1964ece714.html}{Gottesman}."],"relations":{"parents":[{"code_id":"galois_true_stabilizer"},{"code_id":"quantum_cyclic"},{"code_id":"small_distance"}]},"_meta":{"changelog":[{"user_id":"SarahMengLi","date":"2022-02-21"},{"user_id":"VictorVAlbert","date":"2022-02-21"},{"user_id":"VictorVAlbert","date":"2023-01-14"}]},"_zoodb":{"id":"galois_5_1_3","source_file_path":"codes/quantum/qudits_galois/small/galois_5_1_3.yml","source_file_modification_token":1679678315336.1309}},"galois_css":{"code_id":"galois_css","physical":"galois","logical":"galois","name":"Galois-qudit CSS code","introduced":"\\cite{arXiv:quant-ph/9512032,doi:10.1103/PhysRevLett.77.793,arXiv:quant-ph/9601029,arxiv:quant-ph/9608049,arxiv:quant-ph/0312164,doi:10.1016/j.disc.2007.08.038}","description":"An \\([[n,k,d]]_q \\) Galois-qudit true stabilizer code admitting a set of stabilizer generators that\nare either \\(Z\\)-type or \\(X\\)-type Galois-qudit Pauli strings.\nCodes can be defined from chain complexes over \\(GF(q)\\) via an extension of \\hyperref[topic:CSS-to-homology-correspondence]{qubit CSS-to-homology correspondence} to Galois qudits.\n\nThe stabilizer generator matrix, taking values from \\(GF(q)\\), is of the form\n\\begin{align}\nH=\\begin{pmatrix}0 & H_{Z}\\\\\nH_{X} & 0\n\\end{pmatrix}\n\\label{eq:parityg}\n\\end{align}\nsuch that the rows of the two blocks must be orthogonal\n\\begin{align}\nH_X H_Z^T=0~.\n\\label{eq:commG}\n\\end{align}\nThe above condition guarantees that the \\(X\\)-stabilizer generators, defined in the symplectic representation as rows of \\(H_X\\), commute with the \\(Z\\)-stabilizer generators associated with \\(H_Z\\).\n\nEncoding is based on two related \\hyperref[code:q-ary_linear]{\\(q\\)-ary linear codes},\nan \\([n,k_X,d_X]_q \\) code \\(C_X\\) and \\([n,k_Z,d_Z]_q \\) code \\(C_Z\\),\nsatisfying \\(C_X^\\perp \\subseteq C_Z\\).\nThe resulting CSS code has \\(k=k_X+k_Z-n\\) logical qubits and distance \\(d\\geq\\min\\{d_X,d_Z\\}\\).\nThe \\(H_X\\) (\\(H_Z\\)) block of \\(H\\) \\eqref{eq:parityg} is the parity-check matrix of the code \\(C_X\\) (\\(C_Z\\)). The requirement \\(C_X^\\perp \\subseteq C_Z\\) guarantees \\eqref{eq:commG}.\nBasis states for the code are, for \\(\\gamma \\in C_X\\),\n\\begin{align}\n|\\gamma + C_Z^\\perp \\rangle = \\frac{1}{\\sqrt{|C_Z^\\perp|}} \\sum_{\\eta \\in C_Z^\\perp} |\\gamma + \\eta\\rangle.\n\\end{align}\n","protection":"Detects errors on \\(d-1\\) qubits, corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qubits.","relations":{"parents":[{"code_id":"galois_true_stabilizer","detail":"Galois-qudit CSS codes are true stabilizer codes \\cite{preset:GottesmanBook}."},{"code_id":"css"}],"cousins":[{"code_id":"q-ary_linear","detail":"Construction uses two related \\(q\\)-ary linear codes \\(C_X\\) and \\(C_Z\\)."},{"code_id":"q-ary_cyclic","detail":"Galois CSS codes can be constructed using self-orthogonal \\(q\\)-ary cyclic codes \\cite{arxiv:1608.06674}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-09-28"},{"user_id":"LeonidPryadko","date":"2022-02-16"},{"user_id":"DanielGottesman","date":"2022-02-16"},{"user_id":"VictorVAlbert","date":"2022-02-16"},{"user_id":"QingfengKeeWang","date":"2022-01-07"}]},"_zoodb":{"id":"galois_css","source_file_path":"codes/quantum/qudits_galois/stabilizer/galois_css.yml","source_file_modification_token":1681484685100.25}},"galois_stabilizer":{"code_id":"galois_stabilizer","physical":"galois","logical":"galois","name":"Galois-qudit stabilizer code","introduced":"\\cite{doi:10.1109/18.959288,arXiv:quant-ph/0508070}","description":"An \\(((n,K,d))_q\\) Galois-qudit code whose logical subspace is the joint eigenspace of commuting Galois-qudit Pauli operators forming the code's stabilizer group \\(\\mathsf{S}\\). Traditionally, the logical subspace is the joint \\(+1\\) eigenspace, and the stabilizer group does not contain \\(e^{i \\phi} I\\) for any \\(\\phi \\neq 0\\). The distance \\(d\\) is the minimum weight of a Galois-qudit Pauli string that implements a nontrivial logical operation in the code.\n\nA Galois-qudit stabilizer code encoding an integer number of qudits (\\(K=q^k\\)) is denoted as \\([[n,k]]_q\\) or \\([[n,k,d]]_q\\). This notation differentiates between Galois-qudit and modular-qudit \\([[n,k,d]]_{\\mathbb{Z}_q}\\) stabilizer codes, although the same notation is usually used for both. Galois-qudit stabilizer codes need not encode an integer number of qudits, with \\(K=q^{n-\\frac{r}{m}}\\), where \\(r\\) is the number of generators of the stabilizer group, and \\(q=p^m\\) given prime \\(p\\) for all Galois qudits. As a result, \\([[n,k,d]]\\) notation is often used with non-integer \\(k=\\log_q K\\).\n\nThe stabilizer commutation condition can equivalently be stated in the symplectic representation. A pair of Galois-qudit stabilizers on \\(n\\) Galois qudits with symplectic representation vectors \\((a|b)\\) and \\((a^{\\prime}|b^{\\prime})\\) commute iff their \\textit{trace symplectic inner product} is zero,\n\\begin{align}\n\\text{tr}(a \\cdot b^{\\prime} - a^{\\prime}\\cdot b) = \\sum_{j=1}^{n} \\text{tr}(a_j b^{\\prime}_j - a^{\\prime}_i b_i) = 0~.\n\\end{align}\nSymplectic representations of stabilizer group elements thus form a self-orthogonal subspace of \\(GF(q)^{2n}\\) with respect to the trace-symplectic inner product.\n\nNote that the above trace-symplectic inner product reduces to the \\textit{symplectic inner product} when the trace is removed, and a symplectic self-orthogonal set of vectors is automatically trace-symplectic self-orthogonal. More generally, any additive classical code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code (see children).\n","protection":"Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits. Corrects errors on \\(\\left\\lfloor (d-1)/2 \\right\\rfloor\\) qudits.","features":{"encoders":["Encoder with \\(O(n^2)\\) gates can be determined in classical runtime of order \\(O(n^3)\\) \\cite{arxiv:quant-ph/0211014}."],"general_gates":["As opposed to modular qudits for composite \\(q\\), Galois qudits inherit most of the properties of the prime-qudit Clifford group due to the correspondence between a \\(q=p^m\\) Galois qudit and \\(m\\) prime qudits of dimension \\(p\\) \\cite{doi:10.1109/18.959288}."]},"notes":["The number of Galois-qudit stabilizer codes was determined in Ref. \\cite{arxiv:quant-ph/0602001}."],"relations":{"parents":[{"code_id":"non_stabilizer","detail":"A non-stabilizer code is also a stabilizer code if its Fourier description \\(\\mathsf{B}\\) is a subgroup of some Gottesman subgroup \\(\\mathsf{S}\\). When \\(\\mathsf{B}\\) is just a subset, the code is explicitly not a stabilizer code."},{"code_id":"stabilizer"}],"cousins":[{"code_id":"qudit_stabilizer","detail":"Recalling that \\(q=p^m\\), Galois-qudit stabilizer codes can also be treated as prime-qudit stabilizer codes on \\(mn\\) qudits, giving \\(k=nm-r\\) \\cite{doi:10.1109/18.959288}. The case \\(m=1\\) reduces to conventional prime-qudit stabilizer codes on \\(n\\) qudits."},{"code_id":"q-ary_additive","detail":"Galois-qudit stabilizer codes are the closest quantum analogues of additive codes over \\(GF(q)\\) because addition in the field corresponds to multiplication of stabilizers in the quantum case."},{"code_id":"dual_additive","detail":"An additive code of length \\(2n\\) over \\(GF(q)\\) that is self-orthogonal with respect to the trace-symplectic inner product corresponds to symplectic representations of an \\(n\\) Galois-qudit stabilizer group \\cite{doi:10.1109/18.959288}. Moreover, any additive code whose self-orthogonality under some inner product (such as Hermitian, Euclidean, or symplectic) implies trace-symplectic self-orthogonality of an equivalent code can be used to construct a Galois-qudit stabilizer code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"},{"user_id":"VictorVAlbert","date":"2022-04-13"},{"user_id":"LeonidPryadko","date":"2022-04-13"},{"user_id":"VictorVAlbert","date":"2022-01-12"},{"user_id":"QingfengKeeWang","date":"2022-01-07"}]},"_zoodb":{"id":"galois_stabilizer","source_file_path":"codes/quantum/qudits_galois/stabilizer/galois_stabilizer.yml","source_file_modification_token":1681484685100.3477}},"galois_true_stabilizer":{"code_id":"galois_true_stabilizer","physical":"galois","logical":"galois","name":"True Galois-qudit stabilizer code","short_name":"True stabilizer","introduced":"\\cite{doi:10.1109/18.959288,arxiv:quant-ph/0508070,preset:GottesmanBook}","description":"Also called a \\textit{linear stabilizer code}. A \\([[n,k,d]]_q\\) stabilizer code whose stabilizer's symplectic representation forms a linear subspace. In other words, the set of \\(q\\)-ary vectors representing the stabilizer group is closed under both addition and multiplication by elements of \\(GF(q)\\). In contrast, Galois-qudit stabilizer codes admit sets of vectors that are closed under addition only.\n\nThe number of generators \\(r\\) for a true stabilizer code is a multiple of \\(m\\) (recall that \\(q=p^m\\) for Galois qudits). As a result, the number \\(k=n-r/m\\) of logical qudits is an integer.\n\nEach code can be represented by a stabilizer generator matrix \\(H=(A|B)\\), where each row \\((a|b)\\) is the \\(GF(q)\\)-valued symplectic representation of a stabilizer generator.\n\nA Hermitian self-orthogonal linear \\([n,k,d]_{q^2}\\) code can be used to construct an \\([[n,n-2k]]_q\\) true stabilizer code with distance no less than \\(d\\).\nThis \\textit{Hermitian construction} was first proven via the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. \\cite{doi:10.1109/18.959288}, Corr. 1), and later proven via the \\hyperref[code:stabilizer_over_gfqsq]{stabilizer-over-\\(GF(q^2)\\)} construction (showing self-orthogonality under the trace-alternating inner product; see Ref. \\cite{arxiv:quant-ph/0508070}, Corr. 19). There is an isomorphism between the symplectic and stabilizer-over-\\(GF(q^2)\\) representations \\cite[Thm. 27.3.8]{preset:HKSquantum}. The Hermitian construction has been extended to \\(q^{2m}\\)-ary Hermitian self-orthogonal linear codes \\cite{arxiv:2012.11998} and similar constructions exist \\cite{arxiv:1002.4088}.\n","protection":"Detects errors on up to \\(d-1\\) qudits, and corrects erasure errors on up to \\(d-1\\) qudits.","notes":["See Ref. \\cite{doi:10.1017/CBO9781139034807.014}\\cite{preset:HKSquantum} for introductions to various stabilizer code constructions."],"relations":{"parents":[{"code_id":"galois_stabilizer"}],"cousins":[{"code_id":"q-ary_linear","detail":"A true Galois-qudit stabilizer code is the closest quantum analogue of a linear code over \\(GF(q)\\) because the \\(q\\)-ary vectors corresponding to the symplectic representation of the stabilizers form a linear subspace."},{"code_id":"dual","detail":"Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) yield true stabilizer codes via either the symplectic representation (showing self-orthogonality under the trace-symplectic inner product; see Ref. \\cite{doi:10.1109/18.959288}, Corr. 1) or the \\hyperref[code:stabilizer_over_gfqsq]{stabilizer-over-\\(GF(q^2)\\)} construction (showing self-orthogonality under the trace-alternating inner product; see \\cite[Corr. 19]{arxiv:quant-ph/0508070}\\cite[Thm. 27.3.8]{preset:HKSquantum}."},{"code_id":"quantum_mds","detail":"Many MDS codes are constructed from Hermitian self-orthogonal codes over \\(GF(q^2)\\) using the Hermitian construction \\cite{arxiv:quant-ph/0312164,arxiv:0906.2509,arxiv:1507.08355,arxiv:1803.07927}, in particular from cyclic \\cite{doi:10.1109/TIT.2011.2159039}, constacyclic \\cite{doi:10.1109/TIT.2014.2308180,doi:10.1109/TIT.2015.2388576} and negacyclic \\cite{doi:10.1109/TIT.2012.2220519} codes."},{"code_id":"matrix_product","detail":"Hermitian self-orthogonal matrix-product codes over \\(GF(q^2)\\) can be used to construct true stabilizer codes \\cite{doi:10.1007/s11128-020-02921-0,arxiv:1604.05823}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"},{"user_id":"DanielGottesman","date":"2022-02-17"},{"user_id":"VictorVAlbert","date":"2022-02-17"}]},"_zoodb":{"id":"galois_true_stabilizer","source_file_path":"codes/quantum/qudits_galois/stabilizer/galois_true_stabilizer.yml","source_file_modification_token":1682250129452.71}},"quantum_secret_sharing":{"code_id":"quantum_secret_sharing","physical":"galois","logical":"galois","name":"Approximate secret-sharing code","introduced":"\\cite{arXiv:quant-ph/0503139}","description":"A family of \\( [[n,k,d]]_q \\) CSS codes approximately correcting errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) qubits, i.e., with approximate distance approaching the no-cloning bound \\(n/2\\). Constructed using a non-degenerate CSS code, such as a polynomial quantum code, and a classical authentication scheme. The code can be viewed as an \\(t\\)-error tolerant secret sharing scheme. Since the code yields a small logical subspace using large registers that contain both classical and quantum information, it is not useful for practical error correction problems, but instead demonstrates the power of approximate quantum error correction.","protection":"Corrects up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors with fidelity exponentially lose to 1.","features":{"encoders":["Uses a quantum authentication scheme, which is a keyed system in which a valid state has high fidelity, and a classical secret-sharing scheme."],"decoders":["Decoding is analagous to reconstruction in a secret sharing scheme and is done in polynomial time. The only required operations are verification of quantum authentication, which is a pair of polynomial-time quantum algorithms that check if the fidelity of the received state is close to 1, and erasure correction for a stabilizer code, which involves solving a system of linear equations."]},"relations":{"parents":[{"code_id":"galois_css","detail":"The code required to construct this code must be a non-degenerate Galois-qubit CSS code."}],"cousins":[{"code_id":"approximate_qecc","detail":"Secret-sharing codes approximately correct errors on up to \\(\\lfloor (n-1)/2 \\rfloor\\) errors."},{"code_id":"galois_polynomial","detail":"Polynomial codes can be used for a specific construction of this code."},{"code_id":"reed_solomon","detail":"The classical information in this code is encoded using a Reed-Solomon code."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-15"},{"user_id":"ManasiShingane","date":"2021-12-14"}]},"_zoodb":{"id":"quantum_secret_sharing","source_file_path":"codes/quantum/qudits_galois/stabilizer/quantum_secret_sharing.yml","source_file_modification_token":1681484685100.4966}},"quantum_singleton":{"code_id":"quantum_singleton","physical":"galois","logical":"galois","name":"Singleton-bound approaching AQECC","introduced":"\\cite{arXiv:2212.09935}","description":"Approximate quantum code of rate \\(R\\) that can tolerate adversarial errors nearly saturating the quantum Singleton bound of \\((1-R)/2\\).\nThe formulation of such codes relies on a notion of \\textit{quantum list decoding}.\nSampling a description of this code can be done with an efficient randomized algorithm with \\(2^{-\\Omega(n)}\\) failure probability.\n","protection":"For any \\(\\gamma>0\\) and rate \\(0<R<1\\), these approximate quantum \\([[n,R \\cdot n]]_q\\) codes have constant Galois-qudit dimension \\(q=q(\\gamma)\\) and correct errors acting on \\((1-R-\\gamma) \\cdot n/2\\) registers, up to a recovery error of \\(2^{-\\Omega(n)}\\).","features":{"rate":"Given rate \\(R\\), tolerate adversarial errors nearly saturating the quantum Singleton bound of \\((1-R)/2\\).","encoders":["Efficient encoding."],"decoders":["Quantum list decodable \\cite{arXiv:2212.09935}."]},"relations":{"parents":[{"code_id":"galois_css"},{"code_id":"approximate_qecc"}],"cousins":[{"code_id":"quantum_mds","detail":"Singleton-bound approaching AQECCs saturate the quantum Singleton bound."},{"code_id":"galois_fqrs","detail":"Singleton-bound approaching AQECCs utilize FQRS codes."},{"code_id":"quantum_secret_sharing","detail":"Quantum secret-sharing codes have asymptotically decaying rate and require qudit dimension to increase exponentially with \\(n\\), while Singleton-bound approaching AQECCs have constant rate and qudit dimension."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-08"},{"user_id":"SamGunn","date":"2022-01-08"}]},"_zoodb":{"id":"quantum_singleton","source_file_path":"codes/quantum/qudits_galois/stabilizer/quantum_singleton.yml","source_file_modification_token":1681484685100.733}},"skew-cyclic_galois_css":{"code_id":"skew-cyclic_galois_css","physical":"qudits","logical":"qudits","name":"Skew-cyclic CSS code","introduced":"\\cite{doi:10.1016/j.disc.2020.112189}","description":"Stub.","relations":{"parents":[{"code_id":"galois_css"}],"cousins":[{"code_id":"skew_cyclic","detail":"Skew-cyclic CSS codes are constructed from classical skew-cyclic codes."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"NolanCoble","date":"2021-12-03"}]},"_zoodb":{"id":"skew-cyclic_galois_css","source_file_path":"codes/quantum/qudits_galois/stabilizer/skew-cyclic_galois_css.yml","source_file_modification_token":1681484685100.8062}},"stabilizer_over_gfqsq":{"code_id":"stabilizer_over_gfqsq","physical":"galois","logical":"galois","name":"Stabilizer code over \\(GF(q^2)\\)","introduced":"\\cite{arXiv:quant-ph/0508070}","description":"An \\([[n,k,d]]_q\\) Galois-qudit stabilizer code constructed from a classical code over \\(GF(q^2)\\) using the one-to-one correspondence between the Galois-qudit Pauli matrices and elements of the Galois field \\(GF(q^2)\\).\n\nAn \\(n\\) Galois-qudit Pauli stabilizer can be represented as a length-\\(n\\) vector over \\(GF(q^2)\\). The stabilizer commutation condition corresponds to a zero trace-alternating inner product between the corresponding vectors. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from classical trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\) \\cite{arXiv:quant-ph/0508070}.\nHermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal, and applying this construction to such codes yields a class of true stabilizer codes.\n","relations":{"parents":[{"code_id":"galois_true_stabilizer","detail":"Trace-alternating self-orthogonal linear codes over \\(GF(q^2)\\) are equivalent to a class of true stabilizer codes \\cite{preset:GottesmanBook}. Hermitian self-orthogonal linear codes over \\(GF(q^2)\\) are automatically trace-alternating self-orthogonal and can be used to construct true stabilizer codes via the \\hyperref[code:stabilizer_over_gfqsq]{stabilizer-over-\\(GF(q^2)\\)} construction (\\cite{arxiv:quant-ph/0508070}, Corr. 19)."}],"cousins":[{"code_id":"dual_additive","detail":"The stabilizer commutation condition for stabilizer codes over \\(GF(q^2)\\) can equivalently be stated in the representation of stabilizers as vectors over \\(GF(q^2)\\). A pair of \\(n\\) Galois-qudit stabilizers commute iff the trace-alternating inner product of their their corresponding vectors is zero. Stabilizer codes over \\(GF(q^2)\\) can thus be constructed from trace-alternating self-orthogonal additive codes over \\(GF(q^2)\\)."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-07-22"},{"user_id":"VictorVAlbert","date":"2022-03-21"}]},"_zoodb":{"id":"stabilizer_over_gfqsq","source_file_path":"codes/quantum/qudits_galois/stabilizer/stabilizer_over_gfqsq.yml","source_file_modification_token":1682420107453.99}},"gnu_permutation_invariant":{"code_id":"gnu_permutation_invariant","physical":"spins","logical":"qubits","name":"GNU permutation-invariant code","short_name":"GNU","introduced":"\\cite{arXiv:1302.3247}","description":"Can be expressed in terms of Dicke states where the logical states are\n\\begin{align}\n|\\overline{\\pm}\\rangle = \\sum_{\\ell=0}^{n} \\frac{(\\pm 1)^\\ell}{\\sqrt{2^n}} \\sqrt{n \\choose \\ell} |D^m_{g \\ell}\\rangle~.\n\\end{align}\nHere, \\(m\\) is the number of particles used for encoding \\(1\\) qubit, and \\(g, n \\leq m\\) are arbitrary positive integers.\nThe state \\(|D^m_w\\rangle\\) is a Dicke state -- a normalized permutation-invariant state on \\(m\\) spin-half systems with \\(w\\) excitations, i.e., a normalized sum over all basis elements with \\(w\\) ones and \\(m - w\\) zeroes.\n","protection":"Depends on the family. One family which is completely symmetrized versions of Bacon-Shor codes (parameterized by \\(t\\)) protects against arbitrary weight-\\(t\\) spin errors. Additionally, codes with large enough length \\((t+1)(3t+1)+t\\) can approximately correct \\(t\\) spontaneous decay errors.","relations":{"parents":[{"code_id":"spins_into_spins"},{"code_id":"permutation_invariant"}],"cousins":[{"code_id":"bacon_shor","detail":"Symmetrized versions of the Bacon-Shor codes are GNU codes"},{"code_id":"hamiltonian","detail":"GNU codes lie within the ground state of ferromagnetic Heisenberg models without an external magnetic field \\cite{arxiv:1904.01458}."},{"code_id":"approximate_qecc","detail":"GNU codes protect approximately against amplitude damping errors."},{"code_id":"binomial","detail":"Binomial codes and GNU codes related via the Holstein-Primakoff mapping \\cite{doi:10.1103/PhysRev.58.1098} (see also \\cite{doi:10.2307/3212170}). A qudit generalization of GNU codes can be obtained from qudit binomial codes \\cite[Appx. C]{arXiv:1708.05010}."},{"code_id":"quantum_repetition","detail":"GNU codewords for \\(g=1\\) reduce to the phase-flip code."},{"code_id":"metopt","detail":"GNU codes can be used to sense signals within the permutation-invariant subspace \\cite{arxiv:2212.06285}."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-04-26"},{"user_id":"VictorVAlbert","date":"2021-12-16"},{"user_id":"BenjaminQuiring","date":"2021-12-16"}]},"_zoodb":{"id":"gnu_permutation_invariant","source_file_path":"codes/quantum/spins/gnu_permutation_invariant.yml","source_file_modification_token":1683978912611.0713}},"landau_level":{"code_id":"landau_level","physical":"spins","name":"Landau-level spin code","introduced":"\\cite{arXiv:2210.16957}","description":"Approximate quantum code that encodes a qudit in the finite-dimensional Hilbert space of a single spin, i.e., a spherical Landau level.\nCodewords are approximately orthogonal Landau-level spin coherent states whose orientations are spaced maximally far apart along a great circle (equator) of the sphere.\nThe larger the spin, the better the performance.\n","protection":"Protects against equatorial rotational errors acting on the overall spin.\n","relations":{"parents":[{"code_id":"spins_into_spins"},{"code_id":"approximate_qecc","detail":"The Landau-level spin code approximately protects against rotational errors."}],"cousins":[{"code_id":"spin_gkp","detail":"The spin-GKP (Landau-level) code is a GKP-like encoding in (Landau-level) spin coherent states."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-05-12"},{"user_id":"YaleFan","date":"2023-05-12"}]},"_zoodb":{"id":"landau_level","source_file_path":"codes/quantum/spins/landau_level.yml","source_file_modification_token":1683978912611.1501}},"single_spin":{"code_id":"single_spin","physical":"spins","name":"Single-spin code","description":"Permutation invariant qubit code encoding a \\(K\\)-dimensional Hilbert space into the maximally symmetric subspace or \\textit{collective spin} of \\(2\\ell\\) spin-half systems.\nThis \\(2\\ell+1\\)-dimensional Hilbert space can be thought of as a standalone spin-\\(\\ell\\) quantum system.\n","protection":"Noise models can be categorized as those that cause the state to leave the maximally symmetric subspace and those that do not. The former include single-spin errors akin to qubit Pauli noise. The latter include collective rotations or decays.\n","features":{"transversal_gates":"When the physical Hilbert space is thought of a collective spin, logical gates for spin codes have the form \\(U^{\\otimes N}\\), where \\(U\\) is a local rotation on the physical system."},"relations":{"parents":[{"code_id":"spins_into_spins"},{"code_id":"permutation_invariant","detail":"Single-spin codes are subspaces of a single large spin, which can be either standalone or correspond to the permutation-invariant subspace of a set of spins."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-13"}]},"_zoodb":{"id":"single_spin","source_file_path":"codes/quantum/spins/single_spin.yml","source_file_modification_token":1683978912611.372}},"spin_cat":{"code_id":"spin_cat","physical":"spins","logical":"qubits","name":"Spin cat code","introduced":"\\cite{arXiv:2101.03662}","description":"An analogue of the two-component cat code designed for atomic ensembles. Was designed by using the Holstein-Primakoff mapping \\cite{doi:10.1103/PhysRev.58.1098} (see also \\cite{doi:10.2307/3212170}) to pull back the phase-space structure of a bosonic system to the compact phase space of a quantum spin.\n","relations":{"parents":[{"code_id":"single_spin"}],"cousins":[{"code_id":"two-legged-cat","detail":"The Spin-cat code construction utilizes the Holstein-Primakoff mapping \\cite{doi:10.1103/PhysRev.58.1098} (see also \\cite{doi:10.2307/3212170}) to convert cat codes into codes for spin systems."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2023-01-19"}]},"_zoodb":{"id":"spin_cat","source_file_path":"codes/quantum/spins/spin_cat.yml","source_file_modification_token":1677058672670.9915}},"spin_gkp":{"code_id":"spin_gkp","physical":"spins","logical":"qudits","name":"Spin GKP code","introduced":"\\cite{arXiv:2211.05181}","description":"An analogue of the single-mode GKP code designed for atomic ensembles. Was designed by using the Holstein-Primakoff mapping \\cite{doi:10.1103/PhysRev.58.1098} (see also \\cite{doi:10.2307/3212170}) to pull back the phase-space structure of a bosonic system to the compact phase space of a quantum spin. A different construction emerges depending on which particular expression for GKP codewords is pulled back.\n","protection":"Protect against errors native to spin systems like random rotations and stochastic relaxation.","features":{"encoders":["Linear combination of unitaries method \\cite{arxiv:1412.4687,arXiv:1610.06546,arXiv:2203.08882}, which may be applicable to more general codewords."],"general_gates":["Approximate Clifford-group generators are composed of Hamiltonians at most quadratic in angular momentum operators of two spin systems. Assuming that these generators can be implemented with high fidelity, a magic state can be prepared from an atomic ensemble analog of the vacuum state."]},"relations":{"parents":[{"code_id":"single_spin"}],"cousins":[{"code_id":"gkp","detail":"Spin-GKP code constructions utilize the Holstein-Primakoff mapping \\cite{doi:10.1103/PhysRev.58.1098} (see also \\cite{doi:10.2307/3212170}) to convert various expressions for square-lattice GKP states into codes for spin systems."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-11-13"},{"user_id":"SivaprasadOmanakuttan","date":"2022-11-13"}]},"_zoodb":{"id":"spin_gkp","source_file_path":"codes/quantum/spins/spin_gkp.yml","source_file_modification_token":1680994436864.9277}},"spins_into_spins":{"code_id":"spins_into_spins","physical":"spins","name":"Spin code","description":"Encodes \\(K\\)-dimensional Hilbert space into a \\(q^n\\)-dimensional (\\(n\\)-qudit) Hilbert space, where the canonical qudit basis consists of states of a quantum mechanical spin. In other words, canonical single-qudit states \\(|^\\ell_m\\rangle\\) are labeled by total angular momentum \\(\\ell\\) (either integer or half-integer) and its \\(z\\)-axis projection \\(m\\), with \\(q=2\\ell+1\\).\n\nIn contrast to other qudit codes, spin codes are closely associated with the angular momentum Lie algebra and/or the Lie groups \\(SU(2)\\) or \\(SO(3)\\).\n","protection":"Spin codes are often designed to protect against \\(SU(2)\\) rotations by small angles.","relations":{"parents":[{"code_id":"qecc_finite"}]},"_meta":{"changelog":[{"user_id":"ThomasWrona","date":"2022-05-18"},{"user_id":"VictorVAlbert","date":"2022-02-22"}]},"_zoodb":{"id":"spins_into_spins","source_file_path":"codes/quantum/spins/spins_into_spins.yml","source_file_modification_token":1678726895518.206}},"j_gross":{"code_id":"j_gross","physical":"spins","logical":"spins","name":"Clifford code","introduced":"\\cite{arXiv:2005.10910,arxiv:2304.08611}","description":"A spin code designed to realize a discrete group of gates using \\(SU(2)\\) rotations, which are realized transversally if the single spin is treated as a collective spin of several spin-half subsystems.\nCodewords are subspaces of a spin's Hilbert space that house irreducible representations (irreps) of a discrete subgroup of \\(SU(2)\\).\n\nThe first realization \\cite{arXiv:2005.10910} used the single-qubit Clifford group (i.e., the binary octahedral (\\(2O\\)) subgroup of \\(SU(2)\\)).\nCode construction is done by restricting the \\(SU(2)\\) irrep to \\(2O\\), and determining the carrier spaces of any nontrivial irreps of \\(2O\\). Since irreps of \\(2O\\) do not appear in integer spins, half-integer spins are used.\n\nA simple example of a codespace is a projection onto an instance of a particular irrep of \\(2O\\), referred to as either \\( \\varrho_4 \\) or \\( \\varrho_5 \\).\nIn the case of only one instance of the desired irrep present in the spin, the projection is created as follows:\n\\begin{align}\n  P_\\varrho = \\frac{\\text{dim} \\varrho}{|2O|} \\sum_{g \\in 2O} \\chi_\\varrho (g)^* D(g)~,\n\\end{align}\nwhere \\(D(g)\\) is the \\(SU(2)\\) Wigner matrix corresponding to group element \\(g\\), and the character \\(\\chi_\\varrho (g) = \\text{tr}(\\varrho(g))\\) is the trace of the desired irrep evaluated at a group element.\n\nLogical Pauli matrices \\(\\overline{\\sigma}_w\\) are defined using the above projection and the angular momentum operators:\n\\begin{align}\n  \\overline{\\sigma}_w = i P_\\varrho e^{-i \\pi J_w} P_\\varrho~.\n\\end{align}\nFinally, \\(|\\overline{0} \\rangle\\) is defined as the \\(+1\\) eigenvalue of \\(\\overline{\\sigma}_z\\) and \\(|\\overline{1} \\rangle = \\overline{\\sigma}_x |\\overline{0} \\rangle \\).\n","features":{"transversal_gates":"Discrete subgroups of \\(SU(2)\\) can be realized transversally.","general_gates":["Universal computation results from being able to prepare a single logical state, perform one measurement, and the following logical gates: the phase gate (\\( \\overline{S} \\)), the Hadamard gate (\\(\\overline{H}\\)), the conditional phase gate (\\(\\overline{CZ}\\)), and the square root of the phase gate (\\(\\overline{T}\\)). Single-qubit Cliffords can be generated using \\(\\overline{S}\\) and \\(\\overline{H}\\), the extension to multiple-qubit Cliffords is done using \\(\\overline{CZ}\\), and \\(\\overline{T}\\) is to transform to non-Clifford states. Together these gates can be used to create all logical unitaries, while preparation and measurement complete universal quantum computation."]},"relations":{"parents":[{"code_id":"single_spin"}],"cousins":[{"code_id":"qubits_into_qubits","detail":"Certain Clifford codes yield qubit codes with non-trivial distance when the single spin is treated as a collective spin of several qubits."}]},"_meta":{"changelog":[{"user_id":"VictorVAlbert","date":"2022-05-25"},{"user_id":"ThomasWrona","date":"2022-05-18"}]},"_zoodb":{"id":"j_gross","source_file_path":"codes/quantum/spins/transversal/j_gross.yml","source_file_modification_token":1683978912611.5615}},"qubit_stabilizer_oaqecc":{"code_id":"qubit_stabilizer_oaqecc","physical":"qubits","logical":"qubits","name":"Qubit stabilizer operator-algebra quantum error-correcting code","short_name":"Qubit stabilizer OAQECC","introduced":"\\cite{arxiv:2304.11442}","description":"Operator-algebra QECC in which the commutant \\(\\mathcal{A}'\\) of the logical algebra \\(\\mathcal{A}\\) arises as the group algebra of a subgroup \\(\\mathsf{G}\\) of the \\(n\\)-qubit Pauli group \\(\\mathsf{P}_n\\).\nThe stabilizer \\(\\mathsf{S}\\) is the center of \\(\\mathsf{G}\\) modulo factors of \\(i I\\). The quotient \\(\\mathsf{P}_n / \\mathsf{N(S)}\\), where \\(\\mathsf{N(S)}\\) is the normalizer of \\(\\mathsf{S}\\), is in bijective correspondence with the factors of the logical algebra \\(\\mathcal{A}\\).","protection":"Specialized conditions for the correctability of \\(\\mathcal{A}\\) with respect to an error operation \\(\\mathcal{E}\\) with operation elements \\(\\{E_j\\}_j\\) can be given in group theoretic terms.\nIndeed, \\(\\mathcal{A}\\) is correctable for \\(\\mathcal{E}\\) if, for all \\(j,k\\),\n\\[E_j^\\dagger E_k \\notin (\\mathsf{N(S)} - \\mathsf{G}) \\bigcup \\big(\\bigcup_{\\tau, \\sigma: \\tau \\mathsf{N(S)} \\neq \\sigma \\mathsf{N(S)}} \\tau \\mathsf{N(S)} \\sigma\\big)~.\\]","relations":{"parents":[{"code_id":"oaecc"}]},"_meta":{"changelog":[{"user_id":"MichaelLiu","date":"2023-17-06"}]},"_zoodb":{"id":"qubit_stabilizer_oaqecc","source_file_path":"codes/qubit_stabilizer_oaqecc.yml","source_file_modification_token":1689550329220.048}}},"space":{"bits":{"space_id":"bits","_zoodb":{"id":"bits","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"q-ary_digits":{"space_id":"q-ary_digits","_zoodb":{"id":"q-ary_digits","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"matrices":{"space_id":"matrices","_zoodb":{"id":"matrices","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"rings":{"space_id":"rings","_zoodb":{"id":"rings","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"reals":{"space_id":"reals","_zoodb":{"id":"reals","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"spheres":{"space_id":"spheres","_zoodb":{"id":"spheres","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"qubits":{"space_id":"qubits","_zoodb":{"id":"qubits","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"qudits":{"space_id":"qudits","_zoodb":{"id":"qudits","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"galois":{"space_id":"galois","_zoodb":{"id":"galois","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"oscillators":{"space_id":"oscillators","_zoodb":{"id":"oscillators","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"spins":{"space_id":"spins","_zoodb":{"id":"spins","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"rigid_bodies":{"space_id":"rigid_bodies","_zoodb":{"id":"rigid_bodies","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"categories":{"space_id":"categories","_zoodb":{"id":"categories","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}},"groups":{"space_id":"groups","_zoodb":{"id":"groups","source_file_path":"code_extra/spaces.yml","source_file_modification_token":1675636035676.4382}}},"domain":{"classical_domain":{"domain_id":"classical_domain","name":"Classical Domain","description":"Codes for communication over classical channels","_zoodb":{"id":"classical_domain","source_file_path":"codetree/domains.yml","source_file_modification_token":1675636035680.0933}},"quantum_domain":{"domain_id":"quantum_domain","name":"Quantum Domain","description":"Codes for quantum communication over quantum channels","_zoodb":{"id":"quantum_domain","source_file_path":"codetree/domains.yml","source_file_modification_token":1675636035680.0933}},"quantum_into_classical_domain":{"domain_id":"quantum_into_classical_domain","name":"Classical-quantum Domain","description":"Codes for classical communication over quantum channels","_zoodb":{"id":"quantum_into_classical_domain","source_file_path":"codetree/domains.yml","source_file_modification_token":1675636035680.0933}}},"kingdom":{"bits_into_bits":{"parent_domain":{"domain_id":"classical_domain"},"kingdom_id":"bits_into_bits","name":"Binary Kingdom","kingdom_code":{"code_id":"bits_into_bits"},"_zoodb":{"id":"bits_into_bits","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"q-ary_digits_into_q-ary_digits":{"parent_domain":{"domain_id":"classical_domain"},"kingdom_id":"q-ary_digits_into_q-ary_digits","name":"Galois-field Kingdom","kingdom_code":{"code_id":"q-ary_digits_into_q-ary_digits"},"_zoodb":{"id":"q-ary_digits_into_q-ary_digits","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"matrices_into_matrices":{"parent_domain":{"domain_id":"classical_domain"},"kingdom_id":"matrices_into_matrices","name":"Matrix Kingdom","kingdom_code":{"code_id":"matrices_into_matrices"},"_zoodb":{"id":"matrices_into_matrices","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"analog":{"parent_domain":{"domain_id":"classical_domain"},"kingdom_id":"analog","name":"Analog Kingdom","kingdom_code":{"code_id":"analog"},"_zoodb":{"id":"analog","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"points_into_spheres":{"parent_domain":{"domain_id":"classical_domain"},"kingdom_id":"points_into_spheres","name":"Spherical Kingdom","kingdom_code":{"code_id":"points_into_spheres"},"_zoodb":{"id":"points_into_spheres","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"rings_into_rings":{"parent_domain":{"domain_id":"classical_domain"},"kingdom_id":"rings_into_rings","name":"Ring Kingdom","kingdom_code":{"code_id":"rings_into_rings"},"_zoodb":{"id":"rings_into_rings","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"group_classical":{"parent_domain":{"domain_id":"classical_domain"},"kingdom_id":"group_classical","name":"Group Kingdom","kingdom_code":{"code_id":"group_classical"},"_zoodb":{"id":"group_classical","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"qubits_into_qubits":{"parent_domain":{"domain_id":"quantum_domain"},"kingdom_id":"qubits_into_qubits","name":"Qubit Kingdom","kingdom_code":{"code_id":"qubits_into_qubits"},"_zoodb":{"id":"qubits_into_qubits","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"qudits_into_qudits":{"parent_domain":{"domain_id":"quantum_domain"},"kingdom_id":"qudits_into_qudits","name":"Modular-qudit Kingdom","kingdom_code":{"code_id":"qudits_into_qudits"},"_zoodb":{"id":"qudits_into_qudits","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"galois_into_galois":{"parent_domain":{"domain_id":"quantum_domain"},"kingdom_id":"galois_into_galois","name":"Galois-qudit Kingdom","kingdom_code":{"code_id":"galois_into_galois"},"_zoodb":{"id":"galois_into_galois","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"oscillators":{"parent_domain":{"domain_id":"quantum_domain"},"kingdom_id":"oscillators","name":"Bosonic Kingdom","kingdom_code":{"code_id":"oscillators"},"_zoodb":{"id":"oscillators","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"spins_into_spins":{"parent_domain":{"domain_id":"quantum_domain"},"kingdom_id":"spins_into_spins","name":"Spin Kingdom","kingdom_code":{"code_id":"spins_into_spins"},"_zoodb":{"id":"spins_into_spins","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"group_quantum":{"parent_domain":{"domain_id":"quantum_domain"},"kingdom_id":"group_quantum","name":"Group Kingdom","kingdom_code":{"code_id":"group_quantum"},"_zoodb":{"id":"group_quantum","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"category_quantum":{"parent_domain":{"domain_id":"quantum_domain"},"kingdom_id":"category_quantum","name":"Category Kingdom","kingdom_code":{"code_id":"category_quantum"},"_zoodb":{"id":"category_quantum","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"qubit_classical_into_quantum":{"parent_domain":{"domain_id":"quantum_into_classical_domain"},"kingdom_id":"qubit_classical_into_quantum","name":"Binary c-q Kingdom","kingdom_code":{"code_id":"qubit_classical_into_quantum"},"_zoodb":{"id":"qubit_classical_into_quantum","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}},"bosonic_classical_into_quantum":{"parent_domain":{"domain_id":"quantum_into_classical_domain"},"kingdom_id":"bosonic_classical_into_quantum","name":"Bosonic/analog c-q Kingdom","kingdom_code":{"code_id":"bosonic_classical_into_quantum"},"_zoodb":{"id":"bosonic_classical_into_quantum","source_file_path":"codetree/kingdoms.yml","source_file_modification_token":1675636035680.2202}}},"codelist":{"ag":{"list_id":"ag","title":"Algebraic-geometry codes","intro":"Here is a list of \\hyperref[code:ag]{algebraic-geometry} codes constructed\nusing algebraic curves.","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"ag"}]},"_zoodb":{"id":"ag","source_file_path":"codelists/descendants/classical/list_ag.yml","source_file_modification_token":1675636035676.6816}},"binary_linear":{"list_id":"binary_linear","title":"Binary linear codes\n","intro":"Here is a list of \\hyperref[code:binary_linear]{binary linear codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"binary_linear"}]},"_zoodb":{"id":"binary_linear","source_file_path":"codelists/descendants/classical/list_binary_linear.yml","source_file_modification_token":1675636035676.816}},"evaluation":{"list_id":"evaluation","title":"Evaluation codes\n","intro":"Here is a list of \\hyperref[code:evaluation_varieties]{evaluation} codes.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"evaluation_varieties"}]},"_zoodb":{"id":"evaluation","source_file_path":"codelists/descendants/classical/list_evaluation.yml","source_file_modification_token":1675636035676.9353}},"ldpc":{"list_id":"ldpc","title":"LDPC codes\n","intro":"Here is a list of \\hyperref[code:ldpc]{LDPC codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"q-ary_ldpc"}]},"_zoodb":{"id":"ldpc","source_file_path":"codelists/descendants/classical/list_ldpc.yml","source_file_modification_token":1683723710985.471}},"mds":{"list_id":"mds","title":"MDS codes\n","intro":"Here is a list of code families which contain \\hyperref[code:mds]{MDS codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true},{"relationship_property":"mds","property":"detail","title":"MDS Detail","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"mds"},{"cousin_of":"mds"},{"cousin_of":"griesmer"}]},"_zoodb":{"id":"mds","source_file_path":"codelists/descendants/classical/list_mds.yml","source_file_modification_token":1675636035677.1375}},"perfect":{"list_id":"perfect","title":"Perfect codes\n","intro":"Here is a list of code families which contain \\hyperref[code:perfect]{perfect codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"perfect"},{"cousin_of":"perfect"}]},"_zoodb":{"id":"perfect","source_file_path":"codelists/descendants/classical/list_perfect.yml","source_file_modification_token":1675636035677.275}},"q-ary_linear":{"list_id":"q-ary_linear","title":"\\(q\\)-ary linear codes\n","intro":"Here is a list of \\hyperref[code:q-ary_linear]{\\(q\\)-ary linear codes} over the Galois field \\(GF(q)\\).\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"q-ary_linear"}]},"_zoodb":{"id":"q-ary_linear","source_file_path":"codelists/descendants/classical/list_q-ary_linear.yml","source_file_modification_token":1675636035677.3706}},"approximate_qecc":{"list_id":"approximate_qecc","title":"Approximate quantum codes\n","intro":"Here is a list of \\hyperref[code:approximate_qecc]{approximate quantum codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"approximate_qecc"},{"cousin_of":"approximate_qecc"}]},"_zoodb":{"id":"approximate_qecc","source_file_path":"codelists/descendants/quantum/list_approximate.yml","source_file_modification_token":1675636035677.5647}},"css":{"list_id":"css","title":"Quantum CSS codes\n","intro":"Here is a list of quantum CSS codes for \\hyperref[code:css]{qubits} and qudits.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"css"},{"descendant_of":"qudit_css"},{"descendant_of":"galois_css"}]},"_zoodb":{"id":"css","source_file_path":"codelists/descendants/quantum/list_css.yml","source_file_modification_token":1675636035677.6587}},"dynamic_gen":{"list_id":"dynamic_gen","title":"Dynamically generated quantum codes\n","intro":"Here is a list of quantum \\hyperref[code:dynamic_gen]{dynamically generated codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"dynamic_gen"},{"cousin_of":"dynamic_gen"}]},"_zoodb":{"id":"dynamic_gen","source_file_path":"codelists/descendants/quantum/list_dynamic_gen.yml","source_file_modification_token":1675636035677.7925}},"good_qldpc":{"list_id":"good_qldpc","title":"Asymptotically good QLDPC codes\n","intro":"Here is a list of \\hyperref[code:good_qldpc]{good QLDPC} codes.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"cousin_of":"good_qldpc"}]},"_zoodb":{"id":"good_qldpc","source_file_path":"codelists/descendants/quantum/list_good_qldpc.yml","source_file_modification_token":1675636035677.878}},"hamiltonian":{"list_id":"hamiltonian","title":"Hamiltonian-based codes\n","intro":"Here is a list of quantum \\hyperref[code:hamiltonian]{Hamiltonian-based codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"hamiltonian"},{"cousin_of":"hamiltonian"}]},"_zoodb":{"id":"hamiltonian","source_file_path":"codelists/descendants/quantum/list_hamiltonian.yml","source_file_modification_token":1675636035678.013}},"holographic":{"list_id":"holographic","title":"Holographic codes\n","intro":"Here is a list of \\hyperref[code:holographic]{holographic codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"holographic"}]},"_zoodb":{"id":"holographic","source_file_path":"codelists/descendants/quantum/list_holographic.yml","source_file_modification_token":1675636035678.107}},"homological":{"list_id":"homological","title":"Quantum codes based on homological products\n","intro":"Here is a list of \\hyperref[code:generalized_homological_product]{generalized homological product} and related codes.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"generalized_homological_product"}]},"_zoodb":{"id":"homological","source_file_path":"codelists/descendants/quantum/list_homological.yml","source_file_modification_token":1680994436842.8213}},"qldpc":{"list_id":"qldpc","title":"Quantum LDPC codes\n","intro":"Here is a list of \\hyperref[code:qldpc]{QLDPC codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"qldpc"}]},"_zoodb":{"id":"qldpc","source_file_path":"codelists/descendants/quantum/list_qldpc.yml","source_file_modification_token":1675636035678.279}},"quantum_mds":{"list_id":"quantum_mds","title":"Quantum MDS codes\n","intro":"Here is a list of code families which contain \\hyperref[code:quantum_mds]{quantum MDS codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true},{"relationship_property":"quantum_mds","property":"detail","title":"MDS Detail","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"quantum_mds"},{"cousin_of":"quantum_mds"}]},"_zoodb":{"id":"quantum_mds","source_file_path":"codelists/descendants/quantum/list_quantum_mds.yml","source_file_modification_token":1675636035678.4202}},"quantum_perfect":{"list_id":"quantum_perfect","title":"Perfect quantum codes\n","intro":"Here is a list of code families which contain \\hyperref[code:quantum_perfect]{perfect quantum codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"quantum_perfect"},{"cousin_of":"quantum_perfect"}]},"_zoodb":{"id":"quantum_perfect","source_file_path":"codelists/descendants/quantum/list_quantum_perfect.yml","source_file_modification_token":1677058672659.2812}},"single":{"list_id":"single","title":"Small-distance codes\n","intro":"Here is a list of codes defined on \\(n\\) identical subsystems (e.g., qubits, modular qudits, or Galois qudits) that detect or correct an error on at most one subsystem.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"small_distance"}]},"_zoodb":{"id":"single","source_file_path":"codelists/descendants/quantum/list_single.yml","source_file_modification_token":1677058672659.3735}},"stabilizer":{"list_id":"stabilizer","title":"Stabilizer codes\n","intro":"Here is a list of quantum \\hyperref[code:stabilizer]{stabilizer codes}. For a list of \\hyperref[code:css]{CSS codes}, see \\href{https://errorcorrectionzoo.org/list/css}{list of CSS codes}. \n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"stabilizer"}]},"_zoodb":{"id":"stabilizer","source_file_path":"codelists/descendants/quantum/list_stabilizer.yml","source_file_modification_token":1675636035678.8616}},"subsystem":{"list_id":"subsystem","title":"Subsystem codes\n","intro":"Here is a list of quantum \\hyperref[code:oecc]{subsystem codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"oecc"}]},"_zoodb":{"id":"subsystem","source_file_path":"codelists/descendants/quantum/list_subsystem.yml","source_file_modification_token":1675636035678.9343}},"quantum_surface":{"list_id":"quantum_surface","title":"Surface code and friends\n","intro":"Here is a list of codes related to and generalizing the \\hyperref[code:surface]{Kitaev surface code}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"clifford-deformed_surface"},{"descendant_of":"higher_dimensional_surface"},{"descendant_of":"quantum_double"},{"cousin_of":"surface"}]},"_zoodb":{"id":"quantum_surface","source_file_path":"codelists/descendants/quantum/list_surface.yml","source_file_modification_token":1680994436842.9114}},"topological":{"list_id":"topological","title":"Topological codes\n","intro":"Here is a list of quantum \\hyperref[code:topological]{topological codes}.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Code","link_to_code":true,"cssclass":"top left"},{"property":"description","title":"Description","cssclass":"textit","first_paragraph_only":true}]}},"sort":{"by":"name"},"codes":{"select":[{"descendant_of":"topological"}]},"_zoodb":{"id":"topological","source_file_path":"codelists/descendants/quantum/list_topological.yml","source_file_modification_token":1678573155815.381}},"quantum_code_cap_threshold":{"list_id":"quantum_code_cap_threshold","title":"Quantum codes with code capacity thresholds\n","intro":"Here is a list of all quantum codes that admit code capacity thresholds.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"features.code_capacity_threshold","title":"Threshold","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"features.code_capacity_threshold","descendant_of":"oaecc"}]},"_zoodb":{"id":"quantum_code_cap_threshold","source_file_path":"codelists/features/list_code_cap_threshold.yml","source_file_modification_token":1675636035679.2742}},"decoders":{"list_id":"decoders","title":"Codes with notable decoders\n","intro":"Here is a list of all classical and quantum codes that have notable decoders.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"features.decoders","title":"Decoder(s)","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"features.decoders","descendant_of":"oaecc"},{"property_set":"features.decoders","descendant_of":"eacq"}]},"_zoodb":{"id":"decoders","source_file_path":"codelists/features/list_decoders.yml","source_file_modification_token":1675636035679.362}},"quantum_fault_tolerance":{"list_id":"quantum_fault_tolerance","title":"Quantum codes with fault-tolerant gadgets\n","intro":"Here is a list of all quantum codes with fault-tolerant gadgets.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"features.fault_tolerance","title":"Fault-tolerant gadget","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"features.fault_tolerance","descendant_of":"oaecc"}]},"_zoodb":{"id":"quantum_fault_tolerance","source_file_path":"codelists/features/list_fault_tolerance.yml","source_file_modification_token":1675636035679.4668}},"quantum_magic":{"list_id":"quantum_magic","title":"Quantum codes with magic-state distillation scaling exponents\n","intro":"Here is a list of all quantum codes useful for distilling magic states and characterized\nby their magic-state distillation scaling exponent.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"features.magic_scaling_exponent","title":"Magic-state scaling exponent","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"features.magic_scaling_exponent","descendant_of":"oaecc"}]},"_zoodb":{"id":"quantum_magic","source_file_path":"codelists/features/list_magic.yml","source_file_modification_token":1675636035679.5476}},"quantum_with_rate":{"list_id":"quantum_with_rate","title":"Quantum codes with a rate\n","intro":"Here is a list of all quantum codes that specify what rate they have.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"features.rate","title":"Rate","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"features.rate","domain":"quantum_domain","descendant_of":"oaecc"}]},"_zoodb":{"id":"quantum_with_rate","source_file_path":"codelists/features/list_quantum_with_rate.yml","source_file_modification_token":1682251971585.7788}},"realizations":{"list_id":"realizations","title":"Codes with applications\n","intro":"Here is a list of all classical and quantum codes that have been realized in experimental or real-world devices.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"realizations","title":"Realization(s)","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"realizations","descendant_of":"oaecc"}]},"_zoodb":{"id":"realizations","source_file_path":"codelists/features/list_realizations.yml","source_file_modification_token":1675636035679.69}},"quantum_threshold":{"list_id":"quantum_threshold","title":"Quantum codes with other thresholds\n","intro":"Here is a list of all quantum codes that admit thresholds other than code capacity thresholds.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"features.threshold","title":"Threshold","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"features.threshold","descendant_of":"oaecc"}]},"_zoodb":{"id":"quantum_threshold","source_file_path":"codelists/features/list_threshold.yml","source_file_modification_token":1675636035679.7585}},"quantum_transversal":{"list_id":"quantum_transversal","title":"Quantum codes with transversal gates\n","intro":"Here is a list of all quantum codes that admit transversal gates. Applicable to codes living in a tensor-product space,\nsuch gates can be written as a tensor product of unitary operations, with each operation acting on its corresponding subsystem.\n","display":{"style":"table","options":{"cssclass":"xtra-xtra-stretch","columns":[{"property":"name","title":"Name","link_to_code":true,"cssclass":"small left top"},{"property":"features.transversal_gates","title":"Transversal gates","cssclass":"small top"}]}},"codes":{"select":[{"property_set":"features.transversal_gates","descendant_of":"oaecc"}]},"_zoodb":{"id":"quantum_transversal","source_file_path":"codelists/features/list_transversal.yml","source_file_modification_token":1675636035679.832}},"all":{"list_id":"all","title":"Index of all codes\n","intro":"Here are a gigantic list of all the codes, sorted alphabetically, that were\nincluded in the error correction zoo.\n","display":{"style":"index","options":{"show_description":false}},"codes":{"select":[{}]},"sort":{"by":"name"},"_zoodb":{"id":"all","source_file_path":"codelists/list_all.yml","source_file_modification_token":1675636035679.956}}},"user":{"M10T":{"user_id":"M10T","name":"Milan Tenn","githubusername":"M10T","_zoodb":{"id":"M10T","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"AlexCowtan":{"user_id":"AlexCowtan","name":"Alexander Cowtan","githubusername":"alexcowtan","gscholaruser":"lBTgt3cAAAAJ","_zoodb":{"id":"AlexCowtan","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MichaelLiu":{"user_id":"MichaelLiu","name":"Michael Liu","_zoodb":{"id":"MichaelLiu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"YaleFan":{"user_id":"YaleFan","name":"Yale Fan","_zoodb":{"id":"YaleFan","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"RenyuWang":{"user_id":"RenyuWang","name":"Renyu Wang","_zoodb":{"id":"RenyuWang","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"nathanan":{"user_id":"nathanan","name":"Nathanan Tantivasadakarn","gscholaruser":"QUj3lAIAAAAJ","_zoodb":{"id":"nathanan","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"KeLiu":{"user_id":"KeLiu","name":"Ke Liu (刘科 子竞)","gscholaruser":"9Xn3T6EAAAAJ","_zoodb":{"id":"KeLiu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ChristopheVuillot":{"user_id":"ChristopheVuillot","name":"Christophe Vuillot","gscholaruser":"G6IqzFIAAAAJ","githubusername":"ChristopheVuillot","_zoodb":{"id":"ChristopheVuillot","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JasSidhu":{"user_id":"JasSidhu","name":"Jasminder Sidhu","gscholaruser":"jFHb8uQAAAAJ","_zoodb":{"id":"JasSidhu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"YaronJarach":{"user_id":"YaronJarach","name":"Yaron Jarach","_zoodb":{"id":"YaronJarach","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ShubhamPJain":{"user_id":"ShubhamPJain","name":"Shubham P. Jain","githubusername":"shubhamj810","_zoodb":{"id":"ShubhamPJain","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"Baobach":{"user_id":"Baobach","name":"Bao Bach","githubusername":"bachbao","_zoodb":{"id":"Baobach","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"SarahMengLi":{"user_id":"SarahMengLi","name":"Sarah Meng Li","gscholaruser":"PvIx1RcAAAAJ","githubusername":"SarahMLi","_zoodb":{"id":"SarahMengLi","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"BaileyGu":{"user_id":"BaileyGu","name":"Shouzhen (Bailey) Gu","_zoodb":{"id":"BaileyGu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"VikramAmin":{"user_id":"VikramAmin","name":"Vikram Elijah Amin","_zoodb":{"id":"VikramAmin","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"SamGunn":{"user_id":"SamGunn","name":"Sam Gunn","gscholaruser":"KOUwHVYAAAAJ","_zoodb":{"id":"SamGunn","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"khalilguy":{"user_id":"khalilguy","name":"Khalil Guy","gscholaruser":"KTjDjOEAAAAJ","_zoodb":{"id":"khalilguy","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"IvanBurenkov":{"user_id":"IvanBurenkov","name":"Ivan A. Burenkov","gscholaruser":"KTjDjOEAAAAJ","_zoodb":{"id":"IvanBurenkov","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MengCheng":{"user_id":"MengCheng","name":"Meng Cheng (程蒙)","gscholaruser":"3lyNWR0AAAAJ","_zoodb":{"id":"MengCheng","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"SivaprasadOmanakuttan":{"user_id":"SivaprasadOmanakuttan","name":"Sivaprasad Omanakuttan","gscholaruser":"4_fuQdUAAAAJ","_zoodb":{"id":"SivaprasadOmanakuttan","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"HarryZhou":{"user_id":"HarryZhou","name":"Hengyun (Harry) Zhou","gscholaruser":"XLHpQy8AAAAJ","_zoodb":{"id":"HarryZhou","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"HyunseokJeong":{"user_id":"HyunseokJeong","name":"Hyunseok Jeong","gscholaruser":"__73pJ0AAAAJ","_zoodb":{"id":"HyunseokJeong","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"EugeneTang":{"user_id":"EugeneTang","name":"Eugene Tang","gscholaruser":"q9Pxs4oAAAAJ","_zoodb":{"id":"EugeneTang","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"HassanShapourian":{"user_id":"HassanShapourian","name":"Hassan Shapourian","gscholaruser":"Jv7tPW0AAAAJ","_zoodb":{"id":"HassanShapourian","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MichaelVasmer":{"user_id":"MichaelVasmer","name":"Michael Vasmer","githubusername":"MikeVasmer","gscholaruser":"YWXgW2wAAAAJ","_zoodb":{"id":"MichaelVasmer","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"NikolasBreuckmann":{"user_id":"NikolasBreuckmann","name":"Nikolas Breuckmann","githubusername":"nikobreu","gscholaruser":"en1CbxsAAAAJ","_zoodb":{"id":"NikolasBreuckmann","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JoschkaRoffe":{"user_id":"JoschkaRoffe","name":"Joschka Roffe","githubusername":"quantumgizmos","gscholaruser":"vGDLxeoAAAAJ","_zoodb":{"id":"JoschkaRoffe","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"PavelPanteleev":{"user_id":"PavelPanteleev","name":"Pavel Panteleev","gscholaruser":"adjeaUkAAAAJ","_zoodb":{"id":"PavelPanteleev","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MichaelGullans":{"user_id":"MichaelGullans","name":"Michael Gullans","githubusername":"mgullans","gscholaruser":"YP7rWbkAAAAJ","_zoodb":{"id":"MichaelGullans","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"NolanCoble":{"user_id":"NolanCoble","name":"Nolan Coble","githubusername":"nolanjcoble","pageurl":"https://nolanjcoble.com","_zoodb":{"id":"NolanCoble","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"DhruvDevulapalli":{"user_id":"DhruvDevulapalli","name":"Dhruv Devulapalli","githubusername":"dhruvdevu","_zoodb":{"id":"DhruvDevulapalli","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"XiaozhenFu":{"user_id":"XiaozhenFu","name":"Xiaozhen Fu","githubusername":"merrysalad","_zoodb":{"id":"XiaozhenFu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"SrilekhaGandhari":{"user_id":"SrilekhaGandhari","name":"Srilekha Gandhari","githubusername":"gndhari","_zoodb":{"id":"SrilekhaGandhari","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JosephTIosue":{"user_id":"JosephTIosue","name":"Joseph T. Iosue","githubusername":"jtiosue","pageurl":"https://jtiosue.github.io/pages/about/about.html","_zoodb":{"id":"JosephTIosue","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JonathanKunjummen":{"user_id":"JonathanKunjummen","name":"Jonathan Kunjummen","githubusername":"jkunjummen","_zoodb":{"id":"JonathanKunjummen","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"SeyedSajjadNezhadi":{"user_id":"SeyedSajjadNezhadi","name":"Seyed Sajjad Nezhadi","githubusername":"sajjad-nezhadi","pageurl":"https://sajjad-nezhadi.github.io","_zoodb":{"id":"SeyedSajjadNezhadi","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"QingfengKeeWang":{"user_id":"QingfengKeeWang","name":"Qingfeng (Kee) Wang","githubusername":"kee-wang","_zoodb":{"id":"QingfengKeeWang","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"YijiaXu":{"user_id":"YijiaXu","name":"Yijia Xu","githubusername":"xuyij","pageurl":"https://xuyij.github.io/homepage/","_zoodb":{"id":"YijiaXu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ElizabethRBennewitz":{"user_id":"ElizabethRBennewitz","name":"Elizabeth R. Bennewitz","githubusername":"ebennewitz","_zoodb":{"id":"ElizabethRBennewitz","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"EricKubischta":{"user_id":"EricKubischta","name":"Eric Kubischta","githubusername":"eric-kub","_zoodb":{"id":"EricKubischta","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JonNelson":{"user_id":"JonNelson","name":"Jon Nelson","githubusername":"jnelson1","_zoodb":{"id":"JonNelson","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MariannaPodzorova":{"user_id":"MariannaPodzorova","name":"Marianna Podzorova","_zoodb":{"id":"MariannaPodzorova","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"BenjaminQuiring":{"user_id":"BenjaminQuiring","name":"Benjamin Quiring","githubusername":"bquiring","_zoodb":{"id":"BenjaminQuiring","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JoelRajakumar":{"user_id":"JoelRajakumar","name":"Joel Rajakumar","githubusername":"joeldraj4","_zoodb":{"id":"JoelRajakumar","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ManasiShingane":{"user_id":"ManasiShingane","name":"Manasi Shingane","_zoodb":{"id":"ManasiShingane","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"IanTeixeira":{"user_id":"IanTeixeira","name":"Ian Teixeira","githubusername":"iangteixeira","_zoodb":{"id":"IanTeixeira","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"FinneganVoichick":{"user_id":"FinneganVoichick","name":"Finnegan Voichick","githubusername":"fvoichick","_zoodb":{"id":"FinneganVoichick","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"SiddharthTaneja":{"user_id":"SiddharthTaneja","name":"Siddharth Taneja","githubusername":"staneja1","_zoodb":{"id":"SiddharthTaneja","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"XinyuanZheng":{"user_id":"XinyuanZheng","name":"Xinyuan Zheng","githubusername":"xzheng16","_zoodb":{"id":"XinyuanZheng","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ChrisFechisin":{"user_id":"ChrisFechisin","name":"Chris Fechisin","githubusername":"fechisin","_zoodb":{"id":"ChrisFechisin","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"AntonioDCorcoles":{"user_id":"AntonioDCorcoles","name":"Antonio D. Córcoles","gscholaruser":"_nYGfnIAAAAJ","_zoodb":{"id":"AntonioDCorcoles","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ArpitDua":{"user_id":"ArpitDua","name":"Arpit Dua","githubusername":"dua-arpit","gscholaruser":"w4ASA38AAAAJ","_zoodb":{"id":"ArpitDua","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"AleksanderKubica":{"user_id":"AleksanderKubica","name":"Aleksander Kubica","gscholaruser":"D8VDo7YAAAAJ","_zoodb":{"id":"AleksanderKubica","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"LiangJiang":{"user_id":"LiangJiang","name":"Liang Jiang","gscholaruser":"-4vWibwAAAAJ","_zoodb":{"id":"LiangJiang","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"StevenTFlammia":{"user_id":"StevenTFlammia","name":"Steven T. Flammia","gscholaruser":"-VnX0xYAAAAJ","_zoodb":{"id":"StevenTFlammia","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"AlexisSchotte":{"user_id":"AlexisSchotte","name":"Alexis Schotte","githubusername":"AlexisSchotte","_zoodb":{"id":"AlexisSchotte","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"DavidAasen":{"user_id":"DavidAasen","name":"David Aasen","githubusername":"davidaasen","gscholaruser":"vNuuzc8AAAAJ","_zoodb":{"id":"DavidAasen","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"LaneGGunderman":{"user_id":"LaneGGunderman","name":"Lane G. Gunderman","gscholaruser":"L8OpvIIAAAAJ","_zoodb":{"id":"LaneGGunderman","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"BasudhaSrivastava":{"user_id":"BasudhaSrivastava","name":"Basudha Srivastava","gscholaruser":"W61wyBUAAAAJ","_zoodb":{"id":"BasudhaSrivastava","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ChristopherChamberland":{"user_id":"ChristopherChamberland","name":"Christopher Chamberland","gscholaruser":"Rb9SG3wAAAAJ","_zoodb":{"id":"ChristopherChamberland","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JonathanConrad":{"user_id":"JonathanConrad","name":"Jonathan Conrad","gscholaruser":"ETjTNJ8AAAAJ","_zoodb":{"id":"JonathanConrad","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JingzhenHu":{"user_id":"JingzhenHu","name":"Jingzhen Hu","gscholaruser":"TjPWHhcAAAAJ","_zoodb":{"id":"JingzhenHu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MuhammadJunaidAftab":{"user_id":"MuhammadJunaidAftab","name":"Muhammad Junaid Aftab","githubusername":"MJunaidAftab","_zoodb":{"id":"MuhammadJunaidAftab","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"RichardBarney":{"user_id":"RichardBarney","name":"Richard Barney","githubusername":"rbarney4","_zoodb":{"id":"RichardBarney","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MustafaDoger":{"user_id":"MustafaDoger","name":"Mustafa Doger","githubusername":"mustafadgr","_zoodb":{"id":"MustafaDoger","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ArminGerami":{"user_id":"ArminGerami","name":"Armin Gerami","githubusername":"armingerami","_zoodb":{"id":"ArminGerami","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ShashankSule":{"user_id":"ShashankSule","name":"Shashank Sule","githubusername":"ShashankSule","_zoodb":{"id":"ShashankSule","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"YiTingRickTu":{"user_id":"YiTingRickTu","name":"Yi-Ting (Rick) Tu","githubusername":"ricktu288","gscholaruser":"Dt8I_IYAAAAJ","_zoodb":{"id":"YiTingRickTu","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"XiaoXiao":{"user_id":"XiaoXiao","name":"Xiao Xiao","githubusername":"xiaoxiao9689","_zoodb":{"id":"XiaoXiao","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JiaxinHuang":{"user_id":"JiaxinHuang","name":"Jiaxin Huang","githubusername":"jackkyyh","_zoodb":{"id":"JiaxinHuang","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"KennethRBrown":{"user_id":"KennethRBrown","name":"Kenneth R. Brown","gscholaruser":"EFVX84sAAAAJ","_zoodb":{"id":"KennethRBrown","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"AnqiGong":{"user_id":"AnqiGong","name":"Anqi Gong","githubusername":"gongaa","_zoodb":{"id":"AnqiGong","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JoaoRibeiro":{"user_id":"JoaoRibeiro","name":"João Ribeiro","gscholaruser":"_v-WdQUAAAAJ","_zoodb":{"id":"JoaoRibeiro","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"AlexanderGrimm":{"user_id":"AlexanderGrimm","name":"Alexander Grimm","gscholaruser":"_9aGEQ4AAAAJ","_zoodb":{"id":"AlexanderGrimm","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"SisiZhou":{"user_id":"SisiZhou","name":"Sisi Zhou","gscholaruser":"i-m2j4oAAAAJ","_zoodb":{"id":"SisiZhou","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"FelixHuber":{"user_id":"FelixHuber","name":"Felix Huber","gscholaruser":"1O58f3gAAAAJ","_zoodb":{"id":"FelixHuber","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"TonyLau":{"user_id":"TonyLau","name":"Tony Lau","githubusername":"Tonexus","_zoodb":{"id":"TonyLau","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MazinKarjikar":{"user_id":"MazinKarjikar","name":"Mazin Karjikar","githubusername":"MazinKarjikar","_zoodb":{"id":"MazinKarjikar","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MicahShaw":{"user_id":"MicahShaw","name":"Micah Shaw","githubusername":"MicahShaw","_zoodb":{"id":"MicahShaw","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ThomasWrona":{"user_id":"ThomasWrona","name":"Thomas Wrona","githubusername":"thomaswrona","_zoodb":{"id":"ThomasWrona","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"NoahBerthusen":{"user_id":"NoahBerthusen","name":"Noah Berthusen","githubusername":"noahberthusen","_zoodb":{"id":"NoahBerthusen","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"JackDavis":{"user_id":"JackDavis","name":"Jack Davis","githubusername":"JackGDavis","_zoodb":{"id":"JackDavis","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ShuubhamOjha":{"user_id":"ShuubhamOjha","name":"Shuubham Ojha","githubusername":"shuubham4","_zoodb":{"id":"ShuubhamOjha","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"GraceSommers":{"user_id":"GraceSommers","name":"Grace Sommers","_zoodb":{"id":"GraceSommers","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"balopat":{"user_id":"balopat","name":"Balint Pato","gscholaruser":"mnNvWjkAAAAJ","githubusername":"balopat","pageurl":"https://refactorium.com/","_zoodb":{"id":"balopat","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"MarcusPS":{"user_id":"MarcusPS","name":"Marcus P da Silva","githubusername":"marcusps","gscholaruser":"qsKgI6AAAAAJ","_zoodb":{"id":"MarcusPS","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"ChrisPattison":{"user_id":"ChrisPattison","name":"Christopher A. Pattison","githubusername":"chrispattison","gscholaruser":"4neYf8oAAAAJ","_zoodb":{"id":"ChrisPattison","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"VictorVAlbert":{"user_id":"VictorVAlbert","name":"Victor V. Albert","zooteam":"core","zoorole":"zookeeper","githubusername":"valbert4","gscholaruser":"hyddAfkAAAAJ","pageurl":"https://sites.google.com/site/victorvalbert","_zoodb":{"id":"VictorVAlbert","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"PhilippeFaist":{"user_id":"PhilippeFaist","name":"Philippe Faist","zooteam":"core","zoorole":"architect","githubusername":"phfaist","gscholaruser":"rdeNGqMAAAAJ","pageurl":"https://phfaist.com","_zoodb":{"id":"PhilippeFaist","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"DanielGottesman":{"user_id":"DanielGottesman","zooteam":"veterinarians","name":"Daniel Gottesman","gscholaruser":"6eJtRigAAAAJ","pageurl":"https://quics.umd.edu/people/daniel-gottesman","avatarurl":"https://quics.umd.edu/sites/quics.umd.edu/files//styles/medium/public/pictures/picture-561-1626034639.jpg","_zoodb":{"id":"DanielGottesman","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"AlexanderBarg":{"user_id":"AlexanderBarg","zooteam":"veterinarians","name":"Alexander Barg","gscholaruser":"nvU3IvEAAAAJ","pageurl":"https://user.eng.umd.edu/~abarg/","githubusername":"AlexanderBarg","avatarurl":"https://user.eng.umd.edu/~abarg/picture1.jpg","_zoodb":{"id":"AlexanderBarg","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}},"LeonidPryadko":{"user_id":"LeonidPryadko","zooteam":"veterinarians","name":"Leonid Pryadko","gscholaruser":"S8iAOo4AAAAJ","githubusername":"LeonidPryadko","pageurl":"http://www.faculty.ucr.edu/~leonid/","avatarurl":"https://profiles.ucr.edu/api/profilePicture/35106","_zoodb":{"id":"LeonidPryadko","source_file_path":"users/users_db.yml","source_file_modification_token":1689550329220.355}}}}}}